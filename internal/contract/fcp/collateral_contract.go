// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package fcp

import (
	"errors"
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
	_ = abi.ConvertType
)

// SwanCreditCollateralCPInfo is an auto generated low-level Go binding around an user-defined struct.
type SwanCreditCollateralCPInfo struct {
	CpAccount        common.Address
	AvailableBalance *big.Int
	LockedCollateral *big.Int
	Status           string
}

// SwanCreditCollateralContractInfo is an auto generated low-level Go binding around an user-defined struct.
type SwanCreditCollateralContractInfo struct {
	SlashedFunds    *big.Int
	BaseCollateral  *big.Int
	CollateralRatio *big.Int
	SlashRatio      *big.Int
}

// SwanCreditCollateralTask is an auto generated low-level Go binding around an user-defined struct.
type SwanCreditCollateralTask struct {
	CpList           []common.Address
	Collateral       *big.Int
	CollateralStatus uint8
}

// FcpCollateralMetaData contains all meta data concerning the FcpCollateral contract.
var FcpCollateralMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"}],\"name\":\"BeaconUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"cp\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"frozenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balanceAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"operation\",\"type\":\"string\"}],\"name\":\"CollateralAdjusted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"cp\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"taskUid\",\"type\":\"string\"}],\"name\":\"CollateralLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"cp\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"taskUid\",\"type\":\"string\"}],\"name\":\"CollateralSlashed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"string\",\"name\":\"taskUid\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"enumSwanCreditCollateral.CollateralStatus\",\"name\":\"newStatus\",\"type\":\"uint8\"}],\"name\":\"CollateralStatusChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"cp\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"taskUid\",\"type\":\"string\"}],\"name\":\"CollateralUnlocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fundingWallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"cpAccount\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"challenger\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"taskUid\",\"type\":\"string\"}],\"name\":\"DisputeProof\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"string\",\"name\":\"taskUid\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"cpAccountAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"}],\"name\":\"TaskCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"cpOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"cpAccount\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collateralContratOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"slashfund\",\"type\":\"uint256\"}],\"name\":\"WithdrawSlash\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"availableBalance\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collateralInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"slashedFunds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slashRatio\",\"type\":\"uint256\"}],\"internalType\":\"structSwanCreditCollateral.ContractInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collateralRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cpAddress\",\"type\":\"address\"}],\"name\":\"cpInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"cpAccount\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"availableBalance\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"lockedCollateral\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"status\",\"type\":\"string\"}],\"internalType\":\"structSwanCreditCollateral.CPInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"cpStatus\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cpAccount\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"taskUid\",\"type\":\"string\"}],\"name\":\"disputeProof\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"taskUid\",\"type\":\"string\"}],\"name\":\"getTaskInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address[]\",\"name\":\"cpList\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"},{\"internalType\":\"enumSwanCreditCollateral.CollateralStatus\",\"name\":\"collateralStatus\",\"type\":\"uint8\"}],\"internalType\":\"structSwanCreditCollateral.Task\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"taskUid\",\"type\":\"string\"},{\"internalType\":\"address[]\",\"name\":\"cpList\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"taskCollateral\",\"type\":\"uint256\"}],\"name\":\"lockCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lockedCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxiableUUID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"removeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sendETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_baseCollateral\",\"type\":\"uint256\"}],\"name\":\"setBaseCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"setCollateralToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_slashRatio\",\"type\":\"uint256\"}],\"name\":\"setSlashRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"taskUid\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"cpAccount\",\"type\":\"address\"}],\"name\":\"slashCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"slashRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"slashedFunds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"tasks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"},{\"internalType\":\"enumSwanCreditCollateral.CollateralStatus\",\"name\":\"collateralStatus\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"taskUid\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unlockCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cpAccount\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawSlashedFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x60a06040523073ffffffffffffffffffffffffffffffffffffffff1660809073ffffffffffffffffffffffffffffffffffffffff1681525034801561004357600080fd5b5061005261005760201b60201c565b6101f1565b600060019054906101000a900460ff16156100a7576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161009e9061019a565b60405180910390fd5b60ff801660008054906101000a900460ff1660ff16146101155760ff6000806101000a81548160ff021916908360ff1602179055507f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb384740249860ff60405161010c91906101d6565b60405180910390a15b565b600082825260208201905092915050565b7f496e697469616c697a61626c653a20636f6e747261637420697320696e69746960008201527f616c697a696e6700000000000000000000000000000000000000000000000000602082015250565b6000610184602783610117565b915061018f82610128565b604082019050919050565b600060208201905081810360008301526101b381610177565b9050919050565b600060ff82169050919050565b6101d0816101ba565b82525050565b60006020820190506101eb60008301846101c7565b92915050565b60805161491a61022860003960008181610a9001528181610b1e015281816111af0152818161123d01526112ed015261491a6000f3fe6080604052600436106101ee5760003560e01c8063704802751161010d578063a0821be3116100a0578063d27ca89b1161006f578063d27ca89b146106d9578063dd98fff514610704578063e80d9dec1461072d578063f2fde38b14610756578063f3fef3a31461077f576101ee565b8063a0821be31461060b578063a664c21614610648578063b4eae1cb14610685578063ce3518aa146106b0576101ee565b8063853911b2116100dc578063853911b21461054f5780638da5cb5b1461057857806392bdf9ba146105a35780639b5ddf09146105e0576101ee565b806370480275146104cf578063715018a6146104f85780637f58a7e51461050f5780638129fc1c14610538576101ee565b80634f1ef2861161018557806358709cf21161015457806358709cf21461041457806364a197f314610452578063666181a91461047b5780636f99f15c146104a4576101ee565b80634f1ef2861461037757806352d1902d1461039357806353ad8720146103be57806354fd4d50146103e9576101ee565b80633659cfe6116101c15780633659cfe6146102bf5780633fe65177146102e857806347e7ef24146103255780634b9f0bea1461034e576101ee565b80631785f53c146101f35780631b2094631461021c57806324d7806c146102595780632894493f14610296575b600080fd5b3480156101ff57600080fd5b5061021a60048036038101906102159190612e31565b6107a8565b005b34801561022857600080fd5b50610243600480360381019061023e9190612fa4565b61080b565b604051610250919061318b565b60405180910390f35b34801561026557600080fd5b50610280600480360381019061027b9190612e31565b610916565b60405161028d91906131c8565b60405180910390f35b3480156102a257600080fd5b506102bd60048036038101906102b8919061320f565b610936565b005b3480156102cb57600080fd5b506102e660048036038101906102e19190612e31565b610a8e565b005b3480156102f457600080fd5b5061030f600480360381019061030a9190612e31565b610c16565b60405161031c91906132bb565b60405180910390f35b34801561033157600080fd5b5061034c600480360381019061034791906132dd565b610cb6565b005b34801561035a57600080fd5b506103756004803603810190610370919061331d565b610e21565b005b610391600480360381019061038c919061341a565b6111ad565b005b34801561039f57600080fd5b506103a86112e9565b6040516103b5919061348f565b60405180910390f35b3480156103ca57600080fd5b506103d36113a2565b6040516103e091906134ff565b60405180910390f35b3480156103f557600080fd5b506103fe6113d8565b60405161040b9190613529565b60405180910390f35b34801561042057600080fd5b5061043b60048036038101906104369190612fa4565b6113e1565b604051610449929190613553565b60405180910390f35b34801561045e57600080fd5b50610479600480360381019061047491906132dd565b611428565b005b34801561048757600080fd5b506104a2600480360381019061049d9190612e31565b61147b565b005b3480156104b057600080fd5b506104b96114c7565b6040516104c69190613529565b60405180910390f35b3480156104db57600080fd5b506104f660048036038101906104f19190612e31565b6114cd565b005b34801561050457600080fd5b5061050d611530565b005b34801561051b57600080fd5b506105366004803603810190610531919061320f565b611544565b005b34801561054457600080fd5b5061054d6115da565b005b34801561055b57600080fd5b5061057660048036038101906105719190613644565b611797565b005b34801561058457600080fd5b5061058d611b0f565b60405161059a91906136de565b60405180910390f35b3480156105af57600080fd5b506105ca60048036038101906105c59190612e31565b611b39565b6040516105d79190613529565b60405180910390f35b3480156105ec57600080fd5b506105f5611b51565b6040516106029190613529565b60405180910390f35b34801561061757600080fd5b50610632600480360381019061062d9190612e31565b611b57565b60405161063f9190613712565b60405180910390f35b34801561065457600080fd5b5061066f600480360381019061066a9190612e31565b611b6f565b60405161067c91906137e9565b60405180910390f35b34801561069157600080fd5b5061069a611cfa565b6040516106a79190613529565b60405180910390f35b3480156106bc57600080fd5b506106d760048036038101906106d2919061320f565b611d00565b005b3480156106e557600080fd5b506106ee611d12565b6040516106fb9190613529565b60405180910390f35b34801561071057600080fd5b5061072b6004803603810190610726919061380b565b611d18565b005b34801561073957600080fd5b50610754600480360381019061074f9190612fa4565b61206d565b005b34801561076257600080fd5b5061077d60048036038101906107789190612e31565b6120c9565b005b34801561078b57600080fd5b506107a660048036038101906107a191906132dd565b61214c565b005b6107b0612413565b600060cd60008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff02191690831515021790555050565b610813612c7f565b60ce8260405161082391906138a3565b9081526020016040518091039020604051806060016040529081600082018054806020026020016040519081016040528092919081815260200182805480156108c157602002820191906000526020600020905b8160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019060010190808311610877575b50505050508152602001600182015481526020016002820160009054906101000a900460ff1660028111156108f9576108f86130c4565b5b600281111561090b5761090a6130c4565b5b815250509050919050565b60cd6020528060005260406000206000915054906101000a900460ff1681565b61093e612413565b8060c9541015610983576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161097a9061392c565b60405180910390fd5b8060c96000828254610995919061397b565b9250508190555060d260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb33836040518363ffffffff1660e01b81526004016109f99291906139af565b6020604051808303816000875af1158015610a18573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a3c9190613a04565b503373ffffffffffffffffffffffffffffffffffffffff167fbfd9c82485e2178fcfd5c40379d8e66fe60acc50aa1ef4c50966431eb1e381cd82604051610a839190613529565b60405180910390a250565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff1603610b1c576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610b1390613aa3565b60405180910390fd5b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16610b5b612491565b73ffffffffffffffffffffffffffffffffffffffff1614610bb1576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610ba890613b35565b60405180910390fd5b610bba816124e8565b610c1381600067ffffffffffffffff811115610bd957610bd8612e79565b5b6040519080825280601f01601f191660200182016040528015610c0b5781602001600182028036833780820191505090505b5060006124f3565b50565b60d16020528060005260406000206000915090508054610c3590613b84565b80601f0160208091040260200160405190810160405280929190818152602001828054610c6190613b84565b8015610cae5780601f10610c8357610100808354040283529160200191610cae565b820191906000526020600020905b815481529060010190602001808311610c9157829003601f168201915b505050505081565b60d260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd3330846040518463ffffffff1660e01b8152600401610d1593929190613bb5565b6020604051808303816000875af1158015610d34573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d589190613a04565b508060cf60008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254610da89190613bec565b925050819055508173ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f5548c837ab068cf56a2c2479df0882a4922fd203edb7517321831d95078c5f6283604051610e0c9190613529565b60405180910390a3610e1d82612661565b5050565b60cd60003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff16610ead576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610ea490613ca2565b60405180910390fd5b600060ce83604051610ebf91906138a3565b908152602001604051809103902090506000816001015490506000818411610ee75783610ee9565b815b905080836001016000828254610eff919061397b565b9250508190555060005b836000018054905081101561112a578160d06000866000018481548110610f3357610f32613cc2565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254610fa7919061397b565b925050819055508160cf6000866000018481548110610fc957610fc8613cc2565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825461103d9190613bec565b9250508190555083600001818154811061105a57611059613cc2565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff167f0f2440b3ca071b7d18e917a25289e7d7e7de8a491546d45acc2efbec7b3e1ae883886040516110cc929190613cf1565b60405180910390a261111d8460000182815481106110ed576110ec613cc2565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16612661565b8080600101915050610f09565b5060018360020160006101000a81548160ff02191690836002811115611153576111526130c4565b5b02179055508460405161116691906138a3565b60405180910390207f4a2ced9ada462e244851a86e998eb0b5bf558c2c9c6923b7f970ed2b19b073b0600160405161119e9190613d21565b60405180910390a25050505050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff160361123b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161123290613aa3565b60405180910390fd5b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1661127a612491565b73ffffffffffffffffffffffffffffffffffffffff16146112d0576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016112c790613b35565b60405180910390fd5b6112d9826124e8565b6112e5828260016124f3565b5050565b60007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff1614611379576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161137090613dae565b60405180910390fd5b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc60001b905090565b6113aa612cb2565b604051806080016040528060c954815260200160ca54815260200160cb54815260200160cc54815250905090565b60006002905090565b60ce818051602081018201805184825260208301602085012081835280955050505050506000915090508060010154908060020160009054906101000a900460ff16905082565b611430612413565b8173ffffffffffffffffffffffffffffffffffffffff166108fc829081150290604051600060405180830381858888f19350505050158015611476573d6000803e3d6000fd5b505050565b611483612413565b8060d260006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b60c95481565b6114d5612413565b600160cd60008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff02191690831515021790555050565b611538612413565b61154260006127c3565b565b60cd60003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff166115d0576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016115c790613ca2565b60405180910390fd5b8060ca8190555050565b60008060019054906101000a900460ff1615905080801561160b5750600160008054906101000a900460ff1660ff16105b80611638575061161a30612889565b1580156116375750600160008054906101000a900460ff1660ff16145b5b611677576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161166e90613e40565b60405180910390fd5b60016000806101000a81548160ff021916908360ff16021790555080156116b4576001600060016101000a81548160ff0219169083151502179055505b6116bc6128ac565b6116c4612905565b600160cd60003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff021916908315150217905550600160cb81905550600160cc8190555067016345785d8a000060ca8190555080156117945760008060016101000a81548160ff0219169083151502179055507f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498600160405161178b9190613eb2565b60405180910390a15b50565b60cd60003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff16611823576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161181a90613ca2565b60405180910390fd5b818160005b82518110156118da578160cf600085848151811061184957611848613cc2565b5b602002602001015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205412156118cd576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016118c490613f3f565b60405180910390fd5b8080600101915050611828565b5060005b8451811015611a61578360cf60008784815181106118ff576118fe613cc2565b5b602002602001015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546119509190613f5f565b925050819055508360d0600087848151811061196f5761196e613cc2565b5b602002602001015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546119c09190613fa2565b925050819055508481815181106119da576119d9613cc2565b5b602002602001015173ffffffffffffffffffffffffffffffffffffffff167f5f3d004cf9164b95ed5dbf47d1f04018a4eabcb20b4320fe229ed92236ace6348588604051611a29929190613cf1565b60405180910390a2611a54858281518110611a4757611a46613cc2565b5b6020026020010151612661565b80806001019150506118de565b50604051806060016040528085815260200184815260200160006002811115611a8d57611a8c6130c4565b5b81525060ce86604051611aa091906138a3565b90815260200160405180910390206000820151816000019080519060200190611aca929190612cda565b506020820151816001015560408201518160020160006101000a81548160ff02191690836002811115611b0057611aff6130c4565b5b02179055509050505050505050565b6000603360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b60d06020528060005260406000206000915090505481565b60ca5481565b60cf6020528060005260406000206000915090505481565b611b77612d64565b60405180608001604052808373ffffffffffffffffffffffffffffffffffffffff16815260200160cf60008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054815260200160d060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054815260200160d160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208054611c7290613b84565b80601f0160208091040260200160405190810160405280929190818152602001828054611c9e90613b84565b8015611ceb5780601f10611cc057610100808354040283529160200191611ceb565b820191906000526020600020905b815481529060010190602001808311611cce57829003601f168201915b50505050508152509050919050565b60cb5481565b611d08612413565b8060cc8190555050565b60cc5481565b60cd60003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff16611da4576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611d9b90613ca2565b60405180910390fd5b600060ce83604051611db691906138a3565b90815260200160405180910390209050600060cc5460ca54611dd89190613fd6565b9050600060d060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205490506000818311611e2d5782611e2f565b815b90506000818411611e41576000611e4e565b8184611e4d919061397b565b5b90508160d060008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254611e9f919061397b565b925050819055508060cf60008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254611ef59190613f5f565b925050819055508360c96000828254611f0e9190613fa2565b9250508190555060028560020160006101000a81548160ff02191690836002811115611f3d57611f3c6130c4565b5b021790555083856001015411611f54576000611f65565b838560010154611f64919061397b565b5b8560010181905550611f7686612661565b8573ffffffffffffffffffffffffffffffffffffffff167f403feb2cd85cc25c910fe59289105b583f08fe9e4335ebbb08c1851f47ff2d348589604051611fbe929190613cf1565b60405180910390a286604051611fd491906138a3565b60405180910390207f4a2ced9ada462e244851a86e998eb0b5bf558c2c9c6923b7f970ed2b19b073b0600260405161200c9190613d21565b60405180910390a28573ffffffffffffffffffffffffffffffffffffffff167f42f1a8a1aee108e84e4eabfaa8d51d7baaa1a02d482295297883a44b2debd3e4838360405161205c929190614064565b60405180910390a250505050505050565b8060405161207b91906138a3565b60405180910390203373ffffffffffffffffffffffffffffffffffffffff167faec1d412a3c1e4a13fc2a2e19ac38a5af192a9cf17b074fca8146a2d0655e0c360405160405180910390a350565b6120d1612413565b600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603612140576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161213790614112565b60405180910390fd5b612149816127c3565b50565b3373ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff1663893d20e86040518163ffffffff1660e01b8152600401602060405180830381865afa1580156121ae573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906121d29190614147565b73ffffffffffffffffffffffffffffffffffffffff1614612228576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161221f906141e6565b60405180910390fd5b8060cf60008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205412156122aa576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016122a190614252565b60405180910390fd5b8060cf60008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546122f99190613f5f565b9250508190555060d260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb33836040518363ffffffff1660e01b815260040161235d9291906139af565b6020604051808303816000875af115801561237c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906123a09190613a04565b506123aa82612661565b8173ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f9b1bfa7fa9ee420a16e124f794c35ac9f90472acc99140eb2f6447c714cad8eb836040516124079190613529565b60405180910390a35050565b61241b612956565b73ffffffffffffffffffffffffffffffffffffffff16612439611b0f565b73ffffffffffffffffffffffffffffffffffffffff161461248f576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401612486906142be565b60405180910390fd5b565b60006124bf7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc60001b61295e565b60000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b6124f0612413565b50565b61251f7f4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd914360001b612968565b60000160009054906101000a900460ff16156125435761253e83612972565b61265c565b8273ffffffffffffffffffffffffffffffffffffffff166352d1902d6040518163ffffffff1660e01b8152600401602060405180830381865afa9250505080156125ab57506040513d601f19601f820116820180604052508101906125a8919061430a565b60015b6125ea576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016125e1906143a9565b60405180910390fd5b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc60001b811461264f576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016126469061443b565b60405180910390fd5b5061265b838383612a2b565b5b505050565b60ca5460cb546126719190613fd6565b60cf60008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541261273d576040518060400160405280600981526020017f7a6b41756374696f6e000000000000000000000000000000000000000000000081525060d160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020908161273791906145fd565b506127c0565b6040518060400160405280600381526020017f4e5343000000000000000000000000000000000000000000000000000000000081525060d160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090816127be91906145fd565b505b50565b6000603360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905081603360006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b6000808273ffffffffffffffffffffffffffffffffffffffff163b119050919050565b600060019054906101000a900460ff166128fb576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016128f290614741565b60405180910390fd5b612903612a57565b565b600060019054906101000a900460ff16612954576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161294b90614741565b60405180910390fd5b565b600033905090565b6000819050919050565b6000819050919050565b61297b81612889565b6129ba576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016129b1906147d3565b60405180910390fd5b806129e77f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc60001b61295e565b60000160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b612a3483612ab8565b600082511180612a415750805b15612a5257612a508383612b07565b505b505050565b600060019054906101000a900460ff16612aa6576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401612a9d90614741565b60405180910390fd5b612ab6612ab1612956565b6127c3565b565b612ac181612972565b8073ffffffffffffffffffffffffffffffffffffffff167fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b60405160405180910390a250565b6060612b2c83836040518060600160405280602781526020016148be60279139612b34565b905092915050565b60606000808573ffffffffffffffffffffffffffffffffffffffff1685604051612b5e919061483a565b600060405180830381855af49150503d8060008114612b99576040519150601f19603f3d011682016040523d82523d6000602084013e612b9e565b606091505b5091509150612baf86838387612bba565b925050509392505050565b60608315612c1c576000835103612c1457612bd485612889565b612c13576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401612c0a9061489d565b60405180910390fd5b5b829050612c27565b612c268383612c2f565b5b949350505050565b600082511115612c425781518083602001fd5b806040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401612c7691906132bb565b60405180910390fd5b6040518060600160405280606081526020016000815260200160006002811115612cac57612cab6130c4565b5b81525090565b6040518060800160405280600081526020016000815260200160008152602001600081525090565b828054828255906000526020600020908101928215612d53579160200282015b82811115612d525782518260006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555091602001919060010190612cfa565b5b509050612d609190612da2565b5090565b6040518060800160405280600073ffffffffffffffffffffffffffffffffffffffff1681526020016000815260200160008152602001606081525090565b5b80821115612dbb576000816000905550600101612da3565b5090565b6000604051905090565b600080fd5b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000612dfe82612dd3565b9050919050565b612e0e81612df3565b8114612e1957600080fd5b50565b600081359050612e2b81612e05565b92915050565b600060208284031215612e4757612e46612dc9565b5b6000612e5584828501612e1c565b91505092915050565b600080fd5b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b612eb182612e68565b810181811067ffffffffffffffff82111715612ed057612ecf612e79565b5b80604052505050565b6000612ee3612dbf565b9050612eef8282612ea8565b919050565b600067ffffffffffffffff821115612f0f57612f0e612e79565b5b612f1882612e68565b9050602081019050919050565b82818337600083830152505050565b6000612f47612f4284612ef4565b612ed9565b905082815260208101848484011115612f6357612f62612e63565b5b612f6e848285612f25565b509392505050565b600082601f830112612f8b57612f8a612e5e565b5b8135612f9b848260208601612f34565b91505092915050565b600060208284031215612fba57612fb9612dc9565b5b600082013567ffffffffffffffff811115612fd857612fd7612dce565b5b612fe484828501612f76565b91505092915050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b61302281612df3565b82525050565b60006130348383613019565b60208301905092915050565b6000602082019050919050565b600061305882612fed565b6130628185612ff8565b935061306d83613009565b8060005b8381101561309e5781516130858882613028565b975061309083613040565b925050600181019050613071565b5085935050505092915050565b6000819050919050565b6130be816130ab565b82525050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b60038110613104576131036130c4565b5b50565b6000819050613115826130f3565b919050565b600061312582613107565b9050919050565b6131358161311a565b82525050565b60006060830160008301518482036000860152613158828261304d565b915050602083015161316d60208601826130b5565b506040830151613180604086018261312c565b508091505092915050565b600060208201905081810360008301526131a5818461313b565b905092915050565b60008115159050919050565b6131c2816131ad565b82525050565b60006020820190506131dd60008301846131b9565b92915050565b6131ec816130ab565b81146131f757600080fd5b50565b600081359050613209816131e3565b92915050565b60006020828403121561322557613224612dc9565b5b6000613233848285016131fa565b91505092915050565b600081519050919050565b600082825260208201905092915050565b60005b8381101561327657808201518184015260208101905061325b565b60008484015250505050565b600061328d8261323c565b6132978185613247565b93506132a7818560208601613258565b6132b081612e68565b840191505092915050565b600060208201905081810360008301526132d58184613282565b905092915050565b600080604083850312156132f4576132f3612dc9565b5b600061330285828601612e1c565b9250506020613313858286016131fa565b9150509250929050565b6000806040838503121561333457613333612dc9565b5b600083013567ffffffffffffffff81111561335257613351612dce565b5b61335e85828601612f76565b925050602061336f858286016131fa565b9150509250929050565b600067ffffffffffffffff82111561339457613393612e79565b5b61339d82612e68565b9050602081019050919050565b60006133bd6133b884613379565b612ed9565b9050828152602081018484840111156133d9576133d8612e63565b5b6133e4848285612f25565b509392505050565b600082601f83011261340157613400612e5e565b5b81356134118482602086016133aa565b91505092915050565b6000806040838503121561343157613430612dc9565b5b600061343f85828601612e1c565b925050602083013567ffffffffffffffff8111156134605761345f612dce565b5b61346c858286016133ec565b9150509250929050565b6000819050919050565b61348981613476565b82525050565b60006020820190506134a46000830184613480565b92915050565b6080820160008201516134c060008501826130b5565b5060208201516134d360208501826130b5565b5060408201516134e660408501826130b5565b5060608201516134f960608501826130b5565b50505050565b600060808201905061351460008301846134aa565b92915050565b613523816130ab565b82525050565b600060208201905061353e600083018461351a565b92915050565b61354d8161311a565b82525050565b6000604082019050613568600083018561351a565b6135756020830184613544565b9392505050565b600067ffffffffffffffff82111561359757613596612e79565b5b602082029050602081019050919050565b600080fd5b60006135c06135bb8461357c565b612ed9565b905080838252602082019050602084028301858111156135e3576135e26135a8565b5b835b8181101561360c57806135f88882612e1c565b8452602084019350506020810190506135e5565b5050509392505050565b600082601f83011261362b5761362a612e5e565b5b813561363b8482602086016135ad565b91505092915050565b60008060006060848603121561365d5761365c612dc9565b5b600084013567ffffffffffffffff81111561367b5761367a612dce565b5b61368786828701612f76565b935050602084013567ffffffffffffffff8111156136a8576136a7612dce565b5b6136b486828701613616565b92505060406136c5868287016131fa565b9150509250925092565b6136d881612df3565b82525050565b60006020820190506136f360008301846136cf565b92915050565b6000819050919050565b61370c816136f9565b82525050565b60006020820190506137276000830184613703565b92915050565b613736816136f9565b82525050565b600082825260208201905092915050565b60006137588261323c565b613762818561373c565b9350613772818560208601613258565b61377b81612e68565b840191505092915050565b600060808301600083015161379e6000860182613019565b5060208301516137b1602086018261372d565b5060408301516137c460408601826130b5565b50606083015184820360608601526137dc828261374d565b9150508091505092915050565b600060208201905081810360008301526138038184613786565b905092915050565b6000806040838503121561382257613821612dc9565b5b600083013567ffffffffffffffff8111156138405761383f612dce565b5b61384c85828601612f76565b925050602061385d85828601612e1c565b9150509250929050565b600081905092915050565b600061387d8261323c565b6138878185613867565b9350613897818560208601613258565b80840191505092915050565b60006138af8284613872565b915081905092915050565b7f576974686472617720616d6f756e7420616d6f756e742065786365656473207360008201527f6c617368656446756e6473000000000000000000000000000000000000000000602082015250565b6000613916602b83613247565b9150613921826138ba565b604082019050919050565b6000602082019050818103600083015261394581613909565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000613986826130ab565b9150613991836130ab565b92508282039050818111156139a9576139a861394c565b5b92915050565b60006040820190506139c460008301856136cf565b6139d1602083018461351a565b9392505050565b6139e1816131ad565b81146139ec57600080fd5b50565b6000815190506139fe816139d8565b92915050565b600060208284031215613a1a57613a19612dc9565b5b6000613a28848285016139ef565b91505092915050565b7f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060008201527f64656c656761746563616c6c0000000000000000000000000000000000000000602082015250565b6000613a8d602c83613247565b9150613a9882613a31565b604082019050919050565b60006020820190508181036000830152613abc81613a80565b9050919050565b7f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060008201527f6163746976652070726f78790000000000000000000000000000000000000000602082015250565b6000613b1f602c83613247565b9150613b2a82613ac3565b604082019050919050565b60006020820190508181036000830152613b4e81613b12565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b60006002820490506001821680613b9c57607f821691505b602082108103613baf57613bae613b55565b5b50919050565b6000606082019050613bca60008301866136cf565b613bd760208301856136cf565b613be4604083018461351a565b949350505050565b6000613bf7826136f9565b9150613c02836136f9565b925082820190508281121560008312168382126000841215161715613c2a57613c2961394c565b5b92915050565b7f4f6e6c79207468652061646d696e2063616e2063616c6c20746869732066756e60008201527f6374696f6e2e0000000000000000000000000000000000000000000000000000602082015250565b6000613c8c602683613247565b9150613c9782613c30565b604082019050919050565b60006020820190508181036000830152613cbb81613c7f565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b6000604082019050613d06600083018561351a565b8181036020830152613d188184613282565b90509392505050565b6000602082019050613d366000830184613544565b92915050565b7f555550535570677261646561626c653a206d757374206e6f742062652063616c60008201527f6c6564207468726f7567682064656c656761746563616c6c0000000000000000602082015250565b6000613d98603883613247565b9150613da382613d3c565b604082019050919050565b60006020820190508181036000830152613dc781613d8b565b9050919050565b7f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160008201527f647920696e697469616c697a6564000000000000000000000000000000000000602082015250565b6000613e2a602e83613247565b9150613e3582613dce565b604082019050919050565b60006020820190508181036000830152613e5981613e1d565b9050919050565b6000819050919050565b600060ff82169050919050565b6000819050919050565b6000613e9c613e97613e9284613e60565b613e77565b613e6a565b9050919050565b613eac81613e81565b82525050565b6000602082019050613ec76000830184613ea3565b92915050565b7f4e6f7420616c6c20435073206861766520656e6f75676820617661696c61626c60008201527f652062616c616e63650000000000000000000000000000000000000000000000602082015250565b6000613f29602983613247565b9150613f3482613ecd565b604082019050919050565b60006020820190508181036000830152613f5881613f1c565b9050919050565b6000613f6a826136f9565b9150613f75836136f9565b9250828203905081811260008412168282136000851215161715613f9c57613f9b61394c565b5b92915050565b6000613fad826130ab565b9150613fb8836130ab565b9250828201905080821115613fd057613fcf61394c565b5b92915050565b6000613fe1826130ab565b9150613fec836130ab565b9250828202613ffa816130ab565b915082820484148315176140115761401061394c565b5b5092915050565b7f536c617368656400000000000000000000000000000000000000000000000000600082015250565b600061404e600783613247565b915061405982614018565b602082019050919050565b6000606082019050614079600083018561351a565b614086602083018461351a565b818103604083015261409781614041565b90509392505050565b7f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160008201527f6464726573730000000000000000000000000000000000000000000000000000602082015250565b60006140fc602683613247565b9150614107826140a0565b604082019050919050565b6000602082019050818103600083015261412b816140ef565b9050919050565b60008151905061414181612e05565b92915050565b60006020828403121561415d5761415c612dc9565b5b600061416b84828501614132565b91505092915050565b7f4f6e6c792043504163636f756e74206f776e65722063616e207769746864726160008201527f772074686520636f6c6c61746572616c2066756e647300000000000000000000602082015250565b60006141d0603683613247565b91506141db82614174565b604082019050919050565b600060208201905081810360008301526141ff816141c3565b9050919050565b7f576974686472617720616d6f756e7420657863656564732062616c616e636500600082015250565b600061423c601f83613247565b915061424782614206565b602082019050919050565b6000602082019050818103600083015261426b8161422f565b9050919050565b7f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572600082015250565b60006142a8602083613247565b91506142b382614272565b602082019050919050565b600060208201905081810360008301526142d78161429b565b9050919050565b6142e781613476565b81146142f257600080fd5b50565b600081519050614304816142de565b92915050565b6000602082840312156143205761431f612dc9565b5b600061432e848285016142f5565b91505092915050565b7f45524331393637557067726164653a206e657720696d706c656d656e7461746960008201527f6f6e206973206e6f742055555053000000000000000000000000000000000000602082015250565b6000614393602e83613247565b915061439e82614337565b604082019050919050565b600060208201905081810360008301526143c281614386565b9050919050565b7f45524331393637557067726164653a20756e737570706f727465642070726f7860008201527f6961626c65555549440000000000000000000000000000000000000000000000602082015250565b6000614425602983613247565b9150614430826143c9565b604082019050919050565b6000602082019050818103600083015261445481614418565b9050919050565b60008190508160005260206000209050919050565b60006020601f8301049050919050565b600082821b905092915050565b6000600883026144bd7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82614480565b6144c78683614480565b95508019841693508086168417925050509392505050565b60006144fa6144f56144f0846130ab565b613e77565b6130ab565b9050919050565b6000819050919050565b614514836144df565b61452861452082614501565b84845461448d565b825550505050565b600090565b61453d614530565b61454881848461450b565b505050565b5b8181101561456c57614561600082614535565b60018101905061454e565b5050565b601f8211156145b1576145828161445b565b61458b84614470565b8101602085101561459a578190505b6145ae6145a685614470565b83018261454d565b50505b505050565b600082821c905092915050565b60006145d4600019846008026145b6565b1980831691505092915050565b60006145ed83836145c3565b9150826002028217905092915050565b6146068261323c565b67ffffffffffffffff81111561461f5761461e612e79565b5b6146298254613b84565b614634828285614570565b600060209050601f8311600181146146675760008415614655578287015190505b61465f85826145e1565b8655506146c7565b601f1984166146758661445b565b60005b8281101561469d57848901518255600182019150602085019450602081019050614678565b868310156146ba57848901516146b6601f8916826145c3565b8355505b6001600288020188555050505b505050505050565b7f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960008201527f6e697469616c697a696e67000000000000000000000000000000000000000000602082015250565b600061472b602b83613247565b9150614736826146cf565b604082019050919050565b6000602082019050818103600083015261475a8161471e565b9050919050565b7f455243313936373a206e657720696d706c656d656e746174696f6e206973206e60008201527f6f74206120636f6e747261637400000000000000000000000000000000000000602082015250565b60006147bd602d83613247565b91506147c882614761565b604082019050919050565b600060208201905081810360008301526147ec816147b0565b9050919050565b600081519050919050565b600081905092915050565b6000614814826147f3565b61481e81856147fe565b935061482e818560208601613258565b80840191505092915050565b60006148468284614809565b915081905092915050565b7f416464726573733a2063616c6c20746f206e6f6e2d636f6e7472616374000000600082015250565b6000614887601d83613247565b915061489282614851565b602082019050919050565b600060208201905081810360008301526148b68161487a565b905091905056fe416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a2646970667358221220db60567c41a95dc821c3776f190bfaa68caab09f68059c256e5d2843e5d2b64b64736f6c63430008190033",
}

// FcpCollateralABI is the input ABI used to generate the binding from.
// Deprecated: Use FcpCollateralMetaData.ABI instead.
var FcpCollateralABI = FcpCollateralMetaData.ABI

// FcpCollateralBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use FcpCollateralMetaData.Bin instead.
var FcpCollateralBin = FcpCollateralMetaData.Bin

// DeployFcpCollateral deploys a new Ethereum contract, binding an instance of FcpCollateral to it.
func DeployFcpCollateral(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *FcpCollateral, error) {
	parsed, err := FcpCollateralMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(FcpCollateralBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &FcpCollateral{FcpCollateralCaller: FcpCollateralCaller{contract: contract}, FcpCollateralTransactor: FcpCollateralTransactor{contract: contract}, FcpCollateralFilterer: FcpCollateralFilterer{contract: contract}}, nil
}

// FcpCollateral is an auto generated Go binding around an Ethereum contract.
type FcpCollateral struct {
	FcpCollateralCaller     // Read-only binding to the contract
	FcpCollateralTransactor // Write-only binding to the contract
	FcpCollateralFilterer   // Log filterer for contract events
}

// FcpCollateralCaller is an auto generated read-only Go binding around an Ethereum contract.
type FcpCollateralCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// FcpCollateralTransactor is an auto generated write-only Go binding around an Ethereum contract.
type FcpCollateralTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// FcpCollateralFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type FcpCollateralFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// FcpCollateralSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type FcpCollateralSession struct {
	Contract     *FcpCollateral    // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// FcpCollateralCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type FcpCollateralCallerSession struct {
	Contract *FcpCollateralCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts        // Call options to use throughout this session
}

// FcpCollateralTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type FcpCollateralTransactorSession struct {
	Contract     *FcpCollateralTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts        // Transaction auth options to use throughout this session
}

// FcpCollateralRaw is an auto generated low-level Go binding around an Ethereum contract.
type FcpCollateralRaw struct {
	Contract *FcpCollateral // Generic contract binding to access the raw methods on
}

// FcpCollateralCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type FcpCollateralCallerRaw struct {
	Contract *FcpCollateralCaller // Generic read-only contract binding to access the raw methods on
}

// FcpCollateralTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type FcpCollateralTransactorRaw struct {
	Contract *FcpCollateralTransactor // Generic write-only contract binding to access the raw methods on
}

// NewFcpCollateral creates a new instance of FcpCollateral, bound to a specific deployed contract.
func NewFcpCollateral(address common.Address, backend bind.ContractBackend) (*FcpCollateral, error) {
	contract, err := bindFcpCollateral(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &FcpCollateral{FcpCollateralCaller: FcpCollateralCaller{contract: contract}, FcpCollateralTransactor: FcpCollateralTransactor{contract: contract}, FcpCollateralFilterer: FcpCollateralFilterer{contract: contract}}, nil
}

// NewFcpCollateralCaller creates a new read-only instance of FcpCollateral, bound to a specific deployed contract.
func NewFcpCollateralCaller(address common.Address, caller bind.ContractCaller) (*FcpCollateralCaller, error) {
	contract, err := bindFcpCollateral(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &FcpCollateralCaller{contract: contract}, nil
}

// NewFcpCollateralTransactor creates a new write-only instance of FcpCollateral, bound to a specific deployed contract.
func NewFcpCollateralTransactor(address common.Address, transactor bind.ContractTransactor) (*FcpCollateralTransactor, error) {
	contract, err := bindFcpCollateral(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &FcpCollateralTransactor{contract: contract}, nil
}

// NewFcpCollateralFilterer creates a new log filterer instance of FcpCollateral, bound to a specific deployed contract.
func NewFcpCollateralFilterer(address common.Address, filterer bind.ContractFilterer) (*FcpCollateralFilterer, error) {
	contract, err := bindFcpCollateral(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &FcpCollateralFilterer{contract: contract}, nil
}

// bindFcpCollateral binds a generic wrapper to an already deployed contract.
func bindFcpCollateral(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := FcpCollateralMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_FcpCollateral *FcpCollateralRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _FcpCollateral.Contract.FcpCollateralCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_FcpCollateral *FcpCollateralRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _FcpCollateral.Contract.FcpCollateralTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_FcpCollateral *FcpCollateralRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _FcpCollateral.Contract.FcpCollateralTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_FcpCollateral *FcpCollateralCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _FcpCollateral.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_FcpCollateral *FcpCollateralTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _FcpCollateral.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_FcpCollateral *FcpCollateralTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _FcpCollateral.Contract.contract.Transact(opts, method, params...)
}

// AvailableBalance is a free data retrieval call binding the contract method 0xa0821be3.
//
// Solidity: function availableBalance(address ) view returns(int256)
func (_FcpCollateral *FcpCollateralCaller) AvailableBalance(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _FcpCollateral.contract.Call(opts, &out, "availableBalance", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// AvailableBalance is a free data retrieval call binding the contract method 0xa0821be3.
//
// Solidity: function availableBalance(address ) view returns(int256)
func (_FcpCollateral *FcpCollateralSession) AvailableBalance(arg0 common.Address) (*big.Int, error) {
	return _FcpCollateral.Contract.AvailableBalance(&_FcpCollateral.CallOpts, arg0)
}

// AvailableBalance is a free data retrieval call binding the contract method 0xa0821be3.
//
// Solidity: function availableBalance(address ) view returns(int256)
func (_FcpCollateral *FcpCollateralCallerSession) AvailableBalance(arg0 common.Address) (*big.Int, error) {
	return _FcpCollateral.Contract.AvailableBalance(&_FcpCollateral.CallOpts, arg0)
}

// BaseCollateral is a free data retrieval call binding the contract method 0x9b5ddf09.
//
// Solidity: function baseCollateral() view returns(uint256)
func (_FcpCollateral *FcpCollateralCaller) BaseCollateral(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _FcpCollateral.contract.Call(opts, &out, "baseCollateral")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// BaseCollateral is a free data retrieval call binding the contract method 0x9b5ddf09.
//
// Solidity: function baseCollateral() view returns(uint256)
func (_FcpCollateral *FcpCollateralSession) BaseCollateral() (*big.Int, error) {
	return _FcpCollateral.Contract.BaseCollateral(&_FcpCollateral.CallOpts)
}

// BaseCollateral is a free data retrieval call binding the contract method 0x9b5ddf09.
//
// Solidity: function baseCollateral() view returns(uint256)
func (_FcpCollateral *FcpCollateralCallerSession) BaseCollateral() (*big.Int, error) {
	return _FcpCollateral.Contract.BaseCollateral(&_FcpCollateral.CallOpts)
}

// CollateralInfo is a free data retrieval call binding the contract method 0x53ad8720.
//
// Solidity: function collateralInfo() view returns((uint256,uint256,uint256,uint256))
func (_FcpCollateral *FcpCollateralCaller) CollateralInfo(opts *bind.CallOpts) (SwanCreditCollateralContractInfo, error) {
	var out []interface{}
	err := _FcpCollateral.contract.Call(opts, &out, "collateralInfo")

	if err != nil {
		return *new(SwanCreditCollateralContractInfo), err
	}

	out0 := *abi.ConvertType(out[0], new(SwanCreditCollateralContractInfo)).(*SwanCreditCollateralContractInfo)

	return out0, err

}

// CollateralInfo is a free data retrieval call binding the contract method 0x53ad8720.
//
// Solidity: function collateralInfo() view returns((uint256,uint256,uint256,uint256))
func (_FcpCollateral *FcpCollateralSession) CollateralInfo() (SwanCreditCollateralContractInfo, error) {
	return _FcpCollateral.Contract.CollateralInfo(&_FcpCollateral.CallOpts)
}

// CollateralInfo is a free data retrieval call binding the contract method 0x53ad8720.
//
// Solidity: function collateralInfo() view returns((uint256,uint256,uint256,uint256))
func (_FcpCollateral *FcpCollateralCallerSession) CollateralInfo() (SwanCreditCollateralContractInfo, error) {
	return _FcpCollateral.Contract.CollateralInfo(&_FcpCollateral.CallOpts)
}

// CollateralRatio is a free data retrieval call binding the contract method 0xb4eae1cb.
//
// Solidity: function collateralRatio() view returns(uint256)
func (_FcpCollateral *FcpCollateralCaller) CollateralRatio(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _FcpCollateral.contract.Call(opts, &out, "collateralRatio")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// CollateralRatio is a free data retrieval call binding the contract method 0xb4eae1cb.
//
// Solidity: function collateralRatio() view returns(uint256)
func (_FcpCollateral *FcpCollateralSession) CollateralRatio() (*big.Int, error) {
	return _FcpCollateral.Contract.CollateralRatio(&_FcpCollateral.CallOpts)
}

// CollateralRatio is a free data retrieval call binding the contract method 0xb4eae1cb.
//
// Solidity: function collateralRatio() view returns(uint256)
func (_FcpCollateral *FcpCollateralCallerSession) CollateralRatio() (*big.Int, error) {
	return _FcpCollateral.Contract.CollateralRatio(&_FcpCollateral.CallOpts)
}

// CpInfo is a free data retrieval call binding the contract method 0xa664c216.
//
// Solidity: function cpInfo(address cpAddress) view returns((address,int256,uint256,string))
func (_FcpCollateral *FcpCollateralCaller) CpInfo(opts *bind.CallOpts, cpAddress common.Address) (SwanCreditCollateralCPInfo, error) {
	var out []interface{}
	err := _FcpCollateral.contract.Call(opts, &out, "cpInfo", cpAddress)

	if err != nil {
		return *new(SwanCreditCollateralCPInfo), err
	}

	out0 := *abi.ConvertType(out[0], new(SwanCreditCollateralCPInfo)).(*SwanCreditCollateralCPInfo)

	return out0, err

}

// CpInfo is a free data retrieval call binding the contract method 0xa664c216.
//
// Solidity: function cpInfo(address cpAddress) view returns((address,int256,uint256,string))
func (_FcpCollateral *FcpCollateralSession) CpInfo(cpAddress common.Address) (SwanCreditCollateralCPInfo, error) {
	return _FcpCollateral.Contract.CpInfo(&_FcpCollateral.CallOpts, cpAddress)
}

// CpInfo is a free data retrieval call binding the contract method 0xa664c216.
//
// Solidity: function cpInfo(address cpAddress) view returns((address,int256,uint256,string))
func (_FcpCollateral *FcpCollateralCallerSession) CpInfo(cpAddress common.Address) (SwanCreditCollateralCPInfo, error) {
	return _FcpCollateral.Contract.CpInfo(&_FcpCollateral.CallOpts, cpAddress)
}

// CpStatus is a free data retrieval call binding the contract method 0x3fe65177.
//
// Solidity: function cpStatus(address ) view returns(string)
func (_FcpCollateral *FcpCollateralCaller) CpStatus(opts *bind.CallOpts, arg0 common.Address) (string, error) {
	var out []interface{}
	err := _FcpCollateral.contract.Call(opts, &out, "cpStatus", arg0)

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// CpStatus is a free data retrieval call binding the contract method 0x3fe65177.
//
// Solidity: function cpStatus(address ) view returns(string)
func (_FcpCollateral *FcpCollateralSession) CpStatus(arg0 common.Address) (string, error) {
	return _FcpCollateral.Contract.CpStatus(&_FcpCollateral.CallOpts, arg0)
}

// CpStatus is a free data retrieval call binding the contract method 0x3fe65177.
//
// Solidity: function cpStatus(address ) view returns(string)
func (_FcpCollateral *FcpCollateralCallerSession) CpStatus(arg0 common.Address) (string, error) {
	return _FcpCollateral.Contract.CpStatus(&_FcpCollateral.CallOpts, arg0)
}

// GetTaskInfo is a free data retrieval call binding the contract method 0x1b209463.
//
// Solidity: function getTaskInfo(string taskUid) view returns((address[],uint256,uint8))
func (_FcpCollateral *FcpCollateralCaller) GetTaskInfo(opts *bind.CallOpts, taskUid string) (SwanCreditCollateralTask, error) {
	var out []interface{}
	err := _FcpCollateral.contract.Call(opts, &out, "getTaskInfo", taskUid)

	if err != nil {
		return *new(SwanCreditCollateralTask), err
	}

	out0 := *abi.ConvertType(out[0], new(SwanCreditCollateralTask)).(*SwanCreditCollateralTask)

	return out0, err

}

// GetTaskInfo is a free data retrieval call binding the contract method 0x1b209463.
//
// Solidity: function getTaskInfo(string taskUid) view returns((address[],uint256,uint8))
func (_FcpCollateral *FcpCollateralSession) GetTaskInfo(taskUid string) (SwanCreditCollateralTask, error) {
	return _FcpCollateral.Contract.GetTaskInfo(&_FcpCollateral.CallOpts, taskUid)
}

// GetTaskInfo is a free data retrieval call binding the contract method 0x1b209463.
//
// Solidity: function getTaskInfo(string taskUid) view returns((address[],uint256,uint8))
func (_FcpCollateral *FcpCollateralCallerSession) GetTaskInfo(taskUid string) (SwanCreditCollateralTask, error) {
	return _FcpCollateral.Contract.GetTaskInfo(&_FcpCollateral.CallOpts, taskUid)
}

// IsAdmin is a free data retrieval call binding the contract method 0x24d7806c.
//
// Solidity: function isAdmin(address ) view returns(bool)
func (_FcpCollateral *FcpCollateralCaller) IsAdmin(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _FcpCollateral.contract.Call(opts, &out, "isAdmin", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsAdmin is a free data retrieval call binding the contract method 0x24d7806c.
//
// Solidity: function isAdmin(address ) view returns(bool)
func (_FcpCollateral *FcpCollateralSession) IsAdmin(arg0 common.Address) (bool, error) {
	return _FcpCollateral.Contract.IsAdmin(&_FcpCollateral.CallOpts, arg0)
}

// IsAdmin is a free data retrieval call binding the contract method 0x24d7806c.
//
// Solidity: function isAdmin(address ) view returns(bool)
func (_FcpCollateral *FcpCollateralCallerSession) IsAdmin(arg0 common.Address) (bool, error) {
	return _FcpCollateral.Contract.IsAdmin(&_FcpCollateral.CallOpts, arg0)
}

// LockedCollateral is a free data retrieval call binding the contract method 0x92bdf9ba.
//
// Solidity: function lockedCollateral(address ) view returns(uint256)
func (_FcpCollateral *FcpCollateralCaller) LockedCollateral(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _FcpCollateral.contract.Call(opts, &out, "lockedCollateral", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// LockedCollateral is a free data retrieval call binding the contract method 0x92bdf9ba.
//
// Solidity: function lockedCollateral(address ) view returns(uint256)
func (_FcpCollateral *FcpCollateralSession) LockedCollateral(arg0 common.Address) (*big.Int, error) {
	return _FcpCollateral.Contract.LockedCollateral(&_FcpCollateral.CallOpts, arg0)
}

// LockedCollateral is a free data retrieval call binding the contract method 0x92bdf9ba.
//
// Solidity: function lockedCollateral(address ) view returns(uint256)
func (_FcpCollateral *FcpCollateralCallerSession) LockedCollateral(arg0 common.Address) (*big.Int, error) {
	return _FcpCollateral.Contract.LockedCollateral(&_FcpCollateral.CallOpts, arg0)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_FcpCollateral *FcpCollateralCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _FcpCollateral.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_FcpCollateral *FcpCollateralSession) Owner() (common.Address, error) {
	return _FcpCollateral.Contract.Owner(&_FcpCollateral.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_FcpCollateral *FcpCollateralCallerSession) Owner() (common.Address, error) {
	return _FcpCollateral.Contract.Owner(&_FcpCollateral.CallOpts)
}

// ProxiableUUID is a free data retrieval call binding the contract method 0x52d1902d.
//
// Solidity: function proxiableUUID() view returns(bytes32)
func (_FcpCollateral *FcpCollateralCaller) ProxiableUUID(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _FcpCollateral.contract.Call(opts, &out, "proxiableUUID")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// ProxiableUUID is a free data retrieval call binding the contract method 0x52d1902d.
//
// Solidity: function proxiableUUID() view returns(bytes32)
func (_FcpCollateral *FcpCollateralSession) ProxiableUUID() ([32]byte, error) {
	return _FcpCollateral.Contract.ProxiableUUID(&_FcpCollateral.CallOpts)
}

// ProxiableUUID is a free data retrieval call binding the contract method 0x52d1902d.
//
// Solidity: function proxiableUUID() view returns(bytes32)
func (_FcpCollateral *FcpCollateralCallerSession) ProxiableUUID() ([32]byte, error) {
	return _FcpCollateral.Contract.ProxiableUUID(&_FcpCollateral.CallOpts)
}

// SlashRatio is a free data retrieval call binding the contract method 0xd27ca89b.
//
// Solidity: function slashRatio() view returns(uint256)
func (_FcpCollateral *FcpCollateralCaller) SlashRatio(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _FcpCollateral.contract.Call(opts, &out, "slashRatio")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// SlashRatio is a free data retrieval call binding the contract method 0xd27ca89b.
//
// Solidity: function slashRatio() view returns(uint256)
func (_FcpCollateral *FcpCollateralSession) SlashRatio() (*big.Int, error) {
	return _FcpCollateral.Contract.SlashRatio(&_FcpCollateral.CallOpts)
}

// SlashRatio is a free data retrieval call binding the contract method 0xd27ca89b.
//
// Solidity: function slashRatio() view returns(uint256)
func (_FcpCollateral *FcpCollateralCallerSession) SlashRatio() (*big.Int, error) {
	return _FcpCollateral.Contract.SlashRatio(&_FcpCollateral.CallOpts)
}

// SlashedFunds is a free data retrieval call binding the contract method 0x6f99f15c.
//
// Solidity: function slashedFunds() view returns(uint256)
func (_FcpCollateral *FcpCollateralCaller) SlashedFunds(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _FcpCollateral.contract.Call(opts, &out, "slashedFunds")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// SlashedFunds is a free data retrieval call binding the contract method 0x6f99f15c.
//
// Solidity: function slashedFunds() view returns(uint256)
func (_FcpCollateral *FcpCollateralSession) SlashedFunds() (*big.Int, error) {
	return _FcpCollateral.Contract.SlashedFunds(&_FcpCollateral.CallOpts)
}

// SlashedFunds is a free data retrieval call binding the contract method 0x6f99f15c.
//
// Solidity: function slashedFunds() view returns(uint256)
func (_FcpCollateral *FcpCollateralCallerSession) SlashedFunds() (*big.Int, error) {
	return _FcpCollateral.Contract.SlashedFunds(&_FcpCollateral.CallOpts)
}

// Tasks is a free data retrieval call binding the contract method 0x58709cf2.
//
// Solidity: function tasks(string ) view returns(uint256 collateral, uint8 collateralStatus)
func (_FcpCollateral *FcpCollateralCaller) Tasks(opts *bind.CallOpts, arg0 string) (struct {
	Collateral       *big.Int
	CollateralStatus uint8
}, error) {
	var out []interface{}
	err := _FcpCollateral.contract.Call(opts, &out, "tasks", arg0)

	outstruct := new(struct {
		Collateral       *big.Int
		CollateralStatus uint8
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Collateral = *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)
	outstruct.CollateralStatus = *abi.ConvertType(out[1], new(uint8)).(*uint8)

	return *outstruct, err

}

// Tasks is a free data retrieval call binding the contract method 0x58709cf2.
//
// Solidity: function tasks(string ) view returns(uint256 collateral, uint8 collateralStatus)
func (_FcpCollateral *FcpCollateralSession) Tasks(arg0 string) (struct {
	Collateral       *big.Int
	CollateralStatus uint8
}, error) {
	return _FcpCollateral.Contract.Tasks(&_FcpCollateral.CallOpts, arg0)
}

// Tasks is a free data retrieval call binding the contract method 0x58709cf2.
//
// Solidity: function tasks(string ) view returns(uint256 collateral, uint8 collateralStatus)
func (_FcpCollateral *FcpCollateralCallerSession) Tasks(arg0 string) (struct {
	Collateral       *big.Int
	CollateralStatus uint8
}, error) {
	return _FcpCollateral.Contract.Tasks(&_FcpCollateral.CallOpts, arg0)
}

// Version is a free data retrieval call binding the contract method 0x54fd4d50.
//
// Solidity: function version() pure returns(uint256)
func (_FcpCollateral *FcpCollateralCaller) Version(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _FcpCollateral.contract.Call(opts, &out, "version")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Version is a free data retrieval call binding the contract method 0x54fd4d50.
//
// Solidity: function version() pure returns(uint256)
func (_FcpCollateral *FcpCollateralSession) Version() (*big.Int, error) {
	return _FcpCollateral.Contract.Version(&_FcpCollateral.CallOpts)
}

// Version is a free data retrieval call binding the contract method 0x54fd4d50.
//
// Solidity: function version() pure returns(uint256)
func (_FcpCollateral *FcpCollateralCallerSession) Version() (*big.Int, error) {
	return _FcpCollateral.Contract.Version(&_FcpCollateral.CallOpts)
}

// AddAdmin is a paid mutator transaction binding the contract method 0x70480275.
//
// Solidity: function addAdmin(address newAdmin) returns()
func (_FcpCollateral *FcpCollateralTransactor) AddAdmin(opts *bind.TransactOpts, newAdmin common.Address) (*types.Transaction, error) {
	return _FcpCollateral.contract.Transact(opts, "addAdmin", newAdmin)
}

// AddAdmin is a paid mutator transaction binding the contract method 0x70480275.
//
// Solidity: function addAdmin(address newAdmin) returns()
func (_FcpCollateral *FcpCollateralSession) AddAdmin(newAdmin common.Address) (*types.Transaction, error) {
	return _FcpCollateral.Contract.AddAdmin(&_FcpCollateral.TransactOpts, newAdmin)
}

// AddAdmin is a paid mutator transaction binding the contract method 0x70480275.
//
// Solidity: function addAdmin(address newAdmin) returns()
func (_FcpCollateral *FcpCollateralTransactorSession) AddAdmin(newAdmin common.Address) (*types.Transaction, error) {
	return _FcpCollateral.Contract.AddAdmin(&_FcpCollateral.TransactOpts, newAdmin)
}

// Deposit is a paid mutator transaction binding the contract method 0x47e7ef24.
//
// Solidity: function deposit(address cpAccount, uint256 amount) returns()
func (_FcpCollateral *FcpCollateralTransactor) Deposit(opts *bind.TransactOpts, cpAccount common.Address, amount *big.Int) (*types.Transaction, error) {
	return _FcpCollateral.contract.Transact(opts, "deposit", cpAccount, amount)
}

// Deposit is a paid mutator transaction binding the contract method 0x47e7ef24.
//
// Solidity: function deposit(address cpAccount, uint256 amount) returns()
func (_FcpCollateral *FcpCollateralSession) Deposit(cpAccount common.Address, amount *big.Int) (*types.Transaction, error) {
	return _FcpCollateral.Contract.Deposit(&_FcpCollateral.TransactOpts, cpAccount, amount)
}

// Deposit is a paid mutator transaction binding the contract method 0x47e7ef24.
//
// Solidity: function deposit(address cpAccount, uint256 amount) returns()
func (_FcpCollateral *FcpCollateralTransactorSession) Deposit(cpAccount common.Address, amount *big.Int) (*types.Transaction, error) {
	return _FcpCollateral.Contract.Deposit(&_FcpCollateral.TransactOpts, cpAccount, amount)
}

// DisputeProof is a paid mutator transaction binding the contract method 0xe80d9dec.
//
// Solidity: function disputeProof(string taskUid) returns()
func (_FcpCollateral *FcpCollateralTransactor) DisputeProof(opts *bind.TransactOpts, taskUid string) (*types.Transaction, error) {
	return _FcpCollateral.contract.Transact(opts, "disputeProof", taskUid)
}

// DisputeProof is a paid mutator transaction binding the contract method 0xe80d9dec.
//
// Solidity: function disputeProof(string taskUid) returns()
func (_FcpCollateral *FcpCollateralSession) DisputeProof(taskUid string) (*types.Transaction, error) {
	return _FcpCollateral.Contract.DisputeProof(&_FcpCollateral.TransactOpts, taskUid)
}

// DisputeProof is a paid mutator transaction binding the contract method 0xe80d9dec.
//
// Solidity: function disputeProof(string taskUid) returns()
func (_FcpCollateral *FcpCollateralTransactorSession) DisputeProof(taskUid string) (*types.Transaction, error) {
	return _FcpCollateral.Contract.DisputeProof(&_FcpCollateral.TransactOpts, taskUid)
}

// Initialize is a paid mutator transaction binding the contract method 0x8129fc1c.
//
// Solidity: function initialize() returns()
func (_FcpCollateral *FcpCollateralTransactor) Initialize(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _FcpCollateral.contract.Transact(opts, "initialize")
}

// Initialize is a paid mutator transaction binding the contract method 0x8129fc1c.
//
// Solidity: function initialize() returns()
func (_FcpCollateral *FcpCollateralSession) Initialize() (*types.Transaction, error) {
	return _FcpCollateral.Contract.Initialize(&_FcpCollateral.TransactOpts)
}

// Initialize is a paid mutator transaction binding the contract method 0x8129fc1c.
//
// Solidity: function initialize() returns()
func (_FcpCollateral *FcpCollateralTransactorSession) Initialize() (*types.Transaction, error) {
	return _FcpCollateral.Contract.Initialize(&_FcpCollateral.TransactOpts)
}

// LockCollateral is a paid mutator transaction binding the contract method 0x853911b2.
//
// Solidity: function lockCollateral(string taskUid, address[] cpList, uint256 taskCollateral) returns()
func (_FcpCollateral *FcpCollateralTransactor) LockCollateral(opts *bind.TransactOpts, taskUid string, cpList []common.Address, taskCollateral *big.Int) (*types.Transaction, error) {
	return _FcpCollateral.contract.Transact(opts, "lockCollateral", taskUid, cpList, taskCollateral)
}

// LockCollateral is a paid mutator transaction binding the contract method 0x853911b2.
//
// Solidity: function lockCollateral(string taskUid, address[] cpList, uint256 taskCollateral) returns()
func (_FcpCollateral *FcpCollateralSession) LockCollateral(taskUid string, cpList []common.Address, taskCollateral *big.Int) (*types.Transaction, error) {
	return _FcpCollateral.Contract.LockCollateral(&_FcpCollateral.TransactOpts, taskUid, cpList, taskCollateral)
}

// LockCollateral is a paid mutator transaction binding the contract method 0x853911b2.
//
// Solidity: function lockCollateral(string taskUid, address[] cpList, uint256 taskCollateral) returns()
func (_FcpCollateral *FcpCollateralTransactorSession) LockCollateral(taskUid string, cpList []common.Address, taskCollateral *big.Int) (*types.Transaction, error) {
	return _FcpCollateral.Contract.LockCollateral(&_FcpCollateral.TransactOpts, taskUid, cpList, taskCollateral)
}

// RemoveAdmin is a paid mutator transaction binding the contract method 0x1785f53c.
//
// Solidity: function removeAdmin(address admin) returns()
func (_FcpCollateral *FcpCollateralTransactor) RemoveAdmin(opts *bind.TransactOpts, admin common.Address) (*types.Transaction, error) {
	return _FcpCollateral.contract.Transact(opts, "removeAdmin", admin)
}

// RemoveAdmin is a paid mutator transaction binding the contract method 0x1785f53c.
//
// Solidity: function removeAdmin(address admin) returns()
func (_FcpCollateral *FcpCollateralSession) RemoveAdmin(admin common.Address) (*types.Transaction, error) {
	return _FcpCollateral.Contract.RemoveAdmin(&_FcpCollateral.TransactOpts, admin)
}

// RemoveAdmin is a paid mutator transaction binding the contract method 0x1785f53c.
//
// Solidity: function removeAdmin(address admin) returns()
func (_FcpCollateral *FcpCollateralTransactorSession) RemoveAdmin(admin common.Address) (*types.Transaction, error) {
	return _FcpCollateral.Contract.RemoveAdmin(&_FcpCollateral.TransactOpts, admin)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_FcpCollateral *FcpCollateralTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _FcpCollateral.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_FcpCollateral *FcpCollateralSession) RenounceOwnership() (*types.Transaction, error) {
	return _FcpCollateral.Contract.RenounceOwnership(&_FcpCollateral.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_FcpCollateral *FcpCollateralTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _FcpCollateral.Contract.RenounceOwnership(&_FcpCollateral.TransactOpts)
}

// SendETH is a paid mutator transaction binding the contract method 0x64a197f3.
//
// Solidity: function sendETH(address recipient, uint256 amount) returns()
func (_FcpCollateral *FcpCollateralTransactor) SendETH(opts *bind.TransactOpts, recipient common.Address, amount *big.Int) (*types.Transaction, error) {
	return _FcpCollateral.contract.Transact(opts, "sendETH", recipient, amount)
}

// SendETH is a paid mutator transaction binding the contract method 0x64a197f3.
//
// Solidity: function sendETH(address recipient, uint256 amount) returns()
func (_FcpCollateral *FcpCollateralSession) SendETH(recipient common.Address, amount *big.Int) (*types.Transaction, error) {
	return _FcpCollateral.Contract.SendETH(&_FcpCollateral.TransactOpts, recipient, amount)
}

// SendETH is a paid mutator transaction binding the contract method 0x64a197f3.
//
// Solidity: function sendETH(address recipient, uint256 amount) returns()
func (_FcpCollateral *FcpCollateralTransactorSession) SendETH(recipient common.Address, amount *big.Int) (*types.Transaction, error) {
	return _FcpCollateral.Contract.SendETH(&_FcpCollateral.TransactOpts, recipient, amount)
}

// SetBaseCollateral is a paid mutator transaction binding the contract method 0x7f58a7e5.
//
// Solidity: function setBaseCollateral(uint256 _baseCollateral) returns()
func (_FcpCollateral *FcpCollateralTransactor) SetBaseCollateral(opts *bind.TransactOpts, _baseCollateral *big.Int) (*types.Transaction, error) {
	return _FcpCollateral.contract.Transact(opts, "setBaseCollateral", _baseCollateral)
}

// SetBaseCollateral is a paid mutator transaction binding the contract method 0x7f58a7e5.
//
// Solidity: function setBaseCollateral(uint256 _baseCollateral) returns()
func (_FcpCollateral *FcpCollateralSession) SetBaseCollateral(_baseCollateral *big.Int) (*types.Transaction, error) {
	return _FcpCollateral.Contract.SetBaseCollateral(&_FcpCollateral.TransactOpts, _baseCollateral)
}

// SetBaseCollateral is a paid mutator transaction binding the contract method 0x7f58a7e5.
//
// Solidity: function setBaseCollateral(uint256 _baseCollateral) returns()
func (_FcpCollateral *FcpCollateralTransactorSession) SetBaseCollateral(_baseCollateral *big.Int) (*types.Transaction, error) {
	return _FcpCollateral.Contract.SetBaseCollateral(&_FcpCollateral.TransactOpts, _baseCollateral)
}

// SetCollateralToken is a paid mutator transaction binding the contract method 0x666181a9.
//
// Solidity: function setCollateralToken(address tokenAddress) returns()
func (_FcpCollateral *FcpCollateralTransactor) SetCollateralToken(opts *bind.TransactOpts, tokenAddress common.Address) (*types.Transaction, error) {
	return _FcpCollateral.contract.Transact(opts, "setCollateralToken", tokenAddress)
}

// SetCollateralToken is a paid mutator transaction binding the contract method 0x666181a9.
//
// Solidity: function setCollateralToken(address tokenAddress) returns()
func (_FcpCollateral *FcpCollateralSession) SetCollateralToken(tokenAddress common.Address) (*types.Transaction, error) {
	return _FcpCollateral.Contract.SetCollateralToken(&_FcpCollateral.TransactOpts, tokenAddress)
}

// SetCollateralToken is a paid mutator transaction binding the contract method 0x666181a9.
//
// Solidity: function setCollateralToken(address tokenAddress) returns()
func (_FcpCollateral *FcpCollateralTransactorSession) SetCollateralToken(tokenAddress common.Address) (*types.Transaction, error) {
	return _FcpCollateral.Contract.SetCollateralToken(&_FcpCollateral.TransactOpts, tokenAddress)
}

// SetSlashRatio is a paid mutator transaction binding the contract method 0xce3518aa.
//
// Solidity: function setSlashRatio(uint256 _slashRatio) returns()
func (_FcpCollateral *FcpCollateralTransactor) SetSlashRatio(opts *bind.TransactOpts, _slashRatio *big.Int) (*types.Transaction, error) {
	return _FcpCollateral.contract.Transact(opts, "setSlashRatio", _slashRatio)
}

// SetSlashRatio is a paid mutator transaction binding the contract method 0xce3518aa.
//
// Solidity: function setSlashRatio(uint256 _slashRatio) returns()
func (_FcpCollateral *FcpCollateralSession) SetSlashRatio(_slashRatio *big.Int) (*types.Transaction, error) {
	return _FcpCollateral.Contract.SetSlashRatio(&_FcpCollateral.TransactOpts, _slashRatio)
}

// SetSlashRatio is a paid mutator transaction binding the contract method 0xce3518aa.
//
// Solidity: function setSlashRatio(uint256 _slashRatio) returns()
func (_FcpCollateral *FcpCollateralTransactorSession) SetSlashRatio(_slashRatio *big.Int) (*types.Transaction, error) {
	return _FcpCollateral.Contract.SetSlashRatio(&_FcpCollateral.TransactOpts, _slashRatio)
}

// SlashCollateral is a paid mutator transaction binding the contract method 0xdd98fff5.
//
// Solidity: function slashCollateral(string taskUid, address cpAccount) returns()
func (_FcpCollateral *FcpCollateralTransactor) SlashCollateral(opts *bind.TransactOpts, taskUid string, cpAccount common.Address) (*types.Transaction, error) {
	return _FcpCollateral.contract.Transact(opts, "slashCollateral", taskUid, cpAccount)
}

// SlashCollateral is a paid mutator transaction binding the contract method 0xdd98fff5.
//
// Solidity: function slashCollateral(string taskUid, address cpAccount) returns()
func (_FcpCollateral *FcpCollateralSession) SlashCollateral(taskUid string, cpAccount common.Address) (*types.Transaction, error) {
	return _FcpCollateral.Contract.SlashCollateral(&_FcpCollateral.TransactOpts, taskUid, cpAccount)
}

// SlashCollateral is a paid mutator transaction binding the contract method 0xdd98fff5.
//
// Solidity: function slashCollateral(string taskUid, address cpAccount) returns()
func (_FcpCollateral *FcpCollateralTransactorSession) SlashCollateral(taskUid string, cpAccount common.Address) (*types.Transaction, error) {
	return _FcpCollateral.Contract.SlashCollateral(&_FcpCollateral.TransactOpts, taskUid, cpAccount)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_FcpCollateral *FcpCollateralTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _FcpCollateral.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_FcpCollateral *FcpCollateralSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _FcpCollateral.Contract.TransferOwnership(&_FcpCollateral.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_FcpCollateral *FcpCollateralTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _FcpCollateral.Contract.TransferOwnership(&_FcpCollateral.TransactOpts, newOwner)
}

// UnlockCollateral is a paid mutator transaction binding the contract method 0x4b9f0bea.
//
// Solidity: function unlockCollateral(string taskUid, uint256 amount) returns()
func (_FcpCollateral *FcpCollateralTransactor) UnlockCollateral(opts *bind.TransactOpts, taskUid string, amount *big.Int) (*types.Transaction, error) {
	return _FcpCollateral.contract.Transact(opts, "unlockCollateral", taskUid, amount)
}

// UnlockCollateral is a paid mutator transaction binding the contract method 0x4b9f0bea.
//
// Solidity: function unlockCollateral(string taskUid, uint256 amount) returns()
func (_FcpCollateral *FcpCollateralSession) UnlockCollateral(taskUid string, amount *big.Int) (*types.Transaction, error) {
	return _FcpCollateral.Contract.UnlockCollateral(&_FcpCollateral.TransactOpts, taskUid, amount)
}

// UnlockCollateral is a paid mutator transaction binding the contract method 0x4b9f0bea.
//
// Solidity: function unlockCollateral(string taskUid, uint256 amount) returns()
func (_FcpCollateral *FcpCollateralTransactorSession) UnlockCollateral(taskUid string, amount *big.Int) (*types.Transaction, error) {
	return _FcpCollateral.Contract.UnlockCollateral(&_FcpCollateral.TransactOpts, taskUid, amount)
}

// UpgradeTo is a paid mutator transaction binding the contract method 0x3659cfe6.
//
// Solidity: function upgradeTo(address newImplementation) returns()
func (_FcpCollateral *FcpCollateralTransactor) UpgradeTo(opts *bind.TransactOpts, newImplementation common.Address) (*types.Transaction, error) {
	return _FcpCollateral.contract.Transact(opts, "upgradeTo", newImplementation)
}

// UpgradeTo is a paid mutator transaction binding the contract method 0x3659cfe6.
//
// Solidity: function upgradeTo(address newImplementation) returns()
func (_FcpCollateral *FcpCollateralSession) UpgradeTo(newImplementation common.Address) (*types.Transaction, error) {
	return _FcpCollateral.Contract.UpgradeTo(&_FcpCollateral.TransactOpts, newImplementation)
}

// UpgradeTo is a paid mutator transaction binding the contract method 0x3659cfe6.
//
// Solidity: function upgradeTo(address newImplementation) returns()
func (_FcpCollateral *FcpCollateralTransactorSession) UpgradeTo(newImplementation common.Address) (*types.Transaction, error) {
	return _FcpCollateral.Contract.UpgradeTo(&_FcpCollateral.TransactOpts, newImplementation)
}

// UpgradeToAndCall is a paid mutator transaction binding the contract method 0x4f1ef286.
//
// Solidity: function upgradeToAndCall(address newImplementation, bytes data) payable returns()
func (_FcpCollateral *FcpCollateralTransactor) UpgradeToAndCall(opts *bind.TransactOpts, newImplementation common.Address, data []byte) (*types.Transaction, error) {
	return _FcpCollateral.contract.Transact(opts, "upgradeToAndCall", newImplementation, data)
}

// UpgradeToAndCall is a paid mutator transaction binding the contract method 0x4f1ef286.
//
// Solidity: function upgradeToAndCall(address newImplementation, bytes data) payable returns()
func (_FcpCollateral *FcpCollateralSession) UpgradeToAndCall(newImplementation common.Address, data []byte) (*types.Transaction, error) {
	return _FcpCollateral.Contract.UpgradeToAndCall(&_FcpCollateral.TransactOpts, newImplementation, data)
}

// UpgradeToAndCall is a paid mutator transaction binding the contract method 0x4f1ef286.
//
// Solidity: function upgradeToAndCall(address newImplementation, bytes data) payable returns()
func (_FcpCollateral *FcpCollateralTransactorSession) UpgradeToAndCall(newImplementation common.Address, data []byte) (*types.Transaction, error) {
	return _FcpCollateral.Contract.UpgradeToAndCall(&_FcpCollateral.TransactOpts, newImplementation, data)
}

// Withdraw is a paid mutator transaction binding the contract method 0xf3fef3a3.
//
// Solidity: function withdraw(address cpAccount, uint256 amount) returns()
func (_FcpCollateral *FcpCollateralTransactor) Withdraw(opts *bind.TransactOpts, cpAccount common.Address, amount *big.Int) (*types.Transaction, error) {
	return _FcpCollateral.contract.Transact(opts, "withdraw", cpAccount, amount)
}

// Withdraw is a paid mutator transaction binding the contract method 0xf3fef3a3.
//
// Solidity: function withdraw(address cpAccount, uint256 amount) returns()
func (_FcpCollateral *FcpCollateralSession) Withdraw(cpAccount common.Address, amount *big.Int) (*types.Transaction, error) {
	return _FcpCollateral.Contract.Withdraw(&_FcpCollateral.TransactOpts, cpAccount, amount)
}

// Withdraw is a paid mutator transaction binding the contract method 0xf3fef3a3.
//
// Solidity: function withdraw(address cpAccount, uint256 amount) returns()
func (_FcpCollateral *FcpCollateralTransactorSession) Withdraw(cpAccount common.Address, amount *big.Int) (*types.Transaction, error) {
	return _FcpCollateral.Contract.Withdraw(&_FcpCollateral.TransactOpts, cpAccount, amount)
}

// WithdrawSlashedFunds is a paid mutator transaction binding the contract method 0x2894493f.
//
// Solidity: function withdrawSlashedFunds(uint256 amount) returns()
func (_FcpCollateral *FcpCollateralTransactor) WithdrawSlashedFunds(opts *bind.TransactOpts, amount *big.Int) (*types.Transaction, error) {
	return _FcpCollateral.contract.Transact(opts, "withdrawSlashedFunds", amount)
}

// WithdrawSlashedFunds is a paid mutator transaction binding the contract method 0x2894493f.
//
// Solidity: function withdrawSlashedFunds(uint256 amount) returns()
func (_FcpCollateral *FcpCollateralSession) WithdrawSlashedFunds(amount *big.Int) (*types.Transaction, error) {
	return _FcpCollateral.Contract.WithdrawSlashedFunds(&_FcpCollateral.TransactOpts, amount)
}

// WithdrawSlashedFunds is a paid mutator transaction binding the contract method 0x2894493f.
//
// Solidity: function withdrawSlashedFunds(uint256 amount) returns()
func (_FcpCollateral *FcpCollateralTransactorSession) WithdrawSlashedFunds(amount *big.Int) (*types.Transaction, error) {
	return _FcpCollateral.Contract.WithdrawSlashedFunds(&_FcpCollateral.TransactOpts, amount)
}

// FcpCollateralAdminChangedIterator is returned from FilterAdminChanged and is used to iterate over the raw logs and unpacked data for AdminChanged events raised by the FcpCollateral contract.
type FcpCollateralAdminChangedIterator struct {
	Event *FcpCollateralAdminChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *FcpCollateralAdminChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(FcpCollateralAdminChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(FcpCollateralAdminChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *FcpCollateralAdminChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *FcpCollateralAdminChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// FcpCollateralAdminChanged represents a AdminChanged event raised by the FcpCollateral contract.
type FcpCollateralAdminChanged struct {
	PreviousAdmin common.Address
	NewAdmin      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterAdminChanged is a free log retrieval operation binding the contract event 0x7e644d79422f17c01e4894b5f4f588d331ebfa28653d42ae832dc59e38c9798f.
//
// Solidity: event AdminChanged(address previousAdmin, address newAdmin)
func (_FcpCollateral *FcpCollateralFilterer) FilterAdminChanged(opts *bind.FilterOpts) (*FcpCollateralAdminChangedIterator, error) {

	logs, sub, err := _FcpCollateral.contract.FilterLogs(opts, "AdminChanged")
	if err != nil {
		return nil, err
	}
	return &FcpCollateralAdminChangedIterator{contract: _FcpCollateral.contract, event: "AdminChanged", logs: logs, sub: sub}, nil
}

// WatchAdminChanged is a free log subscription operation binding the contract event 0x7e644d79422f17c01e4894b5f4f588d331ebfa28653d42ae832dc59e38c9798f.
//
// Solidity: event AdminChanged(address previousAdmin, address newAdmin)
func (_FcpCollateral *FcpCollateralFilterer) WatchAdminChanged(opts *bind.WatchOpts, sink chan<- *FcpCollateralAdminChanged) (event.Subscription, error) {

	logs, sub, err := _FcpCollateral.contract.WatchLogs(opts, "AdminChanged")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(FcpCollateralAdminChanged)
				if err := _FcpCollateral.contract.UnpackLog(event, "AdminChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAdminChanged is a log parse operation binding the contract event 0x7e644d79422f17c01e4894b5f4f588d331ebfa28653d42ae832dc59e38c9798f.
//
// Solidity: event AdminChanged(address previousAdmin, address newAdmin)
func (_FcpCollateral *FcpCollateralFilterer) ParseAdminChanged(log types.Log) (*FcpCollateralAdminChanged, error) {
	event := new(FcpCollateralAdminChanged)
	if err := _FcpCollateral.contract.UnpackLog(event, "AdminChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// FcpCollateralBeaconUpgradedIterator is returned from FilterBeaconUpgraded and is used to iterate over the raw logs and unpacked data for BeaconUpgraded events raised by the FcpCollateral contract.
type FcpCollateralBeaconUpgradedIterator struct {
	Event *FcpCollateralBeaconUpgraded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *FcpCollateralBeaconUpgradedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(FcpCollateralBeaconUpgraded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(FcpCollateralBeaconUpgraded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *FcpCollateralBeaconUpgradedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *FcpCollateralBeaconUpgradedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// FcpCollateralBeaconUpgraded represents a BeaconUpgraded event raised by the FcpCollateral contract.
type FcpCollateralBeaconUpgraded struct {
	Beacon common.Address
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterBeaconUpgraded is a free log retrieval operation binding the contract event 0x1cf3b03a6cf19fa2baba4df148e9dcabedea7f8a5c07840e207e5c089be95d3e.
//
// Solidity: event BeaconUpgraded(address indexed beacon)
func (_FcpCollateral *FcpCollateralFilterer) FilterBeaconUpgraded(opts *bind.FilterOpts, beacon []common.Address) (*FcpCollateralBeaconUpgradedIterator, error) {

	var beaconRule []interface{}
	for _, beaconItem := range beacon {
		beaconRule = append(beaconRule, beaconItem)
	}

	logs, sub, err := _FcpCollateral.contract.FilterLogs(opts, "BeaconUpgraded", beaconRule)
	if err != nil {
		return nil, err
	}
	return &FcpCollateralBeaconUpgradedIterator{contract: _FcpCollateral.contract, event: "BeaconUpgraded", logs: logs, sub: sub}, nil
}

// WatchBeaconUpgraded is a free log subscription operation binding the contract event 0x1cf3b03a6cf19fa2baba4df148e9dcabedea7f8a5c07840e207e5c089be95d3e.
//
// Solidity: event BeaconUpgraded(address indexed beacon)
func (_FcpCollateral *FcpCollateralFilterer) WatchBeaconUpgraded(opts *bind.WatchOpts, sink chan<- *FcpCollateralBeaconUpgraded, beacon []common.Address) (event.Subscription, error) {

	var beaconRule []interface{}
	for _, beaconItem := range beacon {
		beaconRule = append(beaconRule, beaconItem)
	}

	logs, sub, err := _FcpCollateral.contract.WatchLogs(opts, "BeaconUpgraded", beaconRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(FcpCollateralBeaconUpgraded)
				if err := _FcpCollateral.contract.UnpackLog(event, "BeaconUpgraded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseBeaconUpgraded is a log parse operation binding the contract event 0x1cf3b03a6cf19fa2baba4df148e9dcabedea7f8a5c07840e207e5c089be95d3e.
//
// Solidity: event BeaconUpgraded(address indexed beacon)
func (_FcpCollateral *FcpCollateralFilterer) ParseBeaconUpgraded(log types.Log) (*FcpCollateralBeaconUpgraded, error) {
	event := new(FcpCollateralBeaconUpgraded)
	if err := _FcpCollateral.contract.UnpackLog(event, "BeaconUpgraded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// FcpCollateralCollateralAdjustedIterator is returned from FilterCollateralAdjusted and is used to iterate over the raw logs and unpacked data for CollateralAdjusted events raised by the FcpCollateral contract.
type FcpCollateralCollateralAdjustedIterator struct {
	Event *FcpCollateralCollateralAdjusted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *FcpCollateralCollateralAdjustedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(FcpCollateralCollateralAdjusted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(FcpCollateralCollateralAdjusted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *FcpCollateralCollateralAdjustedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *FcpCollateralCollateralAdjustedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// FcpCollateralCollateralAdjusted represents a CollateralAdjusted event raised by the FcpCollateral contract.
type FcpCollateralCollateralAdjusted struct {
	Cp            common.Address
	FrozenAmount  *big.Int
	BalanceAmount *big.Int
	Operation     string
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterCollateralAdjusted is a free log retrieval operation binding the contract event 0x42f1a8a1aee108e84e4eabfaa8d51d7baaa1a02d482295297883a44b2debd3e4.
//
// Solidity: event CollateralAdjusted(address indexed cp, uint256 frozenAmount, uint256 balanceAmount, string operation)
func (_FcpCollateral *FcpCollateralFilterer) FilterCollateralAdjusted(opts *bind.FilterOpts, cp []common.Address) (*FcpCollateralCollateralAdjustedIterator, error) {

	var cpRule []interface{}
	for _, cpItem := range cp {
		cpRule = append(cpRule, cpItem)
	}

	logs, sub, err := _FcpCollateral.contract.FilterLogs(opts, "CollateralAdjusted", cpRule)
	if err != nil {
		return nil, err
	}
	return &FcpCollateralCollateralAdjustedIterator{contract: _FcpCollateral.contract, event: "CollateralAdjusted", logs: logs, sub: sub}, nil
}

// WatchCollateralAdjusted is a free log subscription operation binding the contract event 0x42f1a8a1aee108e84e4eabfaa8d51d7baaa1a02d482295297883a44b2debd3e4.
//
// Solidity: event CollateralAdjusted(address indexed cp, uint256 frozenAmount, uint256 balanceAmount, string operation)
func (_FcpCollateral *FcpCollateralFilterer) WatchCollateralAdjusted(opts *bind.WatchOpts, sink chan<- *FcpCollateralCollateralAdjusted, cp []common.Address) (event.Subscription, error) {

	var cpRule []interface{}
	for _, cpItem := range cp {
		cpRule = append(cpRule, cpItem)
	}

	logs, sub, err := _FcpCollateral.contract.WatchLogs(opts, "CollateralAdjusted", cpRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(FcpCollateralCollateralAdjusted)
				if err := _FcpCollateral.contract.UnpackLog(event, "CollateralAdjusted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseCollateralAdjusted is a log parse operation binding the contract event 0x42f1a8a1aee108e84e4eabfaa8d51d7baaa1a02d482295297883a44b2debd3e4.
//
// Solidity: event CollateralAdjusted(address indexed cp, uint256 frozenAmount, uint256 balanceAmount, string operation)
func (_FcpCollateral *FcpCollateralFilterer) ParseCollateralAdjusted(log types.Log) (*FcpCollateralCollateralAdjusted, error) {
	event := new(FcpCollateralCollateralAdjusted)
	if err := _FcpCollateral.contract.UnpackLog(event, "CollateralAdjusted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// FcpCollateralCollateralLockedIterator is returned from FilterCollateralLocked and is used to iterate over the raw logs and unpacked data for CollateralLocked events raised by the FcpCollateral contract.
type FcpCollateralCollateralLockedIterator struct {
	Event *FcpCollateralCollateralLocked // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *FcpCollateralCollateralLockedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(FcpCollateralCollateralLocked)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(FcpCollateralCollateralLocked)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *FcpCollateralCollateralLockedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *FcpCollateralCollateralLockedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// FcpCollateralCollateralLocked represents a CollateralLocked event raised by the FcpCollateral contract.
type FcpCollateralCollateralLocked struct {
	Cp               common.Address
	CollateralAmount *big.Int
	TaskUid          string
	Raw              types.Log // Blockchain specific contextual infos
}

// FilterCollateralLocked is a free log retrieval operation binding the contract event 0x5f3d004cf9164b95ed5dbf47d1f04018a4eabcb20b4320fe229ed92236ace634.
//
// Solidity: event CollateralLocked(address indexed cp, uint256 collateralAmount, string taskUid)
func (_FcpCollateral *FcpCollateralFilterer) FilterCollateralLocked(opts *bind.FilterOpts, cp []common.Address) (*FcpCollateralCollateralLockedIterator, error) {

	var cpRule []interface{}
	for _, cpItem := range cp {
		cpRule = append(cpRule, cpItem)
	}

	logs, sub, err := _FcpCollateral.contract.FilterLogs(opts, "CollateralLocked", cpRule)
	if err != nil {
		return nil, err
	}
	return &FcpCollateralCollateralLockedIterator{contract: _FcpCollateral.contract, event: "CollateralLocked", logs: logs, sub: sub}, nil
}

// WatchCollateralLocked is a free log subscription operation binding the contract event 0x5f3d004cf9164b95ed5dbf47d1f04018a4eabcb20b4320fe229ed92236ace634.
//
// Solidity: event CollateralLocked(address indexed cp, uint256 collateralAmount, string taskUid)
func (_FcpCollateral *FcpCollateralFilterer) WatchCollateralLocked(opts *bind.WatchOpts, sink chan<- *FcpCollateralCollateralLocked, cp []common.Address) (event.Subscription, error) {

	var cpRule []interface{}
	for _, cpItem := range cp {
		cpRule = append(cpRule, cpItem)
	}

	logs, sub, err := _FcpCollateral.contract.WatchLogs(opts, "CollateralLocked", cpRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(FcpCollateralCollateralLocked)
				if err := _FcpCollateral.contract.UnpackLog(event, "CollateralLocked", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseCollateralLocked is a log parse operation binding the contract event 0x5f3d004cf9164b95ed5dbf47d1f04018a4eabcb20b4320fe229ed92236ace634.
//
// Solidity: event CollateralLocked(address indexed cp, uint256 collateralAmount, string taskUid)
func (_FcpCollateral *FcpCollateralFilterer) ParseCollateralLocked(log types.Log) (*FcpCollateralCollateralLocked, error) {
	event := new(FcpCollateralCollateralLocked)
	if err := _FcpCollateral.contract.UnpackLog(event, "CollateralLocked", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// FcpCollateralCollateralSlashedIterator is returned from FilterCollateralSlashed and is used to iterate over the raw logs and unpacked data for CollateralSlashed events raised by the FcpCollateral contract.
type FcpCollateralCollateralSlashedIterator struct {
	Event *FcpCollateralCollateralSlashed // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *FcpCollateralCollateralSlashedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(FcpCollateralCollateralSlashed)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(FcpCollateralCollateralSlashed)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *FcpCollateralCollateralSlashedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *FcpCollateralCollateralSlashedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// FcpCollateralCollateralSlashed represents a CollateralSlashed event raised by the FcpCollateral contract.
type FcpCollateralCollateralSlashed struct {
	Cp      common.Address
	Amount  *big.Int
	TaskUid string
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterCollateralSlashed is a free log retrieval operation binding the contract event 0x403feb2cd85cc25c910fe59289105b583f08fe9e4335ebbb08c1851f47ff2d34.
//
// Solidity: event CollateralSlashed(address indexed cp, uint256 amount, string taskUid)
func (_FcpCollateral *FcpCollateralFilterer) FilterCollateralSlashed(opts *bind.FilterOpts, cp []common.Address) (*FcpCollateralCollateralSlashedIterator, error) {

	var cpRule []interface{}
	for _, cpItem := range cp {
		cpRule = append(cpRule, cpItem)
	}

	logs, sub, err := _FcpCollateral.contract.FilterLogs(opts, "CollateralSlashed", cpRule)
	if err != nil {
		return nil, err
	}
	return &FcpCollateralCollateralSlashedIterator{contract: _FcpCollateral.contract, event: "CollateralSlashed", logs: logs, sub: sub}, nil
}

// WatchCollateralSlashed is a free log subscription operation binding the contract event 0x403feb2cd85cc25c910fe59289105b583f08fe9e4335ebbb08c1851f47ff2d34.
//
// Solidity: event CollateralSlashed(address indexed cp, uint256 amount, string taskUid)
func (_FcpCollateral *FcpCollateralFilterer) WatchCollateralSlashed(opts *bind.WatchOpts, sink chan<- *FcpCollateralCollateralSlashed, cp []common.Address) (event.Subscription, error) {

	var cpRule []interface{}
	for _, cpItem := range cp {
		cpRule = append(cpRule, cpItem)
	}

	logs, sub, err := _FcpCollateral.contract.WatchLogs(opts, "CollateralSlashed", cpRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(FcpCollateralCollateralSlashed)
				if err := _FcpCollateral.contract.UnpackLog(event, "CollateralSlashed", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseCollateralSlashed is a log parse operation binding the contract event 0x403feb2cd85cc25c910fe59289105b583f08fe9e4335ebbb08c1851f47ff2d34.
//
// Solidity: event CollateralSlashed(address indexed cp, uint256 amount, string taskUid)
func (_FcpCollateral *FcpCollateralFilterer) ParseCollateralSlashed(log types.Log) (*FcpCollateralCollateralSlashed, error) {
	event := new(FcpCollateralCollateralSlashed)
	if err := _FcpCollateral.contract.UnpackLog(event, "CollateralSlashed", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// FcpCollateralCollateralStatusChangedIterator is returned from FilterCollateralStatusChanged and is used to iterate over the raw logs and unpacked data for CollateralStatusChanged events raised by the FcpCollateral contract.
type FcpCollateralCollateralStatusChangedIterator struct {
	Event *FcpCollateralCollateralStatusChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *FcpCollateralCollateralStatusChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(FcpCollateralCollateralStatusChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(FcpCollateralCollateralStatusChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *FcpCollateralCollateralStatusChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *FcpCollateralCollateralStatusChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// FcpCollateralCollateralStatusChanged represents a CollateralStatusChanged event raised by the FcpCollateral contract.
type FcpCollateralCollateralStatusChanged struct {
	TaskUid   common.Hash
	NewStatus uint8
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterCollateralStatusChanged is a free log retrieval operation binding the contract event 0x4a2ced9ada462e244851a86e998eb0b5bf558c2c9c6923b7f970ed2b19b073b0.
//
// Solidity: event CollateralStatusChanged(string indexed taskUid, uint8 newStatus)
func (_FcpCollateral *FcpCollateralFilterer) FilterCollateralStatusChanged(opts *bind.FilterOpts, taskUid []string) (*FcpCollateralCollateralStatusChangedIterator, error) {

	var taskUidRule []interface{}
	for _, taskUidItem := range taskUid {
		taskUidRule = append(taskUidRule, taskUidItem)
	}

	logs, sub, err := _FcpCollateral.contract.FilterLogs(opts, "CollateralStatusChanged", taskUidRule)
	if err != nil {
		return nil, err
	}
	return &FcpCollateralCollateralStatusChangedIterator{contract: _FcpCollateral.contract, event: "CollateralStatusChanged", logs: logs, sub: sub}, nil
}

// WatchCollateralStatusChanged is a free log subscription operation binding the contract event 0x4a2ced9ada462e244851a86e998eb0b5bf558c2c9c6923b7f970ed2b19b073b0.
//
// Solidity: event CollateralStatusChanged(string indexed taskUid, uint8 newStatus)
func (_FcpCollateral *FcpCollateralFilterer) WatchCollateralStatusChanged(opts *bind.WatchOpts, sink chan<- *FcpCollateralCollateralStatusChanged, taskUid []string) (event.Subscription, error) {

	var taskUidRule []interface{}
	for _, taskUidItem := range taskUid {
		taskUidRule = append(taskUidRule, taskUidItem)
	}

	logs, sub, err := _FcpCollateral.contract.WatchLogs(opts, "CollateralStatusChanged", taskUidRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(FcpCollateralCollateralStatusChanged)
				if err := _FcpCollateral.contract.UnpackLog(event, "CollateralStatusChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseCollateralStatusChanged is a log parse operation binding the contract event 0x4a2ced9ada462e244851a86e998eb0b5bf558c2c9c6923b7f970ed2b19b073b0.
//
// Solidity: event CollateralStatusChanged(string indexed taskUid, uint8 newStatus)
func (_FcpCollateral *FcpCollateralFilterer) ParseCollateralStatusChanged(log types.Log) (*FcpCollateralCollateralStatusChanged, error) {
	event := new(FcpCollateralCollateralStatusChanged)
	if err := _FcpCollateral.contract.UnpackLog(event, "CollateralStatusChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// FcpCollateralCollateralUnlockedIterator is returned from FilterCollateralUnlocked and is used to iterate over the raw logs and unpacked data for CollateralUnlocked events raised by the FcpCollateral contract.
type FcpCollateralCollateralUnlockedIterator struct {
	Event *FcpCollateralCollateralUnlocked // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *FcpCollateralCollateralUnlockedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(FcpCollateralCollateralUnlocked)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(FcpCollateralCollateralUnlocked)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *FcpCollateralCollateralUnlockedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *FcpCollateralCollateralUnlockedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// FcpCollateralCollateralUnlocked represents a CollateralUnlocked event raised by the FcpCollateral contract.
type FcpCollateralCollateralUnlocked struct {
	Cp               common.Address
	CollateralAmount *big.Int
	TaskUid          string
	Raw              types.Log // Blockchain specific contextual infos
}

// FilterCollateralUnlocked is a free log retrieval operation binding the contract event 0x0f2440b3ca071b7d18e917a25289e7d7e7de8a491546d45acc2efbec7b3e1ae8.
//
// Solidity: event CollateralUnlocked(address indexed cp, uint256 collateralAmount, string taskUid)
func (_FcpCollateral *FcpCollateralFilterer) FilterCollateralUnlocked(opts *bind.FilterOpts, cp []common.Address) (*FcpCollateralCollateralUnlockedIterator, error) {

	var cpRule []interface{}
	for _, cpItem := range cp {
		cpRule = append(cpRule, cpItem)
	}

	logs, sub, err := _FcpCollateral.contract.FilterLogs(opts, "CollateralUnlocked", cpRule)
	if err != nil {
		return nil, err
	}
	return &FcpCollateralCollateralUnlockedIterator{contract: _FcpCollateral.contract, event: "CollateralUnlocked", logs: logs, sub: sub}, nil
}

// WatchCollateralUnlocked is a free log subscription operation binding the contract event 0x0f2440b3ca071b7d18e917a25289e7d7e7de8a491546d45acc2efbec7b3e1ae8.
//
// Solidity: event CollateralUnlocked(address indexed cp, uint256 collateralAmount, string taskUid)
func (_FcpCollateral *FcpCollateralFilterer) WatchCollateralUnlocked(opts *bind.WatchOpts, sink chan<- *FcpCollateralCollateralUnlocked, cp []common.Address) (event.Subscription, error) {

	var cpRule []interface{}
	for _, cpItem := range cp {
		cpRule = append(cpRule, cpItem)
	}

	logs, sub, err := _FcpCollateral.contract.WatchLogs(opts, "CollateralUnlocked", cpRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(FcpCollateralCollateralUnlocked)
				if err := _FcpCollateral.contract.UnpackLog(event, "CollateralUnlocked", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseCollateralUnlocked is a log parse operation binding the contract event 0x0f2440b3ca071b7d18e917a25289e7d7e7de8a491546d45acc2efbec7b3e1ae8.
//
// Solidity: event CollateralUnlocked(address indexed cp, uint256 collateralAmount, string taskUid)
func (_FcpCollateral *FcpCollateralFilterer) ParseCollateralUnlocked(log types.Log) (*FcpCollateralCollateralUnlocked, error) {
	event := new(FcpCollateralCollateralUnlocked)
	if err := _FcpCollateral.contract.UnpackLog(event, "CollateralUnlocked", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// FcpCollateralDepositIterator is returned from FilterDeposit and is used to iterate over the raw logs and unpacked data for Deposit events raised by the FcpCollateral contract.
type FcpCollateralDepositIterator struct {
	Event *FcpCollateralDeposit // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *FcpCollateralDepositIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(FcpCollateralDeposit)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(FcpCollateralDeposit)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *FcpCollateralDepositIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *FcpCollateralDepositIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// FcpCollateralDeposit represents a Deposit event raised by the FcpCollateral contract.
type FcpCollateralDeposit struct {
	FundingWallet common.Address
	CpAccount     common.Address
	DepositAmount *big.Int
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterDeposit is a free log retrieval operation binding the contract event 0x5548c837ab068cf56a2c2479df0882a4922fd203edb7517321831d95078c5f62.
//
// Solidity: event Deposit(address indexed fundingWallet, address indexed cpAccount, uint256 depositAmount)
func (_FcpCollateral *FcpCollateralFilterer) FilterDeposit(opts *bind.FilterOpts, fundingWallet []common.Address, cpAccount []common.Address) (*FcpCollateralDepositIterator, error) {

	var fundingWalletRule []interface{}
	for _, fundingWalletItem := range fundingWallet {
		fundingWalletRule = append(fundingWalletRule, fundingWalletItem)
	}
	var cpAccountRule []interface{}
	for _, cpAccountItem := range cpAccount {
		cpAccountRule = append(cpAccountRule, cpAccountItem)
	}

	logs, sub, err := _FcpCollateral.contract.FilterLogs(opts, "Deposit", fundingWalletRule, cpAccountRule)
	if err != nil {
		return nil, err
	}
	return &FcpCollateralDepositIterator{contract: _FcpCollateral.contract, event: "Deposit", logs: logs, sub: sub}, nil
}

// WatchDeposit is a free log subscription operation binding the contract event 0x5548c837ab068cf56a2c2479df0882a4922fd203edb7517321831d95078c5f62.
//
// Solidity: event Deposit(address indexed fundingWallet, address indexed cpAccount, uint256 depositAmount)
func (_FcpCollateral *FcpCollateralFilterer) WatchDeposit(opts *bind.WatchOpts, sink chan<- *FcpCollateralDeposit, fundingWallet []common.Address, cpAccount []common.Address) (event.Subscription, error) {

	var fundingWalletRule []interface{}
	for _, fundingWalletItem := range fundingWallet {
		fundingWalletRule = append(fundingWalletRule, fundingWalletItem)
	}
	var cpAccountRule []interface{}
	for _, cpAccountItem := range cpAccount {
		cpAccountRule = append(cpAccountRule, cpAccountItem)
	}

	logs, sub, err := _FcpCollateral.contract.WatchLogs(opts, "Deposit", fundingWalletRule, cpAccountRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(FcpCollateralDeposit)
				if err := _FcpCollateral.contract.UnpackLog(event, "Deposit", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDeposit is a log parse operation binding the contract event 0x5548c837ab068cf56a2c2479df0882a4922fd203edb7517321831d95078c5f62.
//
// Solidity: event Deposit(address indexed fundingWallet, address indexed cpAccount, uint256 depositAmount)
func (_FcpCollateral *FcpCollateralFilterer) ParseDeposit(log types.Log) (*FcpCollateralDeposit, error) {
	event := new(FcpCollateralDeposit)
	if err := _FcpCollateral.contract.UnpackLog(event, "Deposit", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// FcpCollateralDisputeProofIterator is returned from FilterDisputeProof and is used to iterate over the raw logs and unpacked data for DisputeProof events raised by the FcpCollateral contract.
type FcpCollateralDisputeProofIterator struct {
	Event *FcpCollateralDisputeProof // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *FcpCollateralDisputeProofIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(FcpCollateralDisputeProof)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(FcpCollateralDisputeProof)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *FcpCollateralDisputeProofIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *FcpCollateralDisputeProofIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// FcpCollateralDisputeProof represents a DisputeProof event raised by the FcpCollateral contract.
type FcpCollateralDisputeProof struct {
	Challenger common.Address
	TaskUid    common.Hash
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterDisputeProof is a free log retrieval operation binding the contract event 0xaec1d412a3c1e4a13fc2a2e19ac38a5af192a9cf17b074fca8146a2d0655e0c3.
//
// Solidity: event DisputeProof(address indexed challenger, string indexed taskUid)
func (_FcpCollateral *FcpCollateralFilterer) FilterDisputeProof(opts *bind.FilterOpts, challenger []common.Address, taskUid []string) (*FcpCollateralDisputeProofIterator, error) {

	var challengerRule []interface{}
	for _, challengerItem := range challenger {
		challengerRule = append(challengerRule, challengerItem)
	}
	var taskUidRule []interface{}
	for _, taskUidItem := range taskUid {
		taskUidRule = append(taskUidRule, taskUidItem)
	}

	logs, sub, err := _FcpCollateral.contract.FilterLogs(opts, "DisputeProof", challengerRule, taskUidRule)
	if err != nil {
		return nil, err
	}
	return &FcpCollateralDisputeProofIterator{contract: _FcpCollateral.contract, event: "DisputeProof", logs: logs, sub: sub}, nil
}

// WatchDisputeProof is a free log subscription operation binding the contract event 0xaec1d412a3c1e4a13fc2a2e19ac38a5af192a9cf17b074fca8146a2d0655e0c3.
//
// Solidity: event DisputeProof(address indexed challenger, string indexed taskUid)
func (_FcpCollateral *FcpCollateralFilterer) WatchDisputeProof(opts *bind.WatchOpts, sink chan<- *FcpCollateralDisputeProof, challenger []common.Address, taskUid []string) (event.Subscription, error) {

	var challengerRule []interface{}
	for _, challengerItem := range challenger {
		challengerRule = append(challengerRule, challengerItem)
	}
	var taskUidRule []interface{}
	for _, taskUidItem := range taskUid {
		taskUidRule = append(taskUidRule, taskUidItem)
	}

	logs, sub, err := _FcpCollateral.contract.WatchLogs(opts, "DisputeProof", challengerRule, taskUidRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(FcpCollateralDisputeProof)
				if err := _FcpCollateral.contract.UnpackLog(event, "DisputeProof", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDisputeProof is a log parse operation binding the contract event 0xaec1d412a3c1e4a13fc2a2e19ac38a5af192a9cf17b074fca8146a2d0655e0c3.
//
// Solidity: event DisputeProof(address indexed challenger, string indexed taskUid)
func (_FcpCollateral *FcpCollateralFilterer) ParseDisputeProof(log types.Log) (*FcpCollateralDisputeProof, error) {
	event := new(FcpCollateralDisputeProof)
	if err := _FcpCollateral.contract.UnpackLog(event, "DisputeProof", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// FcpCollateralInitializedIterator is returned from FilterInitialized and is used to iterate over the raw logs and unpacked data for Initialized events raised by the FcpCollateral contract.
type FcpCollateralInitializedIterator struct {
	Event *FcpCollateralInitialized // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *FcpCollateralInitializedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(FcpCollateralInitialized)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(FcpCollateralInitialized)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *FcpCollateralInitializedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *FcpCollateralInitializedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// FcpCollateralInitialized represents a Initialized event raised by the FcpCollateral contract.
type FcpCollateralInitialized struct {
	Version uint8
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterInitialized is a free log retrieval operation binding the contract event 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498.
//
// Solidity: event Initialized(uint8 version)
func (_FcpCollateral *FcpCollateralFilterer) FilterInitialized(opts *bind.FilterOpts) (*FcpCollateralInitializedIterator, error) {

	logs, sub, err := _FcpCollateral.contract.FilterLogs(opts, "Initialized")
	if err != nil {
		return nil, err
	}
	return &FcpCollateralInitializedIterator{contract: _FcpCollateral.contract, event: "Initialized", logs: logs, sub: sub}, nil
}

// WatchInitialized is a free log subscription operation binding the contract event 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498.
//
// Solidity: event Initialized(uint8 version)
func (_FcpCollateral *FcpCollateralFilterer) WatchInitialized(opts *bind.WatchOpts, sink chan<- *FcpCollateralInitialized) (event.Subscription, error) {

	logs, sub, err := _FcpCollateral.contract.WatchLogs(opts, "Initialized")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(FcpCollateralInitialized)
				if err := _FcpCollateral.contract.UnpackLog(event, "Initialized", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInitialized is a log parse operation binding the contract event 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498.
//
// Solidity: event Initialized(uint8 version)
func (_FcpCollateral *FcpCollateralFilterer) ParseInitialized(log types.Log) (*FcpCollateralInitialized, error) {
	event := new(FcpCollateralInitialized)
	if err := _FcpCollateral.contract.UnpackLog(event, "Initialized", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// FcpCollateralOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the FcpCollateral contract.
type FcpCollateralOwnershipTransferredIterator struct {
	Event *FcpCollateralOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *FcpCollateralOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(FcpCollateralOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(FcpCollateralOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *FcpCollateralOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *FcpCollateralOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// FcpCollateralOwnershipTransferred represents a OwnershipTransferred event raised by the FcpCollateral contract.
type FcpCollateralOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_FcpCollateral *FcpCollateralFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*FcpCollateralOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _FcpCollateral.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &FcpCollateralOwnershipTransferredIterator{contract: _FcpCollateral.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_FcpCollateral *FcpCollateralFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *FcpCollateralOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _FcpCollateral.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(FcpCollateralOwnershipTransferred)
				if err := _FcpCollateral.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_FcpCollateral *FcpCollateralFilterer) ParseOwnershipTransferred(log types.Log) (*FcpCollateralOwnershipTransferred, error) {
	event := new(FcpCollateralOwnershipTransferred)
	if err := _FcpCollateral.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// FcpCollateralTaskCreatedIterator is returned from FilterTaskCreated and is used to iterate over the raw logs and unpacked data for TaskCreated events raised by the FcpCollateral contract.
type FcpCollateralTaskCreatedIterator struct {
	Event *FcpCollateralTaskCreated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *FcpCollateralTaskCreatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(FcpCollateralTaskCreated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(FcpCollateralTaskCreated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *FcpCollateralTaskCreatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *FcpCollateralTaskCreatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// FcpCollateralTaskCreated represents a TaskCreated event raised by the FcpCollateral contract.
type FcpCollateralTaskCreated struct {
	TaskUid          common.Hash
	CpAccountAddress common.Address
	Collateral       *big.Int
	Raw              types.Log // Blockchain specific contextual infos
}

// FilterTaskCreated is a free log retrieval operation binding the contract event 0x5bebc56a5428fd7b8cf43ed525f03223f8363907fbe44665b7a3426d1de96800.
//
// Solidity: event TaskCreated(string indexed taskUid, address cpAccountAddress, uint256 collateral)
func (_FcpCollateral *FcpCollateralFilterer) FilterTaskCreated(opts *bind.FilterOpts, taskUid []string) (*FcpCollateralTaskCreatedIterator, error) {

	var taskUidRule []interface{}
	for _, taskUidItem := range taskUid {
		taskUidRule = append(taskUidRule, taskUidItem)
	}

	logs, sub, err := _FcpCollateral.contract.FilterLogs(opts, "TaskCreated", taskUidRule)
	if err != nil {
		return nil, err
	}
	return &FcpCollateralTaskCreatedIterator{contract: _FcpCollateral.contract, event: "TaskCreated", logs: logs, sub: sub}, nil
}

// WatchTaskCreated is a free log subscription operation binding the contract event 0x5bebc56a5428fd7b8cf43ed525f03223f8363907fbe44665b7a3426d1de96800.
//
// Solidity: event TaskCreated(string indexed taskUid, address cpAccountAddress, uint256 collateral)
func (_FcpCollateral *FcpCollateralFilterer) WatchTaskCreated(opts *bind.WatchOpts, sink chan<- *FcpCollateralTaskCreated, taskUid []string) (event.Subscription, error) {

	var taskUidRule []interface{}
	for _, taskUidItem := range taskUid {
		taskUidRule = append(taskUidRule, taskUidItem)
	}

	logs, sub, err := _FcpCollateral.contract.WatchLogs(opts, "TaskCreated", taskUidRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(FcpCollateralTaskCreated)
				if err := _FcpCollateral.contract.UnpackLog(event, "TaskCreated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTaskCreated is a log parse operation binding the contract event 0x5bebc56a5428fd7b8cf43ed525f03223f8363907fbe44665b7a3426d1de96800.
//
// Solidity: event TaskCreated(string indexed taskUid, address cpAccountAddress, uint256 collateral)
func (_FcpCollateral *FcpCollateralFilterer) ParseTaskCreated(log types.Log) (*FcpCollateralTaskCreated, error) {
	event := new(FcpCollateralTaskCreated)
	if err := _FcpCollateral.contract.UnpackLog(event, "TaskCreated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// FcpCollateralUpgradedIterator is returned from FilterUpgraded and is used to iterate over the raw logs and unpacked data for Upgraded events raised by the FcpCollateral contract.
type FcpCollateralUpgradedIterator struct {
	Event *FcpCollateralUpgraded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *FcpCollateralUpgradedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(FcpCollateralUpgraded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(FcpCollateralUpgraded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *FcpCollateralUpgradedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *FcpCollateralUpgradedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// FcpCollateralUpgraded represents a Upgraded event raised by the FcpCollateral contract.
type FcpCollateralUpgraded struct {
	Implementation common.Address
	Raw            types.Log // Blockchain specific contextual infos
}

// FilterUpgraded is a free log retrieval operation binding the contract event 0xbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b.
//
// Solidity: event Upgraded(address indexed implementation)
func (_FcpCollateral *FcpCollateralFilterer) FilterUpgraded(opts *bind.FilterOpts, implementation []common.Address) (*FcpCollateralUpgradedIterator, error) {

	var implementationRule []interface{}
	for _, implementationItem := range implementation {
		implementationRule = append(implementationRule, implementationItem)
	}

	logs, sub, err := _FcpCollateral.contract.FilterLogs(opts, "Upgraded", implementationRule)
	if err != nil {
		return nil, err
	}
	return &FcpCollateralUpgradedIterator{contract: _FcpCollateral.contract, event: "Upgraded", logs: logs, sub: sub}, nil
}

// WatchUpgraded is a free log subscription operation binding the contract event 0xbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b.
//
// Solidity: event Upgraded(address indexed implementation)
func (_FcpCollateral *FcpCollateralFilterer) WatchUpgraded(opts *bind.WatchOpts, sink chan<- *FcpCollateralUpgraded, implementation []common.Address) (event.Subscription, error) {

	var implementationRule []interface{}
	for _, implementationItem := range implementation {
		implementationRule = append(implementationRule, implementationItem)
	}

	logs, sub, err := _FcpCollateral.contract.WatchLogs(opts, "Upgraded", implementationRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(FcpCollateralUpgraded)
				if err := _FcpCollateral.contract.UnpackLog(event, "Upgraded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUpgraded is a log parse operation binding the contract event 0xbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b.
//
// Solidity: event Upgraded(address indexed implementation)
func (_FcpCollateral *FcpCollateralFilterer) ParseUpgraded(log types.Log) (*FcpCollateralUpgraded, error) {
	event := new(FcpCollateralUpgraded)
	if err := _FcpCollateral.contract.UnpackLog(event, "Upgraded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// FcpCollateralWithdrawIterator is returned from FilterWithdraw and is used to iterate over the raw logs and unpacked data for Withdraw events raised by the FcpCollateral contract.
type FcpCollateralWithdrawIterator struct {
	Event *FcpCollateralWithdraw // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *FcpCollateralWithdrawIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(FcpCollateralWithdraw)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(FcpCollateralWithdraw)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *FcpCollateralWithdrawIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *FcpCollateralWithdrawIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// FcpCollateralWithdraw represents a Withdraw event raised by the FcpCollateral contract.
type FcpCollateralWithdraw struct {
	CpOwner        common.Address
	CpAccount      common.Address
	WithdrawAmount *big.Int
	Raw            types.Log // Blockchain specific contextual infos
}

// FilterWithdraw is a free log retrieval operation binding the contract event 0x9b1bfa7fa9ee420a16e124f794c35ac9f90472acc99140eb2f6447c714cad8eb.
//
// Solidity: event Withdraw(address indexed cpOwner, address indexed cpAccount, uint256 withdrawAmount)
func (_FcpCollateral *FcpCollateralFilterer) FilterWithdraw(opts *bind.FilterOpts, cpOwner []common.Address, cpAccount []common.Address) (*FcpCollateralWithdrawIterator, error) {

	var cpOwnerRule []interface{}
	for _, cpOwnerItem := range cpOwner {
		cpOwnerRule = append(cpOwnerRule, cpOwnerItem)
	}
	var cpAccountRule []interface{}
	for _, cpAccountItem := range cpAccount {
		cpAccountRule = append(cpAccountRule, cpAccountItem)
	}

	logs, sub, err := _FcpCollateral.contract.FilterLogs(opts, "Withdraw", cpOwnerRule, cpAccountRule)
	if err != nil {
		return nil, err
	}
	return &FcpCollateralWithdrawIterator{contract: _FcpCollateral.contract, event: "Withdraw", logs: logs, sub: sub}, nil
}

// WatchWithdraw is a free log subscription operation binding the contract event 0x9b1bfa7fa9ee420a16e124f794c35ac9f90472acc99140eb2f6447c714cad8eb.
//
// Solidity: event Withdraw(address indexed cpOwner, address indexed cpAccount, uint256 withdrawAmount)
func (_FcpCollateral *FcpCollateralFilterer) WatchWithdraw(opts *bind.WatchOpts, sink chan<- *FcpCollateralWithdraw, cpOwner []common.Address, cpAccount []common.Address) (event.Subscription, error) {

	var cpOwnerRule []interface{}
	for _, cpOwnerItem := range cpOwner {
		cpOwnerRule = append(cpOwnerRule, cpOwnerItem)
	}
	var cpAccountRule []interface{}
	for _, cpAccountItem := range cpAccount {
		cpAccountRule = append(cpAccountRule, cpAccountItem)
	}

	logs, sub, err := _FcpCollateral.contract.WatchLogs(opts, "Withdraw", cpOwnerRule, cpAccountRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(FcpCollateralWithdraw)
				if err := _FcpCollateral.contract.UnpackLog(event, "Withdraw", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseWithdraw is a log parse operation binding the contract event 0x9b1bfa7fa9ee420a16e124f794c35ac9f90472acc99140eb2f6447c714cad8eb.
//
// Solidity: event Withdraw(address indexed cpOwner, address indexed cpAccount, uint256 withdrawAmount)
func (_FcpCollateral *FcpCollateralFilterer) ParseWithdraw(log types.Log) (*FcpCollateralWithdraw, error) {
	event := new(FcpCollateralWithdraw)
	if err := _FcpCollateral.contract.UnpackLog(event, "Withdraw", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// FcpCollateralWithdrawSlashIterator is returned from FilterWithdrawSlash and is used to iterate over the raw logs and unpacked data for WithdrawSlash events raised by the FcpCollateral contract.
type FcpCollateralWithdrawSlashIterator struct {
	Event *FcpCollateralWithdrawSlash // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *FcpCollateralWithdrawSlashIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(FcpCollateralWithdrawSlash)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(FcpCollateralWithdrawSlash)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *FcpCollateralWithdrawSlashIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *FcpCollateralWithdrawSlashIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// FcpCollateralWithdrawSlash represents a WithdrawSlash event raised by the FcpCollateral contract.
type FcpCollateralWithdrawSlash struct {
	CollateralContratOwner common.Address
	Slashfund              *big.Int
	Raw                    types.Log // Blockchain specific contextual infos
}

// FilterWithdrawSlash is a free log retrieval operation binding the contract event 0xbfd9c82485e2178fcfd5c40379d8e66fe60acc50aa1ef4c50966431eb1e381cd.
//
// Solidity: event WithdrawSlash(address indexed collateralContratOwner, uint256 slashfund)
func (_FcpCollateral *FcpCollateralFilterer) FilterWithdrawSlash(opts *bind.FilterOpts, collateralContratOwner []common.Address) (*FcpCollateralWithdrawSlashIterator, error) {

	var collateralContratOwnerRule []interface{}
	for _, collateralContratOwnerItem := range collateralContratOwner {
		collateralContratOwnerRule = append(collateralContratOwnerRule, collateralContratOwnerItem)
	}

	logs, sub, err := _FcpCollateral.contract.FilterLogs(opts, "WithdrawSlash", collateralContratOwnerRule)
	if err != nil {
		return nil, err
	}
	return &FcpCollateralWithdrawSlashIterator{contract: _FcpCollateral.contract, event: "WithdrawSlash", logs: logs, sub: sub}, nil
}

// WatchWithdrawSlash is a free log subscription operation binding the contract event 0xbfd9c82485e2178fcfd5c40379d8e66fe60acc50aa1ef4c50966431eb1e381cd.
//
// Solidity: event WithdrawSlash(address indexed collateralContratOwner, uint256 slashfund)
func (_FcpCollateral *FcpCollateralFilterer) WatchWithdrawSlash(opts *bind.WatchOpts, sink chan<- *FcpCollateralWithdrawSlash, collateralContratOwner []common.Address) (event.Subscription, error) {

	var collateralContratOwnerRule []interface{}
	for _, collateralContratOwnerItem := range collateralContratOwner {
		collateralContratOwnerRule = append(collateralContratOwnerRule, collateralContratOwnerItem)
	}

	logs, sub, err := _FcpCollateral.contract.WatchLogs(opts, "WithdrawSlash", collateralContratOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(FcpCollateralWithdrawSlash)
				if err := _FcpCollateral.contract.UnpackLog(event, "WithdrawSlash", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseWithdrawSlash is a log parse operation binding the contract event 0xbfd9c82485e2178fcfd5c40379d8e66fe60acc50aa1ef4c50966431eb1e381cd.
//
// Solidity: event WithdrawSlash(address indexed collateralContratOwner, uint256 slashfund)
func (_FcpCollateral *FcpCollateralFilterer) ParseWithdrawSlash(log types.Log) (*FcpCollateralWithdrawSlash, error) {
	event := new(FcpCollateralWithdrawSlash)
	if err := _FcpCollateral.contract.UnpackLog(event, "WithdrawSlash", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}
