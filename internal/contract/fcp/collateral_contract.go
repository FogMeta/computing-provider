// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package fcp

import (
	"errors"
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
	_ = abi.ConvertType
)

// CollateralV2CPInfo is an auto generated low-level Go binding around an user-defined struct.
type CollateralV2CPInfo struct {
	CpAccount        common.Address
	AvailableBalance *big.Int
	LockedCollateral *big.Int
	Status           string
}

// CollateralV2ContractInfo is an auto generated low-level Go binding around an user-defined struct.
type CollateralV2ContractInfo struct {
	SlashedFunds    *big.Int
	BaseCollateral  *big.Int
	CollateralRatio *big.Int
	SlashRatio      *big.Int
}

// CollateralV2Task is an auto generated low-level Go binding around an user-defined struct.
type CollateralV2Task struct {
	CpList           []common.Address
	Collateral       *big.Int
	CollateralStatus uint8
}

// CollateralMetaData contains all meta data concerning the Collateral contract.
var CollateralMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"}],\"name\":\"BeaconUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"cp\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"frozenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balanceAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"operation\",\"type\":\"string\"}],\"name\":\"CollateralAdjusted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"cp\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"taskUid\",\"type\":\"string\"}],\"name\":\"CollateralLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"cp\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"taskUid\",\"type\":\"string\"}],\"name\":\"CollateralSlashed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"string\",\"name\":\"taskUid\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"enumCollateralV2.CollateralStatus\",\"name\":\"newStatus\",\"type\":\"uint8\"}],\"name\":\"CollateralStatusChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"cp\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"taskUid\",\"type\":\"string\"}],\"name\":\"CollateralUnlocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fundingWallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"cpAccount\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"challenger\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"taskUid\",\"type\":\"string\"}],\"name\":\"DisputeProof\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"string\",\"name\":\"taskUid\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"cpAccountAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"}],\"name\":\"TaskCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"cpOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"cpAccount\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collateralContratOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"slashfund\",\"type\":\"uint256\"}],\"name\":\"WithdrawSlash\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"availableBalance\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collateralInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"slashedFunds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slashRatio\",\"type\":\"uint256\"}],\"internalType\":\"structCollateralV2.ContractInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collateralRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cpAddress\",\"type\":\"address\"}],\"name\":\"cpInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"cpAccount\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"availableBalance\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"lockedCollateral\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"status\",\"type\":\"string\"}],\"internalType\":\"structCollateralV2.CPInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"cpStatus\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cpAccount\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"taskUid\",\"type\":\"string\"}],\"name\":\"disputeProof\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"taskUid\",\"type\":\"string\"}],\"name\":\"getTaskInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address[]\",\"name\":\"cpList\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"},{\"internalType\":\"enumCollateralV2.CollateralStatus\",\"name\":\"collateralStatus\",\"type\":\"uint8\"}],\"internalType\":\"structCollateralV2.Task\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"taskUid\",\"type\":\"string\"},{\"internalType\":\"address[]\",\"name\":\"cpList\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"taskCollateral\",\"type\":\"uint256\"}],\"name\":\"lockCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"taskUid\",\"type\":\"string\"},{\"internalType\":\"address[]\",\"name\":\"cpList\",\"type\":\"address[]\"}],\"name\":\"lockCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lockedCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxiableUUID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"removeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_baseCollateral\",\"type\":\"uint256\"}],\"name\":\"setBaseCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_slashRatio\",\"type\":\"uint256\"}],\"name\":\"setSlashRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"taskUid\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"cpAccount\",\"type\":\"address\"}],\"name\":\"slashCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"slashRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"slashedFunds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"tasks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"},{\"internalType\":\"enumCollateralV2.CollateralStatus\",\"name\":\"collateralStatus\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"taskUid\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unlockCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cpAccount\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawSlashedFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]",
	Bin: "0x60a06040523073ffffffffffffffffffffffffffffffffffffffff1660809073ffffffffffffffffffffffffffffffffffffffff168152503480156200004457600080fd5b50620000556200005b60201b60201c565b62000205565b600060019054906101000a900460ff1615620000ae576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401620000a590620001a8565b60405180910390fd5b60ff801660008054906101000a900460ff1660ff16146200011f5760ff6000806101000a81548160ff021916908360ff1602179055507f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb384740249860ff604051620001169190620001e8565b60405180910390a15b565b600082825260208201905092915050565b7f496e697469616c697a61626c653a20636f6e747261637420697320696e69746960008201527f616c697a696e6700000000000000000000000000000000000000000000000000602082015250565b60006200019060278362000121565b91506200019d8262000132565b604082019050919050565b60006020820190508181036000830152620001c38162000181565b9050919050565b600060ff82169050919050565b620001e281620001ca565b82525050565b6000602082019050620001ff6000830184620001d7565b92915050565b608051614a9f6200023d60003960008181610ad001528181610b5e0152818161108a0152818161111801526111c80152614a9f6000f3fe6080604052600436106101e75760003560e01c80638129fc1c11610102578063ce3518aa11610095578063e80d9dec11610064578063e80d9dec146106e4578063f2fde38b1461070d578063f340fa0114610736578063f3fef3a314610752576101f7565b8063ce3518aa1461063e578063d27ca89b14610667578063d4cd925c14610692578063dd98fff5146106bb576101f7565b80639b5ddf09116100d15780639b5ddf091461056e578063a0821be314610599578063a664c216146105d6578063b4eae1cb14610613576101f7565b80638129fc1c146104c6578063853911b2146104dd5780638da5cb5b1461050657806392bdf9ba14610531576101f7565b806352d1902d1161017a5780636f99f15c116101495780636f99f15c14610432578063704802751461045d578063715018a6146104865780637f58a7e51461049d576101f7565b806352d1902d1461037357806353ad87201461039e57806354fd4d50146103c957806358709cf2146103f4576101f7565b80633659cfe6116101b65780633659cfe6146102c85780633fe65177146102f15780634b9f0bea1461032e5780634f1ef28614610357576101f7565b80631785f53c146101fc5780631b2094631461022557806324d7806c146102625780632894493f1461029f576101f7565b366101f7576101f53361077b565b005b600080fd5b34801561020857600080fd5b50610223600480360381019061021e9190612faf565b610842565b005b34801561023157600080fd5b5061024c60048036038101906102479190613122565b6108a5565b6040516102599190613309565b60405180910390f35b34801561026e57600080fd5b5061028960048036038101906102849190612faf565b6109b0565b6040516102969190613346565b60405180910390f35b3480156102ab57600080fd5b506102c660048036038101906102c1919061338d565b6109d0565b005b3480156102d457600080fd5b506102ef60048036038101906102ea9190612faf565b610ace565b005b3480156102fd57600080fd5b5061031860048036038101906103139190612faf565b610c56565b6040516103259190613439565b60405180910390f35b34801561033a57600080fd5b506103556004803603810190610350919061345b565b610cf6565b005b610371600480360381019061036c9190613558565b611088565b005b34801561037f57600080fd5b506103886111c4565b60405161039591906135cd565b60405180910390f35b3480156103aa57600080fd5b506103b361127d565b6040516103c0919061363d565b60405180910390f35b3480156103d557600080fd5b506103de6112b3565b6040516103eb9190613667565b60405180910390f35b34801561040057600080fd5b5061041b60048036038101906104169190613122565b6112bc565b604051610429929190613691565b60405180910390f35b34801561043e57600080fd5b50610447611303565b6040516104549190613667565b60405180910390f35b34801561046957600080fd5b50610484600480360381019061047f9190612faf565b611309565b005b34801561049257600080fd5b5061049b61136c565b005b3480156104a957600080fd5b506104c460048036038101906104bf919061338d565b611380565b005b3480156104d257600080fd5b506104db611416565b005b3480156104e957600080fd5b5061050460048036038101906104ff9190613782565b6115d3565b005b34801561051257600080fd5b5061051b611953565b604051610528919061381c565b60405180910390f35b34801561053d57600080fd5b5061055860048036038101906105539190612faf565b61197d565b6040516105659190613667565b60405180910390f35b34801561057a57600080fd5b50610583611995565b6040516105909190613667565b60405180910390f35b3480156105a557600080fd5b506105c060048036038101906105bb9190612faf565b61199b565b6040516105cd9190613850565b60405180910390f35b3480156105e257600080fd5b506105fd60048036038101906105f89190612faf565b6119b3565b60405161060a9190613927565b60405180910390f35b34801561061f57600080fd5b50610628611b3e565b6040516106359190613667565b60405180910390f35b34801561064a57600080fd5b506106656004803603810190610660919061338d565b611b44565b005b34801561067357600080fd5b5061067c611b56565b6040516106899190613667565b60405180910390f35b34801561069e57600080fd5b506106b960048036038101906106b49190613949565b611b5c565b005b3480156106c757600080fd5b506106e260048036038101906106dd91906139c1565b611ef0565b005b3480156106f057600080fd5b5061070b60048036038101906107069190613122565b612245565b005b34801561071957600080fd5b50610734600480360381019061072f9190612faf565b6122a1565b005b610750600480360381019061074b9190612faf565b61077b565b005b34801561075e57600080fd5b5061077960048036038101906107749190613a1d565b612324565b005b3460cf60008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546107ca9190613a8c565b925050819055508073ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f5548c837ab068cf56a2c2479df0882a4922fd203edb7517321831d95078c5f623460405161082e9190613667565b60405180910390a361083f81612591565b50565b61084a6126f3565b600060cd60008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff02191690831515021790555050565b6108ad612dfd565b60ce826040516108bd9190613b0c565b90815260200160405180910390206040518060600160405290816000820180548060200260200160405190810160405280929190818152602001828054801561095b57602002820191906000526020600020905b8160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019060010190808311610911575b50505050508152602001600182015481526020016002820160009054906101000a900460ff16600281111561099357610992613242565b5b60028111156109a5576109a4613242565b5b815250509050919050565b60cd6020528060005260406000206000915054906101000a900460ff1681565b6109d86126f3565b8060c9541015610a1d576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610a1490613b95565b60405180910390fd5b8060c96000828254610a2f9190613bb5565b925050819055503373ffffffffffffffffffffffffffffffffffffffff166108fc829081150290604051600060405180830381858888f19350505050158015610a7c573d6000803e3d6000fd5b503373ffffffffffffffffffffffffffffffffffffffff167fbfd9c82485e2178fcfd5c40379d8e66fe60acc50aa1ef4c50966431eb1e381cd82604051610ac39190613667565b60405180910390a250565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff1603610b5c576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610b5390613c5b565b60405180910390fd5b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16610b9b612771565b73ffffffffffffffffffffffffffffffffffffffff1614610bf1576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610be890613ced565b60405180910390fd5b610bfa816127c8565b610c5381600067ffffffffffffffff811115610c1957610c18612ff7565b5b6040519080825280601f01601f191660200182016040528015610c4b5781602001600182028036833780820191505090505b5060006127d3565b50565b60d16020528060005260406000206000915090508054610c7590613d3c565b80601f0160208091040260200160405190810160405280929190818152602001828054610ca190613d3c565b8015610cee5780601f10610cc357610100808354040283529160200191610cee565b820191906000526020600020905b815481529060010190602001808311610cd157829003601f168201915b505050505081565b60cd60003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff16610d82576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610d7990613ddf565b60405180910390fd5b600060ce83604051610d949190613b0c565b908152602001604051809103902090506000816001015490506000818411610dbc5783610dbe565b815b905080836001016000828254610dd49190613bb5565b9250508190555060005b8360000180549050811015611005578160d06000866000018481548110610e0857610e07613dff565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254610e7c9190613bb5565b925050819055508160cf6000866000018481548110610e9e57610e9d613dff565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254610f129190613a8c565b92505081905550836000018181548110610f2f57610f2e613dff565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff167f0f2440b3ca071b7d18e917a25289e7d7e7de8a491546d45acc2efbec7b3e1ae88388604051610fa1929190613e2e565b60405180910390a2610ff2846000018281548110610fc257610fc1613dff565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16612591565b8080610ffd90613e5e565b915050610dde565b5060018360020160006101000a81548160ff0219169083600281111561102e5761102d613242565b5b0217905550846040516110419190613b0c565b60405180910390207f4a2ced9ada462e244851a86e998eb0b5bf558c2c9c6923b7f970ed2b19b073b060016040516110799190613ea6565b60405180910390a25050505050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff1603611116576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161110d90613c5b565b60405180910390fd5b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16611155612771565b73ffffffffffffffffffffffffffffffffffffffff16146111ab576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016111a290613ced565b60405180910390fd5b6111b4826127c8565b6111c0828260016127d3565b5050565b60007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff1614611254576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161124b90613f33565b60405180910390fd5b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc60001b905090565b611285612e30565b604051806080016040528060c954815260200160ca54815260200160cb54815260200160cc54815250905090565b60006002905090565b60ce818051602081018201805184825260208301602085012081835280955050505050506000915090508060010154908060020160009054906101000a900460ff16905082565b60c95481565b6113116126f3565b600160cd60008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff02191690831515021790555050565b6113746126f3565b61137e6000612941565b565b60cd60003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff1661140c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161140390613ddf565b60405180910390fd5b8060ca8190555050565b60008060019054906101000a900460ff161590508080156114475750600160008054906101000a900460ff1660ff16105b80611474575061145630612a07565b1580156114735750600160008054906101000a900460ff1660ff16145b5b6114b3576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016114aa90613fc5565b60405180910390fd5b60016000806101000a81548160ff021916908360ff16021790555080156114f0576001600060016101000a81548160ff0219169083151502179055505b6114f8612a2a565b611500612a83565b600160cd60003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff021916908315150217905550600160cb81905550600160cc8190555067016345785d8a000060ca8190555080156115d05760008060016101000a81548160ff0219169083151502179055507f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb384740249860016040516115c79190614037565b60405180910390a15b50565b60cd60003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff1661165f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161165690613ddf565b60405180910390fd5b60005b825181101561171a578160cf600085848151811061168357611682613dff565b5b602002602001015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541215611707576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016116fe906140c4565b60405180910390fd5b808061171290613e5e565b915050611662565b5060005b82518110156118a7578160cf600085848151811061173f5761173e613dff565b5b602002602001015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825461179091906140e4565b925050819055508160d060008584815181106117af576117ae613dff565b5b602002602001015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546118009190614127565b9250508190555082818151811061181a57611819613dff565b5b602002602001015173ffffffffffffffffffffffffffffffffffffffff167f5f3d004cf9164b95ed5dbf47d1f04018a4eabcb20b4320fe229ed92236ace6348386604051611869929190613e2e565b60405180910390a261189483828151811061188757611886613dff565b5b6020026020010151612591565b808061189f90613e5e565b91505061171e565b506040518060600160405280838152602001828152602001600060028111156118d3576118d2613242565b5b81525060ce846040516118e69190613b0c565b90815260200160405180910390206000820151816000019080519060200190611910929190612e58565b506020820151816001015560408201518160020160006101000a81548160ff0219169083600281111561194657611945613242565b5b0217905550905050505050565b6000603360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b60d06020528060005260406000206000915090505481565b60ca5481565b60cf6020528060005260406000206000915090505481565b6119bb612ee2565b60405180608001604052808373ffffffffffffffffffffffffffffffffffffffff16815260200160cf60008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054815260200160d060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054815260200160d160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208054611ab690613d3c565b80601f0160208091040260200160405190810160405280929190818152602001828054611ae290613d3c565b8015611b2f5780601f10611b0457610100808354040283529160200191611b2f565b820191906000526020600020905b815481529060010190602001808311611b1257829003601f168201915b50505050508152509050919050565b60cb5481565b611b4c6126f3565b8060cc8190555050565b60cc5481565b60cd60003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff16611be8576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611bdf90613ddf565b60405180910390fd5b600060ca5460cb54611bfa919061415b565b905060005b8251811015611cb7578160cf6000858481518110611c2057611c1f613dff565b5b602002602001015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541215611ca4576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611c9b906140c4565b60405180910390fd5b8080611caf90613e5e565b915050611bff565b5060005b8251811015611e44578160cf6000858481518110611cdc57611cdb613dff565b5b602002602001015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254611d2d91906140e4565b925050819055508160d06000858481518110611d4c57611d4b613dff565b5b602002602001015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254611d9d9190614127565b92505081905550828181518110611db757611db6613dff565b5b602002602001015173ffffffffffffffffffffffffffffffffffffffff167f5f3d004cf9164b95ed5dbf47d1f04018a4eabcb20b4320fe229ed92236ace6348386604051611e06929190613e2e565b60405180910390a2611e31838281518110611e2457611e23613dff565b5b6020026020010151612591565b8080611e3c90613e5e565b915050611cbb565b50604051806060016040528083815260200182815260200160006002811115611e7057611e6f613242565b5b81525060ce84604051611e839190613b0c565b90815260200160405180910390206000820151816000019080519060200190611ead929190612e58565b506020820151816001015560408201518160020160006101000a81548160ff02191690836002811115611ee357611ee2613242565b5b0217905550905050505050565b60cd60003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff16611f7c576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611f7390613ddf565b60405180910390fd5b600060ce83604051611f8e9190613b0c565b90815260200160405180910390209050600060cc5460ca54611fb0919061415b565b9050600060d060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054905060008183116120055782612007565b815b90506000818411612019576000612026565b81846120259190613bb5565b5b90508160d060008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546120779190613bb5565b925050819055508060cf60008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546120cd91906140e4565b925050819055508360c960008282546120e69190614127565b9250508190555060028560020160006101000a81548160ff0219169083600281111561211557612114613242565b5b02179055508385600101541161212c57600061213d565b83856001015461213c9190613bb5565b5b856001018190555061214e86612591565b8573ffffffffffffffffffffffffffffffffffffffff167f403feb2cd85cc25c910fe59289105b583f08fe9e4335ebbb08c1851f47ff2d348589604051612196929190613e2e565b60405180910390a2866040516121ac9190613b0c565b60405180910390207f4a2ced9ada462e244851a86e998eb0b5bf558c2c9c6923b7f970ed2b19b073b060026040516121e49190613ea6565b60405180910390a28573ffffffffffffffffffffffffffffffffffffffff167f42f1a8a1aee108e84e4eabfaa8d51d7baaa1a02d482295297883a44b2debd3e483836040516122349291906141e9565b60405180910390a250505050505050565b806040516122539190613b0c565b60405180910390203373ffffffffffffffffffffffffffffffffffffffff167faec1d412a3c1e4a13fc2a2e19ac38a5af192a9cf17b074fca8146a2d0655e0c360405160405180910390a350565b6122a96126f3565b600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603612318576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161230f90614297565b60405180910390fd5b61232181612941565b50565b3373ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff1663893d20e86040518163ffffffff1660e01b8152600401602060405180830381865afa158015612386573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906123aa91906142cc565b73ffffffffffffffffffffffffffffffffffffffff1614612400576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016123f79061436b565b60405180910390fd5b8060cf60008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541215612482576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401612479906143d7565b60405180910390fd5b8060cf60008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546124d191906140e4565b925050819055503373ffffffffffffffffffffffffffffffffffffffff166108fc829081150290604051600060405180830381858888f1935050505015801561251e573d6000803e3d6000fd5b5061252882612591565b8173ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f9b1bfa7fa9ee420a16e124f794c35ac9f90472acc99140eb2f6447c714cad8eb836040516125859190613667565b60405180910390a35050565b60ca5460cb546125a1919061415b565b60cf60008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541261266d576040518060400160405280600981526020017f7a6b41756374696f6e000000000000000000000000000000000000000000000081525060d160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090816126679190614599565b506126f0565b6040518060400160405280600381526020017f4e5343000000000000000000000000000000000000000000000000000000000081525060d160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090816126ee9190614599565b505b50565b6126fb612ad4565b73ffffffffffffffffffffffffffffffffffffffff16612719611953565b73ffffffffffffffffffffffffffffffffffffffff161461276f576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401612766906146b7565b60405180910390fd5b565b600061279f7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc60001b612adc565b60000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b6127d06126f3565b50565b6127ff7f4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd914360001b612ae6565b60000160009054906101000a900460ff16156128235761281e83612af0565b61293c565b8273ffffffffffffffffffffffffffffffffffffffff166352d1902d6040518163ffffffff1660e01b8152600401602060405180830381865afa92505050801561288b57506040513d601f19601f820116820180604052508101906128889190614703565b60015b6128ca576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016128c1906147a2565b60405180910390fd5b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc60001b811461292f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161292690614834565b60405180910390fd5b5061293b838383612ba9565b5b505050565b6000603360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905081603360006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b6000808273ffffffffffffffffffffffffffffffffffffffff163b119050919050565b600060019054906101000a900460ff16612a79576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401612a70906148c6565b60405180910390fd5b612a81612bd5565b565b600060019054906101000a900460ff16612ad2576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401612ac9906148c6565b60405180910390fd5b565b600033905090565b6000819050919050565b6000819050919050565b612af981612a07565b612b38576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401612b2f90614958565b60405180910390fd5b80612b657f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc60001b612adc565b60000160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b612bb283612c36565b600082511180612bbf5750805b15612bd057612bce8383612c85565b505b505050565b600060019054906101000a900460ff16612c24576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401612c1b906148c6565b60405180910390fd5b612c34612c2f612ad4565b612941565b565b612c3f81612af0565b8073ffffffffffffffffffffffffffffffffffffffff167fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b60405160405180910390a250565b6060612caa8383604051806060016040528060278152602001614a4360279139612cb2565b905092915050565b60606000808573ffffffffffffffffffffffffffffffffffffffff1685604051612cdc91906149bf565b600060405180830381855af49150503d8060008114612d17576040519150601f19603f3d011682016040523d82523d6000602084013e612d1c565b606091505b5091509150612d2d86838387612d38565b925050509392505050565b60608315612d9a576000835103612d9257612d5285612a07565b612d91576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401612d8890614a22565b60405180910390fd5b5b829050612da5565b612da48383612dad565b5b949350505050565b600082511115612dc05781518083602001fd5b806040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401612df49190613439565b60405180910390fd5b6040518060600160405280606081526020016000815260200160006002811115612e2a57612e29613242565b5b81525090565b6040518060800160405280600081526020016000815260200160008152602001600081525090565b828054828255906000526020600020908101928215612ed1579160200282015b82811115612ed05782518260006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555091602001919060010190612e78565b5b509050612ede9190612f20565b5090565b6040518060800160405280600073ffffffffffffffffffffffffffffffffffffffff1681526020016000815260200160008152602001606081525090565b5b80821115612f39576000816000905550600101612f21565b5090565b6000604051905090565b600080fd5b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000612f7c82612f51565b9050919050565b612f8c81612f71565b8114612f9757600080fd5b50565b600081359050612fa981612f83565b92915050565b600060208284031215612fc557612fc4612f47565b5b6000612fd384828501612f9a565b91505092915050565b600080fd5b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b61302f82612fe6565b810181811067ffffffffffffffff8211171561304e5761304d612ff7565b5b80604052505050565b6000613061612f3d565b905061306d8282613026565b919050565b600067ffffffffffffffff82111561308d5761308c612ff7565b5b61309682612fe6565b9050602081019050919050565b82818337600083830152505050565b60006130c56130c084613072565b613057565b9050828152602081018484840111156130e1576130e0612fe1565b5b6130ec8482856130a3565b509392505050565b600082601f83011261310957613108612fdc565b5b81356131198482602086016130b2565b91505092915050565b60006020828403121561313857613137612f47565b5b600082013567ffffffffffffffff81111561315657613155612f4c565b5b613162848285016130f4565b91505092915050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b6131a081612f71565b82525050565b60006131b28383613197565b60208301905092915050565b6000602082019050919050565b60006131d68261316b565b6131e08185613176565b93506131eb83613187565b8060005b8381101561321c57815161320388826131a6565b975061320e836131be565b9250506001810190506131ef565b5085935050505092915050565b6000819050919050565b61323c81613229565b82525050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b6003811061328257613281613242565b5b50565b600081905061329382613271565b919050565b60006132a382613285565b9050919050565b6132b381613298565b82525050565b600060608301600083015184820360008601526132d682826131cb565b91505060208301516132eb6020860182613233565b5060408301516132fe60408601826132aa565b508091505092915050565b6000602082019050818103600083015261332381846132b9565b905092915050565b60008115159050919050565b6133408161332b565b82525050565b600060208201905061335b6000830184613337565b92915050565b61336a81613229565b811461337557600080fd5b50565b60008135905061338781613361565b92915050565b6000602082840312156133a3576133a2612f47565b5b60006133b184828501613378565b91505092915050565b600081519050919050565b600082825260208201905092915050565b60005b838110156133f45780820151818401526020810190506133d9565b60008484015250505050565b600061340b826133ba565b61341581856133c5565b93506134258185602086016133d6565b61342e81612fe6565b840191505092915050565b600060208201905081810360008301526134538184613400565b905092915050565b6000806040838503121561347257613471612f47565b5b600083013567ffffffffffffffff8111156134905761348f612f4c565b5b61349c858286016130f4565b92505060206134ad85828601613378565b9150509250929050565b600067ffffffffffffffff8211156134d2576134d1612ff7565b5b6134db82612fe6565b9050602081019050919050565b60006134fb6134f6846134b7565b613057565b90508281526020810184848401111561351757613516612fe1565b5b6135228482856130a3565b509392505050565b600082601f83011261353f5761353e612fdc565b5b813561354f8482602086016134e8565b91505092915050565b6000806040838503121561356f5761356e612f47565b5b600061357d85828601612f9a565b925050602083013567ffffffffffffffff81111561359e5761359d612f4c565b5b6135aa8582860161352a565b9150509250929050565b6000819050919050565b6135c7816135b4565b82525050565b60006020820190506135e260008301846135be565b92915050565b6080820160008201516135fe6000850182613233565b5060208201516136116020850182613233565b5060408201516136246040850182613233565b5060608201516136376060850182613233565b50505050565b600060808201905061365260008301846135e8565b92915050565b61366181613229565b82525050565b600060208201905061367c6000830184613658565b92915050565b61368b81613298565b82525050565b60006040820190506136a66000830185613658565b6136b36020830184613682565b9392505050565b600067ffffffffffffffff8211156136d5576136d4612ff7565b5b602082029050602081019050919050565b600080fd5b60006136fe6136f9846136ba565b613057565b90508083825260208201905060208402830185811115613721576137206136e6565b5b835b8181101561374a57806137368882612f9a565b845260208401935050602081019050613723565b5050509392505050565b600082601f83011261376957613768612fdc565b5b81356137798482602086016136eb565b91505092915050565b60008060006060848603121561379b5761379a612f47565b5b600084013567ffffffffffffffff8111156137b9576137b8612f4c565b5b6137c5868287016130f4565b935050602084013567ffffffffffffffff8111156137e6576137e5612f4c565b5b6137f286828701613754565b925050604061380386828701613378565b9150509250925092565b61381681612f71565b82525050565b6000602082019050613831600083018461380d565b92915050565b6000819050919050565b61384a81613837565b82525050565b60006020820190506138656000830184613841565b92915050565b61387481613837565b82525050565b600082825260208201905092915050565b6000613896826133ba565b6138a0818561387a565b93506138b08185602086016133d6565b6138b981612fe6565b840191505092915050565b60006080830160008301516138dc6000860182613197565b5060208301516138ef602086018261386b565b5060408301516139026040860182613233565b506060830151848203606086015261391a828261388b565b9150508091505092915050565b6000602082019050818103600083015261394181846138c4565b905092915050565b600080604083850312156139605761395f612f47565b5b600083013567ffffffffffffffff81111561397e5761397d612f4c565b5b61398a858286016130f4565b925050602083013567ffffffffffffffff8111156139ab576139aa612f4c565b5b6139b785828601613754565b9150509250929050565b600080604083850312156139d8576139d7612f47565b5b600083013567ffffffffffffffff8111156139f6576139f5612f4c565b5b613a02858286016130f4565b9250506020613a1385828601612f9a565b9150509250929050565b60008060408385031215613a3457613a33612f47565b5b6000613a4285828601612f9a565b9250506020613a5385828601613378565b9150509250929050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000613a9782613837565b9150613aa283613837565b925082820190508281121560008312168382126000841215161715613aca57613ac9613a5d565b5b92915050565b600081905092915050565b6000613ae6826133ba565b613af08185613ad0565b9350613b008185602086016133d6565b80840191505092915050565b6000613b188284613adb565b915081905092915050565b7f576974686472617720616d6f756e7420616d6f756e742065786365656473207360008201527f6c617368656446756e6473000000000000000000000000000000000000000000602082015250565b6000613b7f602b836133c5565b9150613b8a82613b23565b604082019050919050565b60006020820190508181036000830152613bae81613b72565b9050919050565b6000613bc082613229565b9150613bcb83613229565b9250828203905081811115613be357613be2613a5d565b5b92915050565b7f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060008201527f64656c656761746563616c6c0000000000000000000000000000000000000000602082015250565b6000613c45602c836133c5565b9150613c5082613be9565b604082019050919050565b60006020820190508181036000830152613c7481613c38565b9050919050565b7f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060008201527f6163746976652070726f78790000000000000000000000000000000000000000602082015250565b6000613cd7602c836133c5565b9150613ce282613c7b565b604082019050919050565b60006020820190508181036000830152613d0681613cca565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b60006002820490506001821680613d5457607f821691505b602082108103613d6757613d66613d0d565b5b50919050565b7f4f6e6c79207468652061646d696e2063616e2063616c6c20746869732066756e60008201527f6374696f6e2e0000000000000000000000000000000000000000000000000000602082015250565b6000613dc96026836133c5565b9150613dd482613d6d565b604082019050919050565b60006020820190508181036000830152613df881613dbc565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b6000604082019050613e436000830185613658565b8181036020830152613e558184613400565b90509392505050565b6000613e6982613229565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203613e9b57613e9a613a5d565b5b600182019050919050565b6000602082019050613ebb6000830184613682565b92915050565b7f555550535570677261646561626c653a206d757374206e6f742062652063616c60008201527f6c6564207468726f7567682064656c656761746563616c6c0000000000000000602082015250565b6000613f1d6038836133c5565b9150613f2882613ec1565b604082019050919050565b60006020820190508181036000830152613f4c81613f10565b9050919050565b7f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160008201527f647920696e697469616c697a6564000000000000000000000000000000000000602082015250565b6000613faf602e836133c5565b9150613fba82613f53565b604082019050919050565b60006020820190508181036000830152613fde81613fa2565b9050919050565b6000819050919050565b600060ff82169050919050565b6000819050919050565b600061402161401c61401784613fe5565b613ffc565b613fef565b9050919050565b61403181614006565b82525050565b600060208201905061404c6000830184614028565b92915050565b7f4e6f7420616c6c20435073206861766520656e6f75676820617661696c61626c60008201527f652062616c616e63650000000000000000000000000000000000000000000000602082015250565b60006140ae6029836133c5565b91506140b982614052565b604082019050919050565b600060208201905081810360008301526140dd816140a1565b9050919050565b60006140ef82613837565b91506140fa83613837565b925082820390508181126000841216828213600085121516171561412157614120613a5d565b5b92915050565b600061413282613229565b915061413d83613229565b925082820190508082111561415557614154613a5d565b5b92915050565b600061416682613229565b915061417183613229565b925082820261417f81613229565b9150828204841483151761419657614195613a5d565b5b5092915050565b7f536c617368656400000000000000000000000000000000000000000000000000600082015250565b60006141d36007836133c5565b91506141de8261419d565b602082019050919050565b60006060820190506141fe6000830185613658565b61420b6020830184613658565b818103604083015261421c816141c6565b90509392505050565b7f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160008201527f6464726573730000000000000000000000000000000000000000000000000000602082015250565b60006142816026836133c5565b915061428c82614225565b604082019050919050565b600060208201905081810360008301526142b081614274565b9050919050565b6000815190506142c681612f83565b92915050565b6000602082840312156142e2576142e1612f47565b5b60006142f0848285016142b7565b91505092915050565b7f4f6e6c792043504163636f756e74206f776e65722063616e207769746864726160008201527f772074686520636f6c6c61746572616c2066756e647300000000000000000000602082015250565b60006143556036836133c5565b9150614360826142f9565b604082019050919050565b6000602082019050818103600083015261438481614348565b9050919050565b7f576974686472617720616d6f756e7420657863656564732062616c616e636500600082015250565b60006143c1601f836133c5565b91506143cc8261438b565b602082019050919050565b600060208201905081810360008301526143f0816143b4565b9050919050565b60008190508160005260206000209050919050565b60006020601f8301049050919050565b600082821b905092915050565b6000600883026144597fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8261441c565b614463868361441c565b95508019841693508086168417925050509392505050565b600061449661449161448c84613229565b613ffc565b613229565b9050919050565b6000819050919050565b6144b08361447b565b6144c46144bc8261449d565b848454614429565b825550505050565b600090565b6144d96144cc565b6144e48184846144a7565b505050565b5b81811015614508576144fd6000826144d1565b6001810190506144ea565b5050565b601f82111561454d5761451e816143f7565b6145278461440c565b81016020851015614536578190505b61454a6145428561440c565b8301826144e9565b50505b505050565b600082821c905092915050565b600061457060001984600802614552565b1980831691505092915050565b6000614589838361455f565b9150826002028217905092915050565b6145a2826133ba565b67ffffffffffffffff8111156145bb576145ba612ff7565b5b6145c58254613d3c565b6145d082828561450c565b600060209050601f83116001811461460357600084156145f1578287015190505b6145fb858261457d565b865550614663565b601f198416614611866143f7565b60005b8281101561463957848901518255600182019150602085019450602081019050614614565b868310156146565784890151614652601f89168261455f565b8355505b6001600288020188555050505b505050505050565b7f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572600082015250565b60006146a16020836133c5565b91506146ac8261466b565b602082019050919050565b600060208201905081810360008301526146d081614694565b9050919050565b6146e0816135b4565b81146146eb57600080fd5b50565b6000815190506146fd816146d7565b92915050565b60006020828403121561471957614718612f47565b5b6000614727848285016146ee565b91505092915050565b7f45524331393637557067726164653a206e657720696d706c656d656e7461746960008201527f6f6e206973206e6f742055555053000000000000000000000000000000000000602082015250565b600061478c602e836133c5565b915061479782614730565b604082019050919050565b600060208201905081810360008301526147bb8161477f565b9050919050565b7f45524331393637557067726164653a20756e737570706f727465642070726f7860008201527f6961626c65555549440000000000000000000000000000000000000000000000602082015250565b600061481e6029836133c5565b9150614829826147c2565b604082019050919050565b6000602082019050818103600083015261484d81614811565b9050919050565b7f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960008201527f6e697469616c697a696e67000000000000000000000000000000000000000000602082015250565b60006148b0602b836133c5565b91506148bb82614854565b604082019050919050565b600060208201905081810360008301526148df816148a3565b9050919050565b7f455243313936373a206e657720696d706c656d656e746174696f6e206973206e60008201527f6f74206120636f6e747261637400000000000000000000000000000000000000602082015250565b6000614942602d836133c5565b915061494d826148e6565b604082019050919050565b6000602082019050818103600083015261497181614935565b9050919050565b600081519050919050565b600081905092915050565b600061499982614978565b6149a38185614983565b93506149b38185602086016133d6565b80840191505092915050565b60006149cb828461498e565b915081905092915050565b7f416464726573733a2063616c6c20746f206e6f6e2d636f6e7472616374000000600082015250565b6000614a0c601d836133c5565b9150614a17826149d6565b602082019050919050565b60006020820190508181036000830152614a3b816149ff565b905091905056fe416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a264697066735822122039efb746de1c0bd7540f7f26b52f7415362fc87528ad867ccd8e1645324a9cc864736f6c63430008140033",
}

// CollateralABI is the input ABI used to generate the binding from.
// Deprecated: Use CollateralMetaData.ABI instead.
var CollateralABI = CollateralMetaData.ABI

// CollateralBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use CollateralMetaData.Bin instead.
var CollateralBin = CollateralMetaData.Bin

// DeployCollateral deploys a new Ethereum contract, binding an instance of Collateral to it.
func DeployCollateral(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Collateral, error) {
	parsed, err := CollateralMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(CollateralBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Collateral{CollateralCaller: CollateralCaller{contract: contract}, CollateralTransactor: CollateralTransactor{contract: contract}, CollateralFilterer: CollateralFilterer{contract: contract}}, nil
}

// Collateral is an auto generated Go binding around an Ethereum contract.
type Collateral struct {
	CollateralCaller     // Read-only binding to the contract
	CollateralTransactor // Write-only binding to the contract
	CollateralFilterer   // Log filterer for contract events
}

// CollateralCaller is an auto generated read-only Go binding around an Ethereum contract.
type CollateralCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CollateralTransactor is an auto generated write-only Go binding around an Ethereum contract.
type CollateralTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CollateralFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type CollateralFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CollateralSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type CollateralSession struct {
	Contract     *Collateral       // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// CollateralCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type CollateralCallerSession struct {
	Contract *CollateralCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts     // Call options to use throughout this session
}

// CollateralTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type CollateralTransactorSession struct {
	Contract     *CollateralTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// CollateralRaw is an auto generated low-level Go binding around an Ethereum contract.
type CollateralRaw struct {
	Contract *Collateral // Generic contract binding to access the raw methods on
}

// CollateralCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type CollateralCallerRaw struct {
	Contract *CollateralCaller // Generic read-only contract binding to access the raw methods on
}

// CollateralTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type CollateralTransactorRaw struct {
	Contract *CollateralTransactor // Generic write-only contract binding to access the raw methods on
}

// NewCollateral creates a new instance of Collateral, bound to a specific deployed contract.
func NewCollateral(address common.Address, backend bind.ContractBackend) (*Collateral, error) {
	contract, err := bindCollateral(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Collateral{CollateralCaller: CollateralCaller{contract: contract}, CollateralTransactor: CollateralTransactor{contract: contract}, CollateralFilterer: CollateralFilterer{contract: contract}}, nil
}

// NewCollateralCaller creates a new read-only instance of Collateral, bound to a specific deployed contract.
func NewCollateralCaller(address common.Address, caller bind.ContractCaller) (*CollateralCaller, error) {
	contract, err := bindCollateral(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &CollateralCaller{contract: contract}, nil
}

// NewCollateralTransactor creates a new write-only instance of Collateral, bound to a specific deployed contract.
func NewCollateralTransactor(address common.Address, transactor bind.ContractTransactor) (*CollateralTransactor, error) {
	contract, err := bindCollateral(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &CollateralTransactor{contract: contract}, nil
}

// NewCollateralFilterer creates a new log filterer instance of Collateral, bound to a specific deployed contract.
func NewCollateralFilterer(address common.Address, filterer bind.ContractFilterer) (*CollateralFilterer, error) {
	contract, err := bindCollateral(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &CollateralFilterer{contract: contract}, nil
}

// bindCollateral binds a generic wrapper to an already deployed contract.
func bindCollateral(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := CollateralMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Collateral *CollateralRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Collateral.Contract.CollateralCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Collateral *CollateralRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Collateral.Contract.CollateralTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Collateral *CollateralRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Collateral.Contract.CollateralTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Collateral *CollateralCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Collateral.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Collateral *CollateralTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Collateral.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Collateral *CollateralTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Collateral.Contract.contract.Transact(opts, method, params...)
}

// AvailableBalance is a free data retrieval call binding the contract method 0xa0821be3.
//
// Solidity: function availableBalance(address ) view returns(int256)
func (_Collateral *CollateralCaller) AvailableBalance(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _Collateral.contract.Call(opts, &out, "availableBalance", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// AvailableBalance is a free data retrieval call binding the contract method 0xa0821be3.
//
// Solidity: function availableBalance(address ) view returns(int256)
func (_Collateral *CollateralSession) AvailableBalance(arg0 common.Address) (*big.Int, error) {
	return _Collateral.Contract.AvailableBalance(&_Collateral.CallOpts, arg0)
}

// AvailableBalance is a free data retrieval call binding the contract method 0xa0821be3.
//
// Solidity: function availableBalance(address ) view returns(int256)
func (_Collateral *CollateralCallerSession) AvailableBalance(arg0 common.Address) (*big.Int, error) {
	return _Collateral.Contract.AvailableBalance(&_Collateral.CallOpts, arg0)
}

// BaseCollateral is a free data retrieval call binding the contract method 0x9b5ddf09.
//
// Solidity: function baseCollateral() view returns(uint256)
func (_Collateral *CollateralCaller) BaseCollateral(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _Collateral.contract.Call(opts, &out, "baseCollateral")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// BaseCollateral is a free data retrieval call binding the contract method 0x9b5ddf09.
//
// Solidity: function baseCollateral() view returns(uint256)
func (_Collateral *CollateralSession) BaseCollateral() (*big.Int, error) {
	return _Collateral.Contract.BaseCollateral(&_Collateral.CallOpts)
}

// BaseCollateral is a free data retrieval call binding the contract method 0x9b5ddf09.
//
// Solidity: function baseCollateral() view returns(uint256)
func (_Collateral *CollateralCallerSession) BaseCollateral() (*big.Int, error) {
	return _Collateral.Contract.BaseCollateral(&_Collateral.CallOpts)
}

// CollateralInfo is a free data retrieval call binding the contract method 0x53ad8720.
//
// Solidity: function collateralInfo() view returns((uint256,uint256,uint256,uint256))
func (_Collateral *CollateralCaller) CollateralInfo(opts *bind.CallOpts) (CollateralV2ContractInfo, error) {
	var out []interface{}
	err := _Collateral.contract.Call(opts, &out, "collateralInfo")

	if err != nil {
		return *new(CollateralV2ContractInfo), err
	}

	out0 := *abi.ConvertType(out[0], new(CollateralV2ContractInfo)).(*CollateralV2ContractInfo)

	return out0, err

}

// CollateralInfo is a free data retrieval call binding the contract method 0x53ad8720.
//
// Solidity: function collateralInfo() view returns((uint256,uint256,uint256,uint256))
func (_Collateral *CollateralSession) CollateralInfo() (CollateralV2ContractInfo, error) {
	return _Collateral.Contract.CollateralInfo(&_Collateral.CallOpts)
}

// CollateralInfo is a free data retrieval call binding the contract method 0x53ad8720.
//
// Solidity: function collateralInfo() view returns((uint256,uint256,uint256,uint256))
func (_Collateral *CollateralCallerSession) CollateralInfo() (CollateralV2ContractInfo, error) {
	return _Collateral.Contract.CollateralInfo(&_Collateral.CallOpts)
}

// CollateralRatio is a free data retrieval call binding the contract method 0xb4eae1cb.
//
// Solidity: function collateralRatio() view returns(uint256)
func (_Collateral *CollateralCaller) CollateralRatio(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _Collateral.contract.Call(opts, &out, "collateralRatio")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// CollateralRatio is a free data retrieval call binding the contract method 0xb4eae1cb.
//
// Solidity: function collateralRatio() view returns(uint256)
func (_Collateral *CollateralSession) CollateralRatio() (*big.Int, error) {
	return _Collateral.Contract.CollateralRatio(&_Collateral.CallOpts)
}

// CollateralRatio is a free data retrieval call binding the contract method 0xb4eae1cb.
//
// Solidity: function collateralRatio() view returns(uint256)
func (_Collateral *CollateralCallerSession) CollateralRatio() (*big.Int, error) {
	return _Collateral.Contract.CollateralRatio(&_Collateral.CallOpts)
}

// CpInfo is a free data retrieval call binding the contract method 0xa664c216.
//
// Solidity: function cpInfo(address cpAddress) view returns((address,int256,uint256,string))
func (_Collateral *CollateralCaller) CpInfo(opts *bind.CallOpts, cpAddress common.Address) (CollateralV2CPInfo, error) {
	var out []interface{}
	err := _Collateral.contract.Call(opts, &out, "cpInfo", cpAddress)

	if err != nil {
		return *new(CollateralV2CPInfo), err
	}

	out0 := *abi.ConvertType(out[0], new(CollateralV2CPInfo)).(*CollateralV2CPInfo)

	return out0, err

}

// CpInfo is a free data retrieval call binding the contract method 0xa664c216.
//
// Solidity: function cpInfo(address cpAddress) view returns((address,int256,uint256,string))
func (_Collateral *CollateralSession) CpInfo(cpAddress common.Address) (CollateralV2CPInfo, error) {
	return _Collateral.Contract.CpInfo(&_Collateral.CallOpts, cpAddress)
}

// CpInfo is a free data retrieval call binding the contract method 0xa664c216.
//
// Solidity: function cpInfo(address cpAddress) view returns((address,int256,uint256,string))
func (_Collateral *CollateralCallerSession) CpInfo(cpAddress common.Address) (CollateralV2CPInfo, error) {
	return _Collateral.Contract.CpInfo(&_Collateral.CallOpts, cpAddress)
}

// CpStatus is a free data retrieval call binding the contract method 0x3fe65177.
//
// Solidity: function cpStatus(address ) view returns(string)
func (_Collateral *CollateralCaller) CpStatus(opts *bind.CallOpts, arg0 common.Address) (string, error) {
	var out []interface{}
	err := _Collateral.contract.Call(opts, &out, "cpStatus", arg0)

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// CpStatus is a free data retrieval call binding the contract method 0x3fe65177.
//
// Solidity: function cpStatus(address ) view returns(string)
func (_Collateral *CollateralSession) CpStatus(arg0 common.Address) (string, error) {
	return _Collateral.Contract.CpStatus(&_Collateral.CallOpts, arg0)
}

// CpStatus is a free data retrieval call binding the contract method 0x3fe65177.
//
// Solidity: function cpStatus(address ) view returns(string)
func (_Collateral *CollateralCallerSession) CpStatus(arg0 common.Address) (string, error) {
	return _Collateral.Contract.CpStatus(&_Collateral.CallOpts, arg0)
}

// GetTaskInfo is a free data retrieval call binding the contract method 0x1b209463.
//
// Solidity: function getTaskInfo(string taskUid) view returns((address[],uint256,uint8))
func (_Collateral *CollateralCaller) GetTaskInfo(opts *bind.CallOpts, taskUid string) (CollateralV2Task, error) {
	var out []interface{}
	err := _Collateral.contract.Call(opts, &out, "getTaskInfo", taskUid)

	if err != nil {
		return *new(CollateralV2Task), err
	}

	out0 := *abi.ConvertType(out[0], new(CollateralV2Task)).(*CollateralV2Task)

	return out0, err

}

// GetTaskInfo is a free data retrieval call binding the contract method 0x1b209463.
//
// Solidity: function getTaskInfo(string taskUid) view returns((address[],uint256,uint8))
func (_Collateral *CollateralSession) GetTaskInfo(taskUid string) (CollateralV2Task, error) {
	return _Collateral.Contract.GetTaskInfo(&_Collateral.CallOpts, taskUid)
}

// GetTaskInfo is a free data retrieval call binding the contract method 0x1b209463.
//
// Solidity: function getTaskInfo(string taskUid) view returns((address[],uint256,uint8))
func (_Collateral *CollateralCallerSession) GetTaskInfo(taskUid string) (CollateralV2Task, error) {
	return _Collateral.Contract.GetTaskInfo(&_Collateral.CallOpts, taskUid)
}

// IsAdmin is a free data retrieval call binding the contract method 0x24d7806c.
//
// Solidity: function isAdmin(address ) view returns(bool)
func (_Collateral *CollateralCaller) IsAdmin(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _Collateral.contract.Call(opts, &out, "isAdmin", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsAdmin is a free data retrieval call binding the contract method 0x24d7806c.
//
// Solidity: function isAdmin(address ) view returns(bool)
func (_Collateral *CollateralSession) IsAdmin(arg0 common.Address) (bool, error) {
	return _Collateral.Contract.IsAdmin(&_Collateral.CallOpts, arg0)
}

// IsAdmin is a free data retrieval call binding the contract method 0x24d7806c.
//
// Solidity: function isAdmin(address ) view returns(bool)
func (_Collateral *CollateralCallerSession) IsAdmin(arg0 common.Address) (bool, error) {
	return _Collateral.Contract.IsAdmin(&_Collateral.CallOpts, arg0)
}

// LockedCollateral is a free data retrieval call binding the contract method 0x92bdf9ba.
//
// Solidity: function lockedCollateral(address ) view returns(uint256)
func (_Collateral *CollateralCaller) LockedCollateral(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _Collateral.contract.Call(opts, &out, "lockedCollateral", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// LockedCollateral is a free data retrieval call binding the contract method 0x92bdf9ba.
//
// Solidity: function lockedCollateral(address ) view returns(uint256)
func (_Collateral *CollateralSession) LockedCollateral(arg0 common.Address) (*big.Int, error) {
	return _Collateral.Contract.LockedCollateral(&_Collateral.CallOpts, arg0)
}

// LockedCollateral is a free data retrieval call binding the contract method 0x92bdf9ba.
//
// Solidity: function lockedCollateral(address ) view returns(uint256)
func (_Collateral *CollateralCallerSession) LockedCollateral(arg0 common.Address) (*big.Int, error) {
	return _Collateral.Contract.LockedCollateral(&_Collateral.CallOpts, arg0)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_Collateral *CollateralCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _Collateral.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_Collateral *CollateralSession) Owner() (common.Address, error) {
	return _Collateral.Contract.Owner(&_Collateral.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_Collateral *CollateralCallerSession) Owner() (common.Address, error) {
	return _Collateral.Contract.Owner(&_Collateral.CallOpts)
}

// ProxiableUUID is a free data retrieval call binding the contract method 0x52d1902d.
//
// Solidity: function proxiableUUID() view returns(bytes32)
func (_Collateral *CollateralCaller) ProxiableUUID(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _Collateral.contract.Call(opts, &out, "proxiableUUID")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// ProxiableUUID is a free data retrieval call binding the contract method 0x52d1902d.
//
// Solidity: function proxiableUUID() view returns(bytes32)
func (_Collateral *CollateralSession) ProxiableUUID() ([32]byte, error) {
	return _Collateral.Contract.ProxiableUUID(&_Collateral.CallOpts)
}

// ProxiableUUID is a free data retrieval call binding the contract method 0x52d1902d.
//
// Solidity: function proxiableUUID() view returns(bytes32)
func (_Collateral *CollateralCallerSession) ProxiableUUID() ([32]byte, error) {
	return _Collateral.Contract.ProxiableUUID(&_Collateral.CallOpts)
}

// SlashRatio is a free data retrieval call binding the contract method 0xd27ca89b.
//
// Solidity: function slashRatio() view returns(uint256)
func (_Collateral *CollateralCaller) SlashRatio(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _Collateral.contract.Call(opts, &out, "slashRatio")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// SlashRatio is a free data retrieval call binding the contract method 0xd27ca89b.
//
// Solidity: function slashRatio() view returns(uint256)
func (_Collateral *CollateralSession) SlashRatio() (*big.Int, error) {
	return _Collateral.Contract.SlashRatio(&_Collateral.CallOpts)
}

// SlashRatio is a free data retrieval call binding the contract method 0xd27ca89b.
//
// Solidity: function slashRatio() view returns(uint256)
func (_Collateral *CollateralCallerSession) SlashRatio() (*big.Int, error) {
	return _Collateral.Contract.SlashRatio(&_Collateral.CallOpts)
}

// SlashedFunds is a free data retrieval call binding the contract method 0x6f99f15c.
//
// Solidity: function slashedFunds() view returns(uint256)
func (_Collateral *CollateralCaller) SlashedFunds(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _Collateral.contract.Call(opts, &out, "slashedFunds")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// SlashedFunds is a free data retrieval call binding the contract method 0x6f99f15c.
//
// Solidity: function slashedFunds() view returns(uint256)
func (_Collateral *CollateralSession) SlashedFunds() (*big.Int, error) {
	return _Collateral.Contract.SlashedFunds(&_Collateral.CallOpts)
}

// SlashedFunds is a free data retrieval call binding the contract method 0x6f99f15c.
//
// Solidity: function slashedFunds() view returns(uint256)
func (_Collateral *CollateralCallerSession) SlashedFunds() (*big.Int, error) {
	return _Collateral.Contract.SlashedFunds(&_Collateral.CallOpts)
}

// Tasks is a free data retrieval call binding the contract method 0x58709cf2.
//
// Solidity: function tasks(string ) view returns(uint256 collateral, uint8 collateralStatus)
func (_Collateral *CollateralCaller) Tasks(opts *bind.CallOpts, arg0 string) (struct {
	Collateral       *big.Int
	CollateralStatus uint8
}, error) {
	var out []interface{}
	err := _Collateral.contract.Call(opts, &out, "tasks", arg0)

	outstruct := new(struct {
		Collateral       *big.Int
		CollateralStatus uint8
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Collateral = *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)
	outstruct.CollateralStatus = *abi.ConvertType(out[1], new(uint8)).(*uint8)

	return *outstruct, err

}

// Tasks is a free data retrieval call binding the contract method 0x58709cf2.
//
// Solidity: function tasks(string ) view returns(uint256 collateral, uint8 collateralStatus)
func (_Collateral *CollateralSession) Tasks(arg0 string) (struct {
	Collateral       *big.Int
	CollateralStatus uint8
}, error) {
	return _Collateral.Contract.Tasks(&_Collateral.CallOpts, arg0)
}

// Tasks is a free data retrieval call binding the contract method 0x58709cf2.
//
// Solidity: function tasks(string ) view returns(uint256 collateral, uint8 collateralStatus)
func (_Collateral *CollateralCallerSession) Tasks(arg0 string) (struct {
	Collateral       *big.Int
	CollateralStatus uint8
}, error) {
	return _Collateral.Contract.Tasks(&_Collateral.CallOpts, arg0)
}

// Version is a free data retrieval call binding the contract method 0x54fd4d50.
//
// Solidity: function version() pure returns(uint256)
func (_Collateral *CollateralCaller) Version(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _Collateral.contract.Call(opts, &out, "version")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Version is a free data retrieval call binding the contract method 0x54fd4d50.
//
// Solidity: function version() pure returns(uint256)
func (_Collateral *CollateralSession) Version() (*big.Int, error) {
	return _Collateral.Contract.Version(&_Collateral.CallOpts)
}

// Version is a free data retrieval call binding the contract method 0x54fd4d50.
//
// Solidity: function version() pure returns(uint256)
func (_Collateral *CollateralCallerSession) Version() (*big.Int, error) {
	return _Collateral.Contract.Version(&_Collateral.CallOpts)
}

// AddAdmin is a paid mutator transaction binding the contract method 0x70480275.
//
// Solidity: function addAdmin(address newAdmin) returns()
func (_Collateral *CollateralTransactor) AddAdmin(opts *bind.TransactOpts, newAdmin common.Address) (*types.Transaction, error) {
	return _Collateral.contract.Transact(opts, "addAdmin", newAdmin)
}

// AddAdmin is a paid mutator transaction binding the contract method 0x70480275.
//
// Solidity: function addAdmin(address newAdmin) returns()
func (_Collateral *CollateralSession) AddAdmin(newAdmin common.Address) (*types.Transaction, error) {
	return _Collateral.Contract.AddAdmin(&_Collateral.TransactOpts, newAdmin)
}

// AddAdmin is a paid mutator transaction binding the contract method 0x70480275.
//
// Solidity: function addAdmin(address newAdmin) returns()
func (_Collateral *CollateralTransactorSession) AddAdmin(newAdmin common.Address) (*types.Transaction, error) {
	return _Collateral.Contract.AddAdmin(&_Collateral.TransactOpts, newAdmin)
}

// Deposit is a paid mutator transaction binding the contract method 0xf340fa01.
//
// Solidity: function deposit(address cpAccount) payable returns()
func (_Collateral *CollateralTransactor) Deposit(opts *bind.TransactOpts, cpAccount common.Address) (*types.Transaction, error) {
	return _Collateral.contract.Transact(opts, "deposit", cpAccount)
}

// Deposit is a paid mutator transaction binding the contract method 0xf340fa01.
//
// Solidity: function deposit(address cpAccount) payable returns()
func (_Collateral *CollateralSession) Deposit(cpAccount common.Address) (*types.Transaction, error) {
	return _Collateral.Contract.Deposit(&_Collateral.TransactOpts, cpAccount)
}

// Deposit is a paid mutator transaction binding the contract method 0xf340fa01.
//
// Solidity: function deposit(address cpAccount) payable returns()
func (_Collateral *CollateralTransactorSession) Deposit(cpAccount common.Address) (*types.Transaction, error) {
	return _Collateral.Contract.Deposit(&_Collateral.TransactOpts, cpAccount)
}

// DisputeProof is a paid mutator transaction binding the contract method 0xe80d9dec.
//
// Solidity: function disputeProof(string taskUid) returns()
func (_Collateral *CollateralTransactor) DisputeProof(opts *bind.TransactOpts, taskUid string) (*types.Transaction, error) {
	return _Collateral.contract.Transact(opts, "disputeProof", taskUid)
}

// DisputeProof is a paid mutator transaction binding the contract method 0xe80d9dec.
//
// Solidity: function disputeProof(string taskUid) returns()
func (_Collateral *CollateralSession) DisputeProof(taskUid string) (*types.Transaction, error) {
	return _Collateral.Contract.DisputeProof(&_Collateral.TransactOpts, taskUid)
}

// DisputeProof is a paid mutator transaction binding the contract method 0xe80d9dec.
//
// Solidity: function disputeProof(string taskUid) returns()
func (_Collateral *CollateralTransactorSession) DisputeProof(taskUid string) (*types.Transaction, error) {
	return _Collateral.Contract.DisputeProof(&_Collateral.TransactOpts, taskUid)
}

// Initialize is a paid mutator transaction binding the contract method 0x8129fc1c.
//
// Solidity: function initialize() returns()
func (_Collateral *CollateralTransactor) Initialize(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Collateral.contract.Transact(opts, "initialize")
}

// Initialize is a paid mutator transaction binding the contract method 0x8129fc1c.
//
// Solidity: function initialize() returns()
func (_Collateral *CollateralSession) Initialize() (*types.Transaction, error) {
	return _Collateral.Contract.Initialize(&_Collateral.TransactOpts)
}

// Initialize is a paid mutator transaction binding the contract method 0x8129fc1c.
//
// Solidity: function initialize() returns()
func (_Collateral *CollateralTransactorSession) Initialize() (*types.Transaction, error) {
	return _Collateral.Contract.Initialize(&_Collateral.TransactOpts)
}

// LockCollateral is a paid mutator transaction binding the contract method 0x853911b2.
//
// Solidity: function lockCollateral(string taskUid, address[] cpList, uint256 taskCollateral) returns()
func (_Collateral *CollateralTransactor) LockCollateral(opts *bind.TransactOpts, taskUid string, cpList []common.Address, taskCollateral *big.Int) (*types.Transaction, error) {
	return _Collateral.contract.Transact(opts, "lockCollateral", taskUid, cpList, taskCollateral)
}

// LockCollateral is a paid mutator transaction binding the contract method 0x853911b2.
//
// Solidity: function lockCollateral(string taskUid, address[] cpList, uint256 taskCollateral) returns()
func (_Collateral *CollateralSession) LockCollateral(taskUid string, cpList []common.Address, taskCollateral *big.Int) (*types.Transaction, error) {
	return _Collateral.Contract.LockCollateral(&_Collateral.TransactOpts, taskUid, cpList, taskCollateral)
}

// LockCollateral is a paid mutator transaction binding the contract method 0x853911b2.
//
// Solidity: function lockCollateral(string taskUid, address[] cpList, uint256 taskCollateral) returns()
func (_Collateral *CollateralTransactorSession) LockCollateral(taskUid string, cpList []common.Address, taskCollateral *big.Int) (*types.Transaction, error) {
	return _Collateral.Contract.LockCollateral(&_Collateral.TransactOpts, taskUid, cpList, taskCollateral)
}

// LockCollateral0 is a paid mutator transaction binding the contract method 0xd4cd925c.
//
// Solidity: function lockCollateral(string taskUid, address[] cpList) returns()
func (_Collateral *CollateralTransactor) LockCollateral0(opts *bind.TransactOpts, taskUid string, cpList []common.Address) (*types.Transaction, error) {
	return _Collateral.contract.Transact(opts, "lockCollateral0", taskUid, cpList)
}

// LockCollateral0 is a paid mutator transaction binding the contract method 0xd4cd925c.
//
// Solidity: function lockCollateral(string taskUid, address[] cpList) returns()
func (_Collateral *CollateralSession) LockCollateral0(taskUid string, cpList []common.Address) (*types.Transaction, error) {
	return _Collateral.Contract.LockCollateral0(&_Collateral.TransactOpts, taskUid, cpList)
}

// LockCollateral0 is a paid mutator transaction binding the contract method 0xd4cd925c.
//
// Solidity: function lockCollateral(string taskUid, address[] cpList) returns()
func (_Collateral *CollateralTransactorSession) LockCollateral0(taskUid string, cpList []common.Address) (*types.Transaction, error) {
	return _Collateral.Contract.LockCollateral0(&_Collateral.TransactOpts, taskUid, cpList)
}

// RemoveAdmin is a paid mutator transaction binding the contract method 0x1785f53c.
//
// Solidity: function removeAdmin(address admin) returns()
func (_Collateral *CollateralTransactor) RemoveAdmin(opts *bind.TransactOpts, admin common.Address) (*types.Transaction, error) {
	return _Collateral.contract.Transact(opts, "removeAdmin", admin)
}

// RemoveAdmin is a paid mutator transaction binding the contract method 0x1785f53c.
//
// Solidity: function removeAdmin(address admin) returns()
func (_Collateral *CollateralSession) RemoveAdmin(admin common.Address) (*types.Transaction, error) {
	return _Collateral.Contract.RemoveAdmin(&_Collateral.TransactOpts, admin)
}

// RemoveAdmin is a paid mutator transaction binding the contract method 0x1785f53c.
//
// Solidity: function removeAdmin(address admin) returns()
func (_Collateral *CollateralTransactorSession) RemoveAdmin(admin common.Address) (*types.Transaction, error) {
	return _Collateral.Contract.RemoveAdmin(&_Collateral.TransactOpts, admin)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_Collateral *CollateralTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Collateral.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_Collateral *CollateralSession) RenounceOwnership() (*types.Transaction, error) {
	return _Collateral.Contract.RenounceOwnership(&_Collateral.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_Collateral *CollateralTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _Collateral.Contract.RenounceOwnership(&_Collateral.TransactOpts)
}

// SetBaseCollateral is a paid mutator transaction binding the contract method 0x7f58a7e5.
//
// Solidity: function setBaseCollateral(uint256 _baseCollateral) returns()
func (_Collateral *CollateralTransactor) SetBaseCollateral(opts *bind.TransactOpts, _baseCollateral *big.Int) (*types.Transaction, error) {
	return _Collateral.contract.Transact(opts, "setBaseCollateral", _baseCollateral)
}

// SetBaseCollateral is a paid mutator transaction binding the contract method 0x7f58a7e5.
//
// Solidity: function setBaseCollateral(uint256 _baseCollateral) returns()
func (_Collateral *CollateralSession) SetBaseCollateral(_baseCollateral *big.Int) (*types.Transaction, error) {
	return _Collateral.Contract.SetBaseCollateral(&_Collateral.TransactOpts, _baseCollateral)
}

// SetBaseCollateral is a paid mutator transaction binding the contract method 0x7f58a7e5.
//
// Solidity: function setBaseCollateral(uint256 _baseCollateral) returns()
func (_Collateral *CollateralTransactorSession) SetBaseCollateral(_baseCollateral *big.Int) (*types.Transaction, error) {
	return _Collateral.Contract.SetBaseCollateral(&_Collateral.TransactOpts, _baseCollateral)
}

// SetSlashRatio is a paid mutator transaction binding the contract method 0xce3518aa.
//
// Solidity: function setSlashRatio(uint256 _slashRatio) returns()
func (_Collateral *CollateralTransactor) SetSlashRatio(opts *bind.TransactOpts, _slashRatio *big.Int) (*types.Transaction, error) {
	return _Collateral.contract.Transact(opts, "setSlashRatio", _slashRatio)
}

// SetSlashRatio is a paid mutator transaction binding the contract method 0xce3518aa.
//
// Solidity: function setSlashRatio(uint256 _slashRatio) returns()
func (_Collateral *CollateralSession) SetSlashRatio(_slashRatio *big.Int) (*types.Transaction, error) {
	return _Collateral.Contract.SetSlashRatio(&_Collateral.TransactOpts, _slashRatio)
}

// SetSlashRatio is a paid mutator transaction binding the contract method 0xce3518aa.
//
// Solidity: function setSlashRatio(uint256 _slashRatio) returns()
func (_Collateral *CollateralTransactorSession) SetSlashRatio(_slashRatio *big.Int) (*types.Transaction, error) {
	return _Collateral.Contract.SetSlashRatio(&_Collateral.TransactOpts, _slashRatio)
}

// SlashCollateral is a paid mutator transaction binding the contract method 0xdd98fff5.
//
// Solidity: function slashCollateral(string taskUid, address cpAccount) returns()
func (_Collateral *CollateralTransactor) SlashCollateral(opts *bind.TransactOpts, taskUid string, cpAccount common.Address) (*types.Transaction, error) {
	return _Collateral.contract.Transact(opts, "slashCollateral", taskUid, cpAccount)
}

// SlashCollateral is a paid mutator transaction binding the contract method 0xdd98fff5.
//
// Solidity: function slashCollateral(string taskUid, address cpAccount) returns()
func (_Collateral *CollateralSession) SlashCollateral(taskUid string, cpAccount common.Address) (*types.Transaction, error) {
	return _Collateral.Contract.SlashCollateral(&_Collateral.TransactOpts, taskUid, cpAccount)
}

// SlashCollateral is a paid mutator transaction binding the contract method 0xdd98fff5.
//
// Solidity: function slashCollateral(string taskUid, address cpAccount) returns()
func (_Collateral *CollateralTransactorSession) SlashCollateral(taskUid string, cpAccount common.Address) (*types.Transaction, error) {
	return _Collateral.Contract.SlashCollateral(&_Collateral.TransactOpts, taskUid, cpAccount)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_Collateral *CollateralTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _Collateral.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_Collateral *CollateralSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _Collateral.Contract.TransferOwnership(&_Collateral.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_Collateral *CollateralTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _Collateral.Contract.TransferOwnership(&_Collateral.TransactOpts, newOwner)
}

// UnlockCollateral is a paid mutator transaction binding the contract method 0x4b9f0bea.
//
// Solidity: function unlockCollateral(string taskUid, uint256 amount) returns()
func (_Collateral *CollateralTransactor) UnlockCollateral(opts *bind.TransactOpts, taskUid string, amount *big.Int) (*types.Transaction, error) {
	return _Collateral.contract.Transact(opts, "unlockCollateral", taskUid, amount)
}

// UnlockCollateral is a paid mutator transaction binding the contract method 0x4b9f0bea.
//
// Solidity: function unlockCollateral(string taskUid, uint256 amount) returns()
func (_Collateral *CollateralSession) UnlockCollateral(taskUid string, amount *big.Int) (*types.Transaction, error) {
	return _Collateral.Contract.UnlockCollateral(&_Collateral.TransactOpts, taskUid, amount)
}

// UnlockCollateral is a paid mutator transaction binding the contract method 0x4b9f0bea.
//
// Solidity: function unlockCollateral(string taskUid, uint256 amount) returns()
func (_Collateral *CollateralTransactorSession) UnlockCollateral(taskUid string, amount *big.Int) (*types.Transaction, error) {
	return _Collateral.Contract.UnlockCollateral(&_Collateral.TransactOpts, taskUid, amount)
}

// UpgradeTo is a paid mutator transaction binding the contract method 0x3659cfe6.
//
// Solidity: function upgradeTo(address newImplementation) returns()
func (_Collateral *CollateralTransactor) UpgradeTo(opts *bind.TransactOpts, newImplementation common.Address) (*types.Transaction, error) {
	return _Collateral.contract.Transact(opts, "upgradeTo", newImplementation)
}

// UpgradeTo is a paid mutator transaction binding the contract method 0x3659cfe6.
//
// Solidity: function upgradeTo(address newImplementation) returns()
func (_Collateral *CollateralSession) UpgradeTo(newImplementation common.Address) (*types.Transaction, error) {
	return _Collateral.Contract.UpgradeTo(&_Collateral.TransactOpts, newImplementation)
}

// UpgradeTo is a paid mutator transaction binding the contract method 0x3659cfe6.
//
// Solidity: function upgradeTo(address newImplementation) returns()
func (_Collateral *CollateralTransactorSession) UpgradeTo(newImplementation common.Address) (*types.Transaction, error) {
	return _Collateral.Contract.UpgradeTo(&_Collateral.TransactOpts, newImplementation)
}

// UpgradeToAndCall is a paid mutator transaction binding the contract method 0x4f1ef286.
//
// Solidity: function upgradeToAndCall(address newImplementation, bytes data) payable returns()
func (_Collateral *CollateralTransactor) UpgradeToAndCall(opts *bind.TransactOpts, newImplementation common.Address, data []byte) (*types.Transaction, error) {
	return _Collateral.contract.Transact(opts, "upgradeToAndCall", newImplementation, data)
}

// UpgradeToAndCall is a paid mutator transaction binding the contract method 0x4f1ef286.
//
// Solidity: function upgradeToAndCall(address newImplementation, bytes data) payable returns()
func (_Collateral *CollateralSession) UpgradeToAndCall(newImplementation common.Address, data []byte) (*types.Transaction, error) {
	return _Collateral.Contract.UpgradeToAndCall(&_Collateral.TransactOpts, newImplementation, data)
}

// UpgradeToAndCall is a paid mutator transaction binding the contract method 0x4f1ef286.
//
// Solidity: function upgradeToAndCall(address newImplementation, bytes data) payable returns()
func (_Collateral *CollateralTransactorSession) UpgradeToAndCall(newImplementation common.Address, data []byte) (*types.Transaction, error) {
	return _Collateral.Contract.UpgradeToAndCall(&_Collateral.TransactOpts, newImplementation, data)
}

// Withdraw is a paid mutator transaction binding the contract method 0xf3fef3a3.
//
// Solidity: function withdraw(address cpAccount, uint256 amount) returns()
func (_Collateral *CollateralTransactor) Withdraw(opts *bind.TransactOpts, cpAccount common.Address, amount *big.Int) (*types.Transaction, error) {
	return _Collateral.contract.Transact(opts, "withdraw", cpAccount, amount)
}

// Withdraw is a paid mutator transaction binding the contract method 0xf3fef3a3.
//
// Solidity: function withdraw(address cpAccount, uint256 amount) returns()
func (_Collateral *CollateralSession) Withdraw(cpAccount common.Address, amount *big.Int) (*types.Transaction, error) {
	return _Collateral.Contract.Withdraw(&_Collateral.TransactOpts, cpAccount, amount)
}

// Withdraw is a paid mutator transaction binding the contract method 0xf3fef3a3.
//
// Solidity: function withdraw(address cpAccount, uint256 amount) returns()
func (_Collateral *CollateralTransactorSession) Withdraw(cpAccount common.Address, amount *big.Int) (*types.Transaction, error) {
	return _Collateral.Contract.Withdraw(&_Collateral.TransactOpts, cpAccount, amount)
}

// WithdrawSlashedFunds is a paid mutator transaction binding the contract method 0x2894493f.
//
// Solidity: function withdrawSlashedFunds(uint256 amount) returns()
func (_Collateral *CollateralTransactor) WithdrawSlashedFunds(opts *bind.TransactOpts, amount *big.Int) (*types.Transaction, error) {
	return _Collateral.contract.Transact(opts, "withdrawSlashedFunds", amount)
}

// WithdrawSlashedFunds is a paid mutator transaction binding the contract method 0x2894493f.
//
// Solidity: function withdrawSlashedFunds(uint256 amount) returns()
func (_Collateral *CollateralSession) WithdrawSlashedFunds(amount *big.Int) (*types.Transaction, error) {
	return _Collateral.Contract.WithdrawSlashedFunds(&_Collateral.TransactOpts, amount)
}

// WithdrawSlashedFunds is a paid mutator transaction binding the contract method 0x2894493f.
//
// Solidity: function withdrawSlashedFunds(uint256 amount) returns()
func (_Collateral *CollateralTransactorSession) WithdrawSlashedFunds(amount *big.Int) (*types.Transaction, error) {
	return _Collateral.Contract.WithdrawSlashedFunds(&_Collateral.TransactOpts, amount)
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_Collateral *CollateralTransactor) Receive(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Collateral.contract.RawTransact(opts, nil) // calldata is disallowed for receive function
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_Collateral *CollateralSession) Receive() (*types.Transaction, error) {
	return _Collateral.Contract.Receive(&_Collateral.TransactOpts)
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_Collateral *CollateralTransactorSession) Receive() (*types.Transaction, error) {
	return _Collateral.Contract.Receive(&_Collateral.TransactOpts)
}

// CollateralAdminChangedIterator is returned from FilterAdminChanged and is used to iterate over the raw logs and unpacked data for AdminChanged events raised by the Collateral contract.
type CollateralAdminChangedIterator struct {
	Event *CollateralAdminChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CollateralAdminChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CollateralAdminChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CollateralAdminChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CollateralAdminChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CollateralAdminChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CollateralAdminChanged represents a AdminChanged event raised by the Collateral contract.
type CollateralAdminChanged struct {
	PreviousAdmin common.Address
	NewAdmin      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterAdminChanged is a free log retrieval operation binding the contract event 0x7e644d79422f17c01e4894b5f4f588d331ebfa28653d42ae832dc59e38c9798f.
//
// Solidity: event AdminChanged(address previousAdmin, address newAdmin)
func (_Collateral *CollateralFilterer) FilterAdminChanged(opts *bind.FilterOpts) (*CollateralAdminChangedIterator, error) {

	logs, sub, err := _Collateral.contract.FilterLogs(opts, "AdminChanged")
	if err != nil {
		return nil, err
	}
	return &CollateralAdminChangedIterator{contract: _Collateral.contract, event: "AdminChanged", logs: logs, sub: sub}, nil
}

// WatchAdminChanged is a free log subscription operation binding the contract event 0x7e644d79422f17c01e4894b5f4f588d331ebfa28653d42ae832dc59e38c9798f.
//
// Solidity: event AdminChanged(address previousAdmin, address newAdmin)
func (_Collateral *CollateralFilterer) WatchAdminChanged(opts *bind.WatchOpts, sink chan<- *CollateralAdminChanged) (event.Subscription, error) {

	logs, sub, err := _Collateral.contract.WatchLogs(opts, "AdminChanged")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CollateralAdminChanged)
				if err := _Collateral.contract.UnpackLog(event, "AdminChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAdminChanged is a log parse operation binding the contract event 0x7e644d79422f17c01e4894b5f4f588d331ebfa28653d42ae832dc59e38c9798f.
//
// Solidity: event AdminChanged(address previousAdmin, address newAdmin)
func (_Collateral *CollateralFilterer) ParseAdminChanged(log types.Log) (*CollateralAdminChanged, error) {
	event := new(CollateralAdminChanged)
	if err := _Collateral.contract.UnpackLog(event, "AdminChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// CollateralBeaconUpgradedIterator is returned from FilterBeaconUpgraded and is used to iterate over the raw logs and unpacked data for BeaconUpgraded events raised by the Collateral contract.
type CollateralBeaconUpgradedIterator struct {
	Event *CollateralBeaconUpgraded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CollateralBeaconUpgradedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CollateralBeaconUpgraded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CollateralBeaconUpgraded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CollateralBeaconUpgradedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CollateralBeaconUpgradedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CollateralBeaconUpgraded represents a BeaconUpgraded event raised by the Collateral contract.
type CollateralBeaconUpgraded struct {
	Beacon common.Address
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterBeaconUpgraded is a free log retrieval operation binding the contract event 0x1cf3b03a6cf19fa2baba4df148e9dcabedea7f8a5c07840e207e5c089be95d3e.
//
// Solidity: event BeaconUpgraded(address indexed beacon)
func (_Collateral *CollateralFilterer) FilterBeaconUpgraded(opts *bind.FilterOpts, beacon []common.Address) (*CollateralBeaconUpgradedIterator, error) {

	var beaconRule []interface{}
	for _, beaconItem := range beacon {
		beaconRule = append(beaconRule, beaconItem)
	}

	logs, sub, err := _Collateral.contract.FilterLogs(opts, "BeaconUpgraded", beaconRule)
	if err != nil {
		return nil, err
	}
	return &CollateralBeaconUpgradedIterator{contract: _Collateral.contract, event: "BeaconUpgraded", logs: logs, sub: sub}, nil
}

// WatchBeaconUpgraded is a free log subscription operation binding the contract event 0x1cf3b03a6cf19fa2baba4df148e9dcabedea7f8a5c07840e207e5c089be95d3e.
//
// Solidity: event BeaconUpgraded(address indexed beacon)
func (_Collateral *CollateralFilterer) WatchBeaconUpgraded(opts *bind.WatchOpts, sink chan<- *CollateralBeaconUpgraded, beacon []common.Address) (event.Subscription, error) {

	var beaconRule []interface{}
	for _, beaconItem := range beacon {
		beaconRule = append(beaconRule, beaconItem)
	}

	logs, sub, err := _Collateral.contract.WatchLogs(opts, "BeaconUpgraded", beaconRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CollateralBeaconUpgraded)
				if err := _Collateral.contract.UnpackLog(event, "BeaconUpgraded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseBeaconUpgraded is a log parse operation binding the contract event 0x1cf3b03a6cf19fa2baba4df148e9dcabedea7f8a5c07840e207e5c089be95d3e.
//
// Solidity: event BeaconUpgraded(address indexed beacon)
func (_Collateral *CollateralFilterer) ParseBeaconUpgraded(log types.Log) (*CollateralBeaconUpgraded, error) {
	event := new(CollateralBeaconUpgraded)
	if err := _Collateral.contract.UnpackLog(event, "BeaconUpgraded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// CollateralCollateralAdjustedIterator is returned from FilterCollateralAdjusted and is used to iterate over the raw logs and unpacked data for CollateralAdjusted events raised by the Collateral contract.
type CollateralCollateralAdjustedIterator struct {
	Event *CollateralCollateralAdjusted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CollateralCollateralAdjustedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CollateralCollateralAdjusted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CollateralCollateralAdjusted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CollateralCollateralAdjustedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CollateralCollateralAdjustedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CollateralCollateralAdjusted represents a CollateralAdjusted event raised by the Collateral contract.
type CollateralCollateralAdjusted struct {
	Cp            common.Address
	FrozenAmount  *big.Int
	BalanceAmount *big.Int
	Operation     string
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterCollateralAdjusted is a free log retrieval operation binding the contract event 0x42f1a8a1aee108e84e4eabfaa8d51d7baaa1a02d482295297883a44b2debd3e4.
//
// Solidity: event CollateralAdjusted(address indexed cp, uint256 frozenAmount, uint256 balanceAmount, string operation)
func (_Collateral *CollateralFilterer) FilterCollateralAdjusted(opts *bind.FilterOpts, cp []common.Address) (*CollateralCollateralAdjustedIterator, error) {

	var cpRule []interface{}
	for _, cpItem := range cp {
		cpRule = append(cpRule, cpItem)
	}

	logs, sub, err := _Collateral.contract.FilterLogs(opts, "CollateralAdjusted", cpRule)
	if err != nil {
		return nil, err
	}
	return &CollateralCollateralAdjustedIterator{contract: _Collateral.contract, event: "CollateralAdjusted", logs: logs, sub: sub}, nil
}

// WatchCollateralAdjusted is a free log subscription operation binding the contract event 0x42f1a8a1aee108e84e4eabfaa8d51d7baaa1a02d482295297883a44b2debd3e4.
//
// Solidity: event CollateralAdjusted(address indexed cp, uint256 frozenAmount, uint256 balanceAmount, string operation)
func (_Collateral *CollateralFilterer) WatchCollateralAdjusted(opts *bind.WatchOpts, sink chan<- *CollateralCollateralAdjusted, cp []common.Address) (event.Subscription, error) {

	var cpRule []interface{}
	for _, cpItem := range cp {
		cpRule = append(cpRule, cpItem)
	}

	logs, sub, err := _Collateral.contract.WatchLogs(opts, "CollateralAdjusted", cpRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CollateralCollateralAdjusted)
				if err := _Collateral.contract.UnpackLog(event, "CollateralAdjusted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseCollateralAdjusted is a log parse operation binding the contract event 0x42f1a8a1aee108e84e4eabfaa8d51d7baaa1a02d482295297883a44b2debd3e4.
//
// Solidity: event CollateralAdjusted(address indexed cp, uint256 frozenAmount, uint256 balanceAmount, string operation)
func (_Collateral *CollateralFilterer) ParseCollateralAdjusted(log types.Log) (*CollateralCollateralAdjusted, error) {
	event := new(CollateralCollateralAdjusted)
	if err := _Collateral.contract.UnpackLog(event, "CollateralAdjusted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// CollateralCollateralLockedIterator is returned from FilterCollateralLocked and is used to iterate over the raw logs and unpacked data for CollateralLocked events raised by the Collateral contract.
type CollateralCollateralLockedIterator struct {
	Event *CollateralCollateralLocked // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CollateralCollateralLockedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CollateralCollateralLocked)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CollateralCollateralLocked)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CollateralCollateralLockedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CollateralCollateralLockedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CollateralCollateralLocked represents a CollateralLocked event raised by the Collateral contract.
type CollateralCollateralLocked struct {
	Cp               common.Address
	CollateralAmount *big.Int
	TaskUid          string
	Raw              types.Log // Blockchain specific contextual infos
}

// FilterCollateralLocked is a free log retrieval operation binding the contract event 0x5f3d004cf9164b95ed5dbf47d1f04018a4eabcb20b4320fe229ed92236ace634.
//
// Solidity: event CollateralLocked(address indexed cp, uint256 collateralAmount, string taskUid)
func (_Collateral *CollateralFilterer) FilterCollateralLocked(opts *bind.FilterOpts, cp []common.Address) (*CollateralCollateralLockedIterator, error) {

	var cpRule []interface{}
	for _, cpItem := range cp {
		cpRule = append(cpRule, cpItem)
	}

	logs, sub, err := _Collateral.contract.FilterLogs(opts, "CollateralLocked", cpRule)
	if err != nil {
		return nil, err
	}
	return &CollateralCollateralLockedIterator{contract: _Collateral.contract, event: "CollateralLocked", logs: logs, sub: sub}, nil
}

// WatchCollateralLocked is a free log subscription operation binding the contract event 0x5f3d004cf9164b95ed5dbf47d1f04018a4eabcb20b4320fe229ed92236ace634.
//
// Solidity: event CollateralLocked(address indexed cp, uint256 collateralAmount, string taskUid)
func (_Collateral *CollateralFilterer) WatchCollateralLocked(opts *bind.WatchOpts, sink chan<- *CollateralCollateralLocked, cp []common.Address) (event.Subscription, error) {

	var cpRule []interface{}
	for _, cpItem := range cp {
		cpRule = append(cpRule, cpItem)
	}

	logs, sub, err := _Collateral.contract.WatchLogs(opts, "CollateralLocked", cpRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CollateralCollateralLocked)
				if err := _Collateral.contract.UnpackLog(event, "CollateralLocked", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseCollateralLocked is a log parse operation binding the contract event 0x5f3d004cf9164b95ed5dbf47d1f04018a4eabcb20b4320fe229ed92236ace634.
//
// Solidity: event CollateralLocked(address indexed cp, uint256 collateralAmount, string taskUid)
func (_Collateral *CollateralFilterer) ParseCollateralLocked(log types.Log) (*CollateralCollateralLocked, error) {
	event := new(CollateralCollateralLocked)
	if err := _Collateral.contract.UnpackLog(event, "CollateralLocked", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// CollateralCollateralSlashedIterator is returned from FilterCollateralSlashed and is used to iterate over the raw logs and unpacked data for CollateralSlashed events raised by the Collateral contract.
type CollateralCollateralSlashedIterator struct {
	Event *CollateralCollateralSlashed // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CollateralCollateralSlashedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CollateralCollateralSlashed)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CollateralCollateralSlashed)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CollateralCollateralSlashedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CollateralCollateralSlashedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CollateralCollateralSlashed represents a CollateralSlashed event raised by the Collateral contract.
type CollateralCollateralSlashed struct {
	Cp      common.Address
	Amount  *big.Int
	TaskUid string
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterCollateralSlashed is a free log retrieval operation binding the contract event 0x403feb2cd85cc25c910fe59289105b583f08fe9e4335ebbb08c1851f47ff2d34.
//
// Solidity: event CollateralSlashed(address indexed cp, uint256 amount, string taskUid)
func (_Collateral *CollateralFilterer) FilterCollateralSlashed(opts *bind.FilterOpts, cp []common.Address) (*CollateralCollateralSlashedIterator, error) {

	var cpRule []interface{}
	for _, cpItem := range cp {
		cpRule = append(cpRule, cpItem)
	}

	logs, sub, err := _Collateral.contract.FilterLogs(opts, "CollateralSlashed", cpRule)
	if err != nil {
		return nil, err
	}
	return &CollateralCollateralSlashedIterator{contract: _Collateral.contract, event: "CollateralSlashed", logs: logs, sub: sub}, nil
}

// WatchCollateralSlashed is a free log subscription operation binding the contract event 0x403feb2cd85cc25c910fe59289105b583f08fe9e4335ebbb08c1851f47ff2d34.
//
// Solidity: event CollateralSlashed(address indexed cp, uint256 amount, string taskUid)
func (_Collateral *CollateralFilterer) WatchCollateralSlashed(opts *bind.WatchOpts, sink chan<- *CollateralCollateralSlashed, cp []common.Address) (event.Subscription, error) {

	var cpRule []interface{}
	for _, cpItem := range cp {
		cpRule = append(cpRule, cpItem)
	}

	logs, sub, err := _Collateral.contract.WatchLogs(opts, "CollateralSlashed", cpRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CollateralCollateralSlashed)
				if err := _Collateral.contract.UnpackLog(event, "CollateralSlashed", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseCollateralSlashed is a log parse operation binding the contract event 0x403feb2cd85cc25c910fe59289105b583f08fe9e4335ebbb08c1851f47ff2d34.
//
// Solidity: event CollateralSlashed(address indexed cp, uint256 amount, string taskUid)
func (_Collateral *CollateralFilterer) ParseCollateralSlashed(log types.Log) (*CollateralCollateralSlashed, error) {
	event := new(CollateralCollateralSlashed)
	if err := _Collateral.contract.UnpackLog(event, "CollateralSlashed", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// CollateralCollateralStatusChangedIterator is returned from FilterCollateralStatusChanged and is used to iterate over the raw logs and unpacked data for CollateralStatusChanged events raised by the Collateral contract.
type CollateralCollateralStatusChangedIterator struct {
	Event *CollateralCollateralStatusChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CollateralCollateralStatusChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CollateralCollateralStatusChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CollateralCollateralStatusChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CollateralCollateralStatusChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CollateralCollateralStatusChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CollateralCollateralStatusChanged represents a CollateralStatusChanged event raised by the Collateral contract.
type CollateralCollateralStatusChanged struct {
	TaskUid   common.Hash
	NewStatus uint8
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterCollateralStatusChanged is a free log retrieval operation binding the contract event 0x4a2ced9ada462e244851a86e998eb0b5bf558c2c9c6923b7f970ed2b19b073b0.
//
// Solidity: event CollateralStatusChanged(string indexed taskUid, uint8 newStatus)
func (_Collateral *CollateralFilterer) FilterCollateralStatusChanged(opts *bind.FilterOpts, taskUid []string) (*CollateralCollateralStatusChangedIterator, error) {

	var taskUidRule []interface{}
	for _, taskUidItem := range taskUid {
		taskUidRule = append(taskUidRule, taskUidItem)
	}

	logs, sub, err := _Collateral.contract.FilterLogs(opts, "CollateralStatusChanged", taskUidRule)
	if err != nil {
		return nil, err
	}
	return &CollateralCollateralStatusChangedIterator{contract: _Collateral.contract, event: "CollateralStatusChanged", logs: logs, sub: sub}, nil
}

// WatchCollateralStatusChanged is a free log subscription operation binding the contract event 0x4a2ced9ada462e244851a86e998eb0b5bf558c2c9c6923b7f970ed2b19b073b0.
//
// Solidity: event CollateralStatusChanged(string indexed taskUid, uint8 newStatus)
func (_Collateral *CollateralFilterer) WatchCollateralStatusChanged(opts *bind.WatchOpts, sink chan<- *CollateralCollateralStatusChanged, taskUid []string) (event.Subscription, error) {

	var taskUidRule []interface{}
	for _, taskUidItem := range taskUid {
		taskUidRule = append(taskUidRule, taskUidItem)
	}

	logs, sub, err := _Collateral.contract.WatchLogs(opts, "CollateralStatusChanged", taskUidRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CollateralCollateralStatusChanged)
				if err := _Collateral.contract.UnpackLog(event, "CollateralStatusChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseCollateralStatusChanged is a log parse operation binding the contract event 0x4a2ced9ada462e244851a86e998eb0b5bf558c2c9c6923b7f970ed2b19b073b0.
//
// Solidity: event CollateralStatusChanged(string indexed taskUid, uint8 newStatus)
func (_Collateral *CollateralFilterer) ParseCollateralStatusChanged(log types.Log) (*CollateralCollateralStatusChanged, error) {
	event := new(CollateralCollateralStatusChanged)
	if err := _Collateral.contract.UnpackLog(event, "CollateralStatusChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// CollateralCollateralUnlockedIterator is returned from FilterCollateralUnlocked and is used to iterate over the raw logs and unpacked data for CollateralUnlocked events raised by the Collateral contract.
type CollateralCollateralUnlockedIterator struct {
	Event *CollateralCollateralUnlocked // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CollateralCollateralUnlockedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CollateralCollateralUnlocked)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CollateralCollateralUnlocked)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CollateralCollateralUnlockedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CollateralCollateralUnlockedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CollateralCollateralUnlocked represents a CollateralUnlocked event raised by the Collateral contract.
type CollateralCollateralUnlocked struct {
	Cp               common.Address
	CollateralAmount *big.Int
	TaskUid          string
	Raw              types.Log // Blockchain specific contextual infos
}

// FilterCollateralUnlocked is a free log retrieval operation binding the contract event 0x0f2440b3ca071b7d18e917a25289e7d7e7de8a491546d45acc2efbec7b3e1ae8.
//
// Solidity: event CollateralUnlocked(address indexed cp, uint256 collateralAmount, string taskUid)
func (_Collateral *CollateralFilterer) FilterCollateralUnlocked(opts *bind.FilterOpts, cp []common.Address) (*CollateralCollateralUnlockedIterator, error) {

	var cpRule []interface{}
	for _, cpItem := range cp {
		cpRule = append(cpRule, cpItem)
	}

	logs, sub, err := _Collateral.contract.FilterLogs(opts, "CollateralUnlocked", cpRule)
	if err != nil {
		return nil, err
	}
	return &CollateralCollateralUnlockedIterator{contract: _Collateral.contract, event: "CollateralUnlocked", logs: logs, sub: sub}, nil
}

// WatchCollateralUnlocked is a free log subscription operation binding the contract event 0x0f2440b3ca071b7d18e917a25289e7d7e7de8a491546d45acc2efbec7b3e1ae8.
//
// Solidity: event CollateralUnlocked(address indexed cp, uint256 collateralAmount, string taskUid)
func (_Collateral *CollateralFilterer) WatchCollateralUnlocked(opts *bind.WatchOpts, sink chan<- *CollateralCollateralUnlocked, cp []common.Address) (event.Subscription, error) {

	var cpRule []interface{}
	for _, cpItem := range cp {
		cpRule = append(cpRule, cpItem)
	}

	logs, sub, err := _Collateral.contract.WatchLogs(opts, "CollateralUnlocked", cpRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CollateralCollateralUnlocked)
				if err := _Collateral.contract.UnpackLog(event, "CollateralUnlocked", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseCollateralUnlocked is a log parse operation binding the contract event 0x0f2440b3ca071b7d18e917a25289e7d7e7de8a491546d45acc2efbec7b3e1ae8.
//
// Solidity: event CollateralUnlocked(address indexed cp, uint256 collateralAmount, string taskUid)
func (_Collateral *CollateralFilterer) ParseCollateralUnlocked(log types.Log) (*CollateralCollateralUnlocked, error) {
	event := new(CollateralCollateralUnlocked)
	if err := _Collateral.contract.UnpackLog(event, "CollateralUnlocked", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// CollateralDepositIterator is returned from FilterDeposit and is used to iterate over the raw logs and unpacked data for Deposit events raised by the Collateral contract.
type CollateralDepositIterator struct {
	Event *CollateralDeposit // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CollateralDepositIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CollateralDeposit)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CollateralDeposit)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CollateralDepositIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CollateralDepositIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CollateralDeposit represents a Deposit event raised by the Collateral contract.
type CollateralDeposit struct {
	FundingWallet common.Address
	CpAccount     common.Address
	DepositAmount *big.Int
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterDeposit is a free log retrieval operation binding the contract event 0x5548c837ab068cf56a2c2479df0882a4922fd203edb7517321831d95078c5f62.
//
// Solidity: event Deposit(address indexed fundingWallet, address indexed cpAccount, uint256 depositAmount)
func (_Collateral *CollateralFilterer) FilterDeposit(opts *bind.FilterOpts, fundingWallet []common.Address, cpAccount []common.Address) (*CollateralDepositIterator, error) {

	var fundingWalletRule []interface{}
	for _, fundingWalletItem := range fundingWallet {
		fundingWalletRule = append(fundingWalletRule, fundingWalletItem)
	}
	var cpAccountRule []interface{}
	for _, cpAccountItem := range cpAccount {
		cpAccountRule = append(cpAccountRule, cpAccountItem)
	}

	logs, sub, err := _Collateral.contract.FilterLogs(opts, "Deposit", fundingWalletRule, cpAccountRule)
	if err != nil {
		return nil, err
	}
	return &CollateralDepositIterator{contract: _Collateral.contract, event: "Deposit", logs: logs, sub: sub}, nil
}

// WatchDeposit is a free log subscription operation binding the contract event 0x5548c837ab068cf56a2c2479df0882a4922fd203edb7517321831d95078c5f62.
//
// Solidity: event Deposit(address indexed fundingWallet, address indexed cpAccount, uint256 depositAmount)
func (_Collateral *CollateralFilterer) WatchDeposit(opts *bind.WatchOpts, sink chan<- *CollateralDeposit, fundingWallet []common.Address, cpAccount []common.Address) (event.Subscription, error) {

	var fundingWalletRule []interface{}
	for _, fundingWalletItem := range fundingWallet {
		fundingWalletRule = append(fundingWalletRule, fundingWalletItem)
	}
	var cpAccountRule []interface{}
	for _, cpAccountItem := range cpAccount {
		cpAccountRule = append(cpAccountRule, cpAccountItem)
	}

	logs, sub, err := _Collateral.contract.WatchLogs(opts, "Deposit", fundingWalletRule, cpAccountRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CollateralDeposit)
				if err := _Collateral.contract.UnpackLog(event, "Deposit", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDeposit is a log parse operation binding the contract event 0x5548c837ab068cf56a2c2479df0882a4922fd203edb7517321831d95078c5f62.
//
// Solidity: event Deposit(address indexed fundingWallet, address indexed cpAccount, uint256 depositAmount)
func (_Collateral *CollateralFilterer) ParseDeposit(log types.Log) (*CollateralDeposit, error) {
	event := new(CollateralDeposit)
	if err := _Collateral.contract.UnpackLog(event, "Deposit", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// CollateralDisputeProofIterator is returned from FilterDisputeProof and is used to iterate over the raw logs and unpacked data for DisputeProof events raised by the Collateral contract.
type CollateralDisputeProofIterator struct {
	Event *CollateralDisputeProof // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CollateralDisputeProofIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CollateralDisputeProof)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CollateralDisputeProof)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CollateralDisputeProofIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CollateralDisputeProofIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CollateralDisputeProof represents a DisputeProof event raised by the Collateral contract.
type CollateralDisputeProof struct {
	Challenger common.Address
	TaskUid    common.Hash
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterDisputeProof is a free log retrieval operation binding the contract event 0xaec1d412a3c1e4a13fc2a2e19ac38a5af192a9cf17b074fca8146a2d0655e0c3.
//
// Solidity: event DisputeProof(address indexed challenger, string indexed taskUid)
func (_Collateral *CollateralFilterer) FilterDisputeProof(opts *bind.FilterOpts, challenger []common.Address, taskUid []string) (*CollateralDisputeProofIterator, error) {

	var challengerRule []interface{}
	for _, challengerItem := range challenger {
		challengerRule = append(challengerRule, challengerItem)
	}
	var taskUidRule []interface{}
	for _, taskUidItem := range taskUid {
		taskUidRule = append(taskUidRule, taskUidItem)
	}

	logs, sub, err := _Collateral.contract.FilterLogs(opts, "DisputeProof", challengerRule, taskUidRule)
	if err != nil {
		return nil, err
	}
	return &CollateralDisputeProofIterator{contract: _Collateral.contract, event: "DisputeProof", logs: logs, sub: sub}, nil
}

// WatchDisputeProof is a free log subscription operation binding the contract event 0xaec1d412a3c1e4a13fc2a2e19ac38a5af192a9cf17b074fca8146a2d0655e0c3.
//
// Solidity: event DisputeProof(address indexed challenger, string indexed taskUid)
func (_Collateral *CollateralFilterer) WatchDisputeProof(opts *bind.WatchOpts, sink chan<- *CollateralDisputeProof, challenger []common.Address, taskUid []string) (event.Subscription, error) {

	var challengerRule []interface{}
	for _, challengerItem := range challenger {
		challengerRule = append(challengerRule, challengerItem)
	}
	var taskUidRule []interface{}
	for _, taskUidItem := range taskUid {
		taskUidRule = append(taskUidRule, taskUidItem)
	}

	logs, sub, err := _Collateral.contract.WatchLogs(opts, "DisputeProof", challengerRule, taskUidRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CollateralDisputeProof)
				if err := _Collateral.contract.UnpackLog(event, "DisputeProof", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDisputeProof is a log parse operation binding the contract event 0xaec1d412a3c1e4a13fc2a2e19ac38a5af192a9cf17b074fca8146a2d0655e0c3.
//
// Solidity: event DisputeProof(address indexed challenger, string indexed taskUid)
func (_Collateral *CollateralFilterer) ParseDisputeProof(log types.Log) (*CollateralDisputeProof, error) {
	event := new(CollateralDisputeProof)
	if err := _Collateral.contract.UnpackLog(event, "DisputeProof", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// CollateralInitializedIterator is returned from FilterInitialized and is used to iterate over the raw logs and unpacked data for Initialized events raised by the Collateral contract.
type CollateralInitializedIterator struct {
	Event *CollateralInitialized // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CollateralInitializedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CollateralInitialized)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CollateralInitialized)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CollateralInitializedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CollateralInitializedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CollateralInitialized represents a Initialized event raised by the Collateral contract.
type CollateralInitialized struct {
	Version uint8
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterInitialized is a free log retrieval operation binding the contract event 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498.
//
// Solidity: event Initialized(uint8 version)
func (_Collateral *CollateralFilterer) FilterInitialized(opts *bind.FilterOpts) (*CollateralInitializedIterator, error) {

	logs, sub, err := _Collateral.contract.FilterLogs(opts, "Initialized")
	if err != nil {
		return nil, err
	}
	return &CollateralInitializedIterator{contract: _Collateral.contract, event: "Initialized", logs: logs, sub: sub}, nil
}

// WatchInitialized is a free log subscription operation binding the contract event 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498.
//
// Solidity: event Initialized(uint8 version)
func (_Collateral *CollateralFilterer) WatchInitialized(opts *bind.WatchOpts, sink chan<- *CollateralInitialized) (event.Subscription, error) {

	logs, sub, err := _Collateral.contract.WatchLogs(opts, "Initialized")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CollateralInitialized)
				if err := _Collateral.contract.UnpackLog(event, "Initialized", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInitialized is a log parse operation binding the contract event 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498.
//
// Solidity: event Initialized(uint8 version)
func (_Collateral *CollateralFilterer) ParseInitialized(log types.Log) (*CollateralInitialized, error) {
	event := new(CollateralInitialized)
	if err := _Collateral.contract.UnpackLog(event, "Initialized", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// CollateralOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the Collateral contract.
type CollateralOwnershipTransferredIterator struct {
	Event *CollateralOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CollateralOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CollateralOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CollateralOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CollateralOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CollateralOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CollateralOwnershipTransferred represents a OwnershipTransferred event raised by the Collateral contract.
type CollateralOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_Collateral *CollateralFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*CollateralOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _Collateral.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &CollateralOwnershipTransferredIterator{contract: _Collateral.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_Collateral *CollateralFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *CollateralOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _Collateral.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CollateralOwnershipTransferred)
				if err := _Collateral.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_Collateral *CollateralFilterer) ParseOwnershipTransferred(log types.Log) (*CollateralOwnershipTransferred, error) {
	event := new(CollateralOwnershipTransferred)
	if err := _Collateral.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// CollateralTaskCreatedIterator is returned from FilterTaskCreated and is used to iterate over the raw logs and unpacked data for TaskCreated events raised by the Collateral contract.
type CollateralTaskCreatedIterator struct {
	Event *CollateralTaskCreated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CollateralTaskCreatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CollateralTaskCreated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CollateralTaskCreated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CollateralTaskCreatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CollateralTaskCreatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CollateralTaskCreated represents a TaskCreated event raised by the Collateral contract.
type CollateralTaskCreated struct {
	TaskUid          common.Hash
	CpAccountAddress common.Address
	Collateral       *big.Int
	Raw              types.Log // Blockchain specific contextual infos
}

// FilterTaskCreated is a free log retrieval operation binding the contract event 0x5bebc56a5428fd7b8cf43ed525f03223f8363907fbe44665b7a3426d1de96800.
//
// Solidity: event TaskCreated(string indexed taskUid, address cpAccountAddress, uint256 collateral)
func (_Collateral *CollateralFilterer) FilterTaskCreated(opts *bind.FilterOpts, taskUid []string) (*CollateralTaskCreatedIterator, error) {

	var taskUidRule []interface{}
	for _, taskUidItem := range taskUid {
		taskUidRule = append(taskUidRule, taskUidItem)
	}

	logs, sub, err := _Collateral.contract.FilterLogs(opts, "TaskCreated", taskUidRule)
	if err != nil {
		return nil, err
	}
	return &CollateralTaskCreatedIterator{contract: _Collateral.contract, event: "TaskCreated", logs: logs, sub: sub}, nil
}

// WatchTaskCreated is a free log subscription operation binding the contract event 0x5bebc56a5428fd7b8cf43ed525f03223f8363907fbe44665b7a3426d1de96800.
//
// Solidity: event TaskCreated(string indexed taskUid, address cpAccountAddress, uint256 collateral)
func (_Collateral *CollateralFilterer) WatchTaskCreated(opts *bind.WatchOpts, sink chan<- *CollateralTaskCreated, taskUid []string) (event.Subscription, error) {

	var taskUidRule []interface{}
	for _, taskUidItem := range taskUid {
		taskUidRule = append(taskUidRule, taskUidItem)
	}

	logs, sub, err := _Collateral.contract.WatchLogs(opts, "TaskCreated", taskUidRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CollateralTaskCreated)
				if err := _Collateral.contract.UnpackLog(event, "TaskCreated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTaskCreated is a log parse operation binding the contract event 0x5bebc56a5428fd7b8cf43ed525f03223f8363907fbe44665b7a3426d1de96800.
//
// Solidity: event TaskCreated(string indexed taskUid, address cpAccountAddress, uint256 collateral)
func (_Collateral *CollateralFilterer) ParseTaskCreated(log types.Log) (*CollateralTaskCreated, error) {
	event := new(CollateralTaskCreated)
	if err := _Collateral.contract.UnpackLog(event, "TaskCreated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// CollateralUpgradedIterator is returned from FilterUpgraded and is used to iterate over the raw logs and unpacked data for Upgraded events raised by the Collateral contract.
type CollateralUpgradedIterator struct {
	Event *CollateralUpgraded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CollateralUpgradedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CollateralUpgraded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CollateralUpgraded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CollateralUpgradedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CollateralUpgradedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CollateralUpgraded represents a Upgraded event raised by the Collateral contract.
type CollateralUpgraded struct {
	Implementation common.Address
	Raw            types.Log // Blockchain specific contextual infos
}

// FilterUpgraded is a free log retrieval operation binding the contract event 0xbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b.
//
// Solidity: event Upgraded(address indexed implementation)
func (_Collateral *CollateralFilterer) FilterUpgraded(opts *bind.FilterOpts, implementation []common.Address) (*CollateralUpgradedIterator, error) {

	var implementationRule []interface{}
	for _, implementationItem := range implementation {
		implementationRule = append(implementationRule, implementationItem)
	}

	logs, sub, err := _Collateral.contract.FilterLogs(opts, "Upgraded", implementationRule)
	if err != nil {
		return nil, err
	}
	return &CollateralUpgradedIterator{contract: _Collateral.contract, event: "Upgraded", logs: logs, sub: sub}, nil
}

// WatchUpgraded is a free log subscription operation binding the contract event 0xbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b.
//
// Solidity: event Upgraded(address indexed implementation)
func (_Collateral *CollateralFilterer) WatchUpgraded(opts *bind.WatchOpts, sink chan<- *CollateralUpgraded, implementation []common.Address) (event.Subscription, error) {

	var implementationRule []interface{}
	for _, implementationItem := range implementation {
		implementationRule = append(implementationRule, implementationItem)
	}

	logs, sub, err := _Collateral.contract.WatchLogs(opts, "Upgraded", implementationRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CollateralUpgraded)
				if err := _Collateral.contract.UnpackLog(event, "Upgraded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUpgraded is a log parse operation binding the contract event 0xbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b.
//
// Solidity: event Upgraded(address indexed implementation)
func (_Collateral *CollateralFilterer) ParseUpgraded(log types.Log) (*CollateralUpgraded, error) {
	event := new(CollateralUpgraded)
	if err := _Collateral.contract.UnpackLog(event, "Upgraded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// CollateralWithdrawIterator is returned from FilterWithdraw and is used to iterate over the raw logs and unpacked data for Withdraw events raised by the Collateral contract.
type CollateralWithdrawIterator struct {
	Event *CollateralWithdraw // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CollateralWithdrawIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CollateralWithdraw)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CollateralWithdraw)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CollateralWithdrawIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CollateralWithdrawIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CollateralWithdraw represents a Withdraw event raised by the Collateral contract.
type CollateralWithdraw struct {
	CpOwner        common.Address
	CpAccount      common.Address
	WithdrawAmount *big.Int
	Raw            types.Log // Blockchain specific contextual infos
}

// FilterWithdraw is a free log retrieval operation binding the contract event 0x9b1bfa7fa9ee420a16e124f794c35ac9f90472acc99140eb2f6447c714cad8eb.
//
// Solidity: event Withdraw(address indexed cpOwner, address indexed cpAccount, uint256 withdrawAmount)
func (_Collateral *CollateralFilterer) FilterWithdraw(opts *bind.FilterOpts, cpOwner []common.Address, cpAccount []common.Address) (*CollateralWithdrawIterator, error) {

	var cpOwnerRule []interface{}
	for _, cpOwnerItem := range cpOwner {
		cpOwnerRule = append(cpOwnerRule, cpOwnerItem)
	}
	var cpAccountRule []interface{}
	for _, cpAccountItem := range cpAccount {
		cpAccountRule = append(cpAccountRule, cpAccountItem)
	}

	logs, sub, err := _Collateral.contract.FilterLogs(opts, "Withdraw", cpOwnerRule, cpAccountRule)
	if err != nil {
		return nil, err
	}
	return &CollateralWithdrawIterator{contract: _Collateral.contract, event: "Withdraw", logs: logs, sub: sub}, nil
}

// WatchWithdraw is a free log subscription operation binding the contract event 0x9b1bfa7fa9ee420a16e124f794c35ac9f90472acc99140eb2f6447c714cad8eb.
//
// Solidity: event Withdraw(address indexed cpOwner, address indexed cpAccount, uint256 withdrawAmount)
func (_Collateral *CollateralFilterer) WatchWithdraw(opts *bind.WatchOpts, sink chan<- *CollateralWithdraw, cpOwner []common.Address, cpAccount []common.Address) (event.Subscription, error) {

	var cpOwnerRule []interface{}
	for _, cpOwnerItem := range cpOwner {
		cpOwnerRule = append(cpOwnerRule, cpOwnerItem)
	}
	var cpAccountRule []interface{}
	for _, cpAccountItem := range cpAccount {
		cpAccountRule = append(cpAccountRule, cpAccountItem)
	}

	logs, sub, err := _Collateral.contract.WatchLogs(opts, "Withdraw", cpOwnerRule, cpAccountRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CollateralWithdraw)
				if err := _Collateral.contract.UnpackLog(event, "Withdraw", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseWithdraw is a log parse operation binding the contract event 0x9b1bfa7fa9ee420a16e124f794c35ac9f90472acc99140eb2f6447c714cad8eb.
//
// Solidity: event Withdraw(address indexed cpOwner, address indexed cpAccount, uint256 withdrawAmount)
func (_Collateral *CollateralFilterer) ParseWithdraw(log types.Log) (*CollateralWithdraw, error) {
	event := new(CollateralWithdraw)
	if err := _Collateral.contract.UnpackLog(event, "Withdraw", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// CollateralWithdrawSlashIterator is returned from FilterWithdrawSlash and is used to iterate over the raw logs and unpacked data for WithdrawSlash events raised by the Collateral contract.
type CollateralWithdrawSlashIterator struct {
	Event *CollateralWithdrawSlash // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CollateralWithdrawSlashIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CollateralWithdrawSlash)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CollateralWithdrawSlash)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CollateralWithdrawSlashIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CollateralWithdrawSlashIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CollateralWithdrawSlash represents a WithdrawSlash event raised by the Collateral contract.
type CollateralWithdrawSlash struct {
	CollateralContratOwner common.Address
	Slashfund              *big.Int
	Raw                    types.Log // Blockchain specific contextual infos
}

// FilterWithdrawSlash is a free log retrieval operation binding the contract event 0xbfd9c82485e2178fcfd5c40379d8e66fe60acc50aa1ef4c50966431eb1e381cd.
//
// Solidity: event WithdrawSlash(address indexed collateralContratOwner, uint256 slashfund)
func (_Collateral *CollateralFilterer) FilterWithdrawSlash(opts *bind.FilterOpts, collateralContratOwner []common.Address) (*CollateralWithdrawSlashIterator, error) {

	var collateralContratOwnerRule []interface{}
	for _, collateralContratOwnerItem := range collateralContratOwner {
		collateralContratOwnerRule = append(collateralContratOwnerRule, collateralContratOwnerItem)
	}

	logs, sub, err := _Collateral.contract.FilterLogs(opts, "WithdrawSlash", collateralContratOwnerRule)
	if err != nil {
		return nil, err
	}
	return &CollateralWithdrawSlashIterator{contract: _Collateral.contract, event: "WithdrawSlash", logs: logs, sub: sub}, nil
}

// WatchWithdrawSlash is a free log subscription operation binding the contract event 0xbfd9c82485e2178fcfd5c40379d8e66fe60acc50aa1ef4c50966431eb1e381cd.
//
// Solidity: event WithdrawSlash(address indexed collateralContratOwner, uint256 slashfund)
func (_Collateral *CollateralFilterer) WatchWithdrawSlash(opts *bind.WatchOpts, sink chan<- *CollateralWithdrawSlash, collateralContratOwner []common.Address) (event.Subscription, error) {

	var collateralContratOwnerRule []interface{}
	for _, collateralContratOwnerItem := range collateralContratOwner {
		collateralContratOwnerRule = append(collateralContratOwnerRule, collateralContratOwnerItem)
	}

	logs, sub, err := _Collateral.contract.WatchLogs(opts, "WithdrawSlash", collateralContratOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CollateralWithdrawSlash)
				if err := _Collateral.contract.UnpackLog(event, "WithdrawSlash", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseWithdrawSlash is a log parse operation binding the contract event 0xbfd9c82485e2178fcfd5c40379d8e66fe60acc50aa1ef4c50966431eb1e381cd.
//
// Solidity: event WithdrawSlash(address indexed collateralContratOwner, uint256 slashfund)
func (_Collateral *CollateralFilterer) ParseWithdrawSlash(log types.Log) (*CollateralWithdrawSlash, error) {
	event := new(CollateralWithdrawSlash)
	if err := _Collateral.contract.UnpackLog(event, "WithdrawSlash", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}
