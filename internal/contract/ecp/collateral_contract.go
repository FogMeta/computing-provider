// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package ecp

import (
	"errors"
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
	_ = abi.ConvertType
)

// ECPCollateralCPInfo is an auto generated low-level Go binding around an user-defined struct.
type ECPCollateralCPInfo struct {
	Cp            common.Address
	Balance       *big.Int
	FrozenBalance *big.Int
	Status        string
}

// ECPCollateralContractInfo is an auto generated low-level Go binding around an user-defined struct.
type ECPCollateralContractInfo struct {
	SlashedFunds    *big.Int
	BaseCollateral  *big.Int
	TaskBalance     *big.Int
	CollateralRatio *big.Int
	SlashRatio      *big.Int
}

// ECPCollateralTask is an auto generated low-level Go binding around an user-defined struct.
type ECPCollateralTask struct {
	CpAccountAddress common.Address
	Collateral       *big.Int
	Status           *big.Int
}

// EcpCollateralMetaData contains all meta data concerning the EcpCollateral contract.
var EcpCollateralMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"cp\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"frozenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balanceAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"operation\",\"type\":\"string\"}],\"name\":\"CollateralAdjusted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"cp\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"taskID\",\"type\":\"uint256\"}],\"name\":\"CollateralLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"cp\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"taskID\",\"type\":\"uint256\"}],\"name\":\"CollateralSlashed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"cp\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"taskID\",\"type\":\"uint256\"}],\"name\":\"CollateralUnlocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fundingWallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"cpAccount\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"challenger\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"taskContractAddress\",\"type\":\"address\"}],\"name\":\"DisputeProof\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"taskID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"cpAccountAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"}],\"name\":\"TaskCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"taskID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newStatus\",\"type\":\"uint256\"}],\"name\":\"TaskStatusChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"cpOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"cpAccount\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collateralContratOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"slashfund\",\"type\":\"uint256\"}],\"name\":\"WithdrawSlash\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"cpAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"taskIDs\",\"type\":\"uint256[]\"}],\"name\":\"batchLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"taskIDs\",\"type\":\"uint256[]\"}],\"name\":\"batchSlash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"taskIDs\",\"type\":\"uint256[]\"}],\"name\":\"batchUnlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collateralRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collateralToken\",\"outputs\":[{\"internalType\":\"contractIERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cpAddress\",\"type\":\"address\"}],\"name\":\"cpInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"cp\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"balance\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"frozenBalance\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"status\",\"type\":\"string\"}],\"internalType\":\"structECPCollateral.CPInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"cpStatus\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cpAccount\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"taskContractAddress\",\"type\":\"address\"}],\"name\":\"disputeProof\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"frozenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBaseCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getECPCollateralInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"slashedFunds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"taskBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slashRatio\",\"type\":\"uint256\"}],\"internalType\":\"structECPCollateral.ContractInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"taskID\",\"type\":\"uint256\"}],\"name\":\"getTaskInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"cpAccountAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"}],\"internalType\":\"structECPCollateral.Task\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cp\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"taskID\",\"type\":\"uint256\"}],\"name\":\"lockCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"removeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_baseCollateral\",\"type\":\"uint256\"}],\"name\":\"setBaseCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_collateralRatio\",\"type\":\"uint256\"}],\"name\":\"setCollateralRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"setCollateralToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_slashRatio\",\"type\":\"uint256\"}],\"name\":\"setSlashRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"taskID\",\"type\":\"uint256\"}],\"name\":\"slashCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"slashRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"slashedFunds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taskBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tasks\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"cpAccountAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"taskID\",\"type\":\"uint256\"}],\"name\":\"unlockCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cpAccount\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"slashfund\",\"type\":\"uint256\"}],\"name\":\"withdrawSlashedFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x60806040523480156200001157600080fd5b506200003262000026620000b060201b60201c565b620000b860201b60201c565b6200004333620000b860201b60201c565b6001600760003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff0219169083151502179055506005808190555060026006819055506200017c565b600033905090565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050816000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b613690806200018c6000396000f3fe608060405234801561001057600080fd5b50600436106102065760003560e01c806370b729441161011a578063b2016bd4116100ad578063d27ca89b1161007c578063d27ca89b146105c1578063de2b2f53146105df578063f2fde38b146105fb578063f31cc88314610617578063f3fef3a31461063557610206565b8063b2016bd414610539578063b4eae1cb14610557578063ce3518aa14610575578063d1a1b9991461059157610206565b80638da5cb5b116100e95780638da5cb5b146104af5780639939cd18146104cd5780639b5ddf09146104eb578063a664c2161461050957610206565b806370b7294414610439578063715018a6146104575780637f58a7e5146104615780638d9776721461047d57610206565b806343a8906c1161019d5780636060663e1161016c5780636060663e146103ab57806363215bb7146103c7578063666181a9146103e35780636f99f15c146103ff578063704802751461041d57610206565b806343a8906c1461033b57806347a7d1071461035757806347e7ef24146103735780634a82942c1461038f57610206565b806327e235e3116101d957806327e235e3146102a35780632894493f146102d35780633fe65177146102ef578063436ea4911461031f57610206565b80630fcc834e1461020b5780631785f53c1461022757806324d7806c14610243578063266565a914610273575b600080fd5b6102256004803603810190610220919061241f565b610651565b005b610241600480360381019061023c91906124aa565b61095f565b005b61025d600480360381019061025891906124aa565b6109c2565b60405161026a91906124f2565b60405180910390f35b61028d600480360381019061028891906124aa565b6109e2565b60405161029a919061251c565b60405180910390f35b6102bd60048036038101906102b891906124aa565b6109fa565b6040516102ca9190612550565b60405180910390f35b6102ed60048036038101906102e8919061241f565b610a12565b005b610309600480360381019061030491906124aa565b610b6a565b60405161031691906125fb565b60405180910390f35b61033960048036038101906103349190612682565b610c0a565b005b610355600480360381019061035091906124aa565b610cde565b005b610371600480360381019061036c91906126cf565b610d3b565b005b61038d600480360381019061038891906126cf565b611044565b005b6103a960048036038101906103a49190612682565b6111af565b005b6103c560048036038101906103c0919061241f565b611283565b005b6103e160048036038101906103dc9190612765565b611295565b005b6103fd60048036038101906103f891906124aa565b6113db565b005b610407611427565b604051610414919061251c565b60405180910390f35b610437600480360381019061043291906124aa565b61142d565b005b610441611490565b60405161044e919061251c565b60405180910390f35b61045f61149a565b005b61047b6004803603810190610476919061241f565b6114ae565b005b6104976004803603810190610492919061241f565b611544565b6040516104a6939291906127f5565b60405180910390f35b6104b761158e565b6040516104c4919061282c565b60405180910390f35b6104d56115b7565b6040516104e291906128be565b60405180910390f35b6104f36115f5565b604051610500919061251c565b60405180910390f35b610523600480360381019061051e91906124aa565b6115fb565b60405161053091906129a4565b60405180910390f35b610541611786565b60405161054e9190612a25565b60405180910390f35b61055f6117ac565b60405161056c919061251c565b60405180910390f35b61058f600480360381019061058a919061241f565b6117b2565b005b6105ab60048036038101906105a6919061241f565b6117c4565b6040516105b89190612a82565b60405180910390f35b6105c961185b565b6040516105d6919061251c565b60405180910390f35b6105f960048036038101906105f4919061241f565b611861565b005b610615600480360381019061061091906124aa565b611c61565b005b61061f611ce4565b60405161062c919061251c565b60405180910390f35b61064f600480360381019061064a91906126cf565b611cea565b005b600760003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff166106dd576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016106d490612b0f565b60405180910390fd5b6000600a600083815260200190815260200160002090506000600960008360000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050600081836001015411610773578260010154610775565b815b905080600960008560000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546107ea9190612b5e565b9250508190555080600860008560000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546108649190612b92565b9250508190555060008360010181905550600283600201819055506108ac8360000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1661208f565b8260000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff167fe8e7440c7efbb5d2d20a061fde9c0fa35db9764f5da8475a0090ea4f23466c848286604051610918929190612bd6565b60405180910390a2837f857a475dc812e506ac81a9f3ffc00638593b96a880e2543da02a1a6b38f51f396002604051610951919061251c565b60405180910390a250505050565b6109676121f1565b6000600760008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff02191690831515021790555050565b60076020528060005260406000206000915054906101000a900460ff1681565b60096020528060005260406000206000915090505481565b60086020528060005260406000206000915090505481565b610a1a6121f1565b806002541015610a5f576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610a5690612c71565b60405180910390fd5b8060026000828254610a719190612b5e565b92505081905550600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb33836040518363ffffffff1660e01b8152600401610ad5929190612c91565b6020604051808303816000875af1158015610af4573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b189190612ce6565b503373ffffffffffffffffffffffffffffffffffffffff167fbfd9c82485e2178fcfd5c40379d8e66fe60acc50aa1ef4c50966431eb1e381cd82604051610b5f919061251c565b60405180910390a250565b600b6020528060005260406000206000915090508054610b8990612d42565b80601f0160208091040260200160405190810160405280929190818152602001828054610bb590612d42565b8015610c025780601f10610bd757610100808354040283529160200191610c02565b820191906000526020600020905b815481529060010190602001808311610be557829003601f168201915b505050505081565b600760003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff16610c96576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610c8d90612b0f565b60405180910390fd5b60005b82829050811015610cd957610cc6838383818110610cba57610cb9612d73565b5b90506020020135611861565b8080610cd190612da2565b915050610c99565b505050565b8073ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f1e61a07012c23d5019cb79991ed79d73a9fc17fb89182f5830f036bd544423f360405160405180910390a350565b600760003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff16610dc7576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610dbe90612b0f565b60405180910390fd5b6000600354600554610dd99190612dea565b905080600860008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541215610e5d576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610e5490612e9e565b60405180910390fd5b80600860008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254610eac9190612ebe565b9250508190555080600960008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254610f029190612f01565b9250508190555060405180606001604052808473ffffffffffffffffffffffffffffffffffffffff1681526020018281526020016001815250600a600084815260200190815260200160002060008201518160000160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506020820151816001015560408201518160020155905050610fb58361208f565b8273ffffffffffffffffffffffffffffffffffffffff167faff82f4178df227ea409be11c927e414a908fb01481236913cec80ea866b24688284604051610ffd929190612bd6565b60405180910390a2817f6cf53aa7292e664152c2ea948c3b3c95d4b05c36daeb2626d0293473c4a4a1538483604051611037929190612c91565b60405180910390a2505050565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd3330846040518463ffffffff1660e01b81526004016110a393929190612f35565b6020604051808303816000875af11580156110c2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110e69190612ce6565b5080600860008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546111369190612b92565b925050819055508173ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f5548c837ab068cf56a2c2479df0882a4922fd203edb7517321831d95078c5f628360405161119a919061251c565b60405180910390a36111ab8261208f565b5050565b600760003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff1661123b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161123290612b0f565b60405180910390fd5b60005b8282905081101561127e5761126b83838381811061125f5761125e612d73565b5b90506020020135610651565b808061127690612da2565b91505061123e565b505050565b61128b6121f1565b8060058190555050565b600760003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff16611321576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161131890612b0f565b60405180910390fd5b818190508484905014611369576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161136090612fb8565b60405180910390fd5b60005b848490508110156113d4576113c185858381811061138d5761138c612d73565b5b90506020020160208101906113a291906124aa565b8484848181106113b5576113b4612d73565b5b90506020020135610d3b565b80806113cc90612da2565b91505061136c565b5050505050565b6113e36121f1565b80600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b60025481565b6114356121f1565b6001600760008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff02191690831515021790555050565b6000600354905090565b6114a26121f1565b6114ac600061226f565b565b600760003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff1661153a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161153190612b0f565b60405180910390fd5b8060038190555050565b600a6020528060005260406000206000915090508060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16908060010154908060020154905083565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b6115bf61233b565b6040518060a001604052806002548152602001600354815260200160045481526020016005548152602001600654815250905090565b60035481565b61160361236a565b60405180608001604052808373ffffffffffffffffffffffffffffffffffffffff168152602001600860008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020548152602001600960008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020548152602001600b60008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002080546116fe90612d42565b80601f016020809104026020016040519081016040528092919081815260200182805461172a90612d42565b80156117775780601f1061174c57610100808354040283529160200191611777565b820191906000526020600020905b81548152906001019060200180831161175a57829003601f168201915b50505050508152509050919050565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b60055481565b6117ba6121f1565b8060068190555050565b6117cc6123a8565b600a60008381526020019081526020016000206040518060600160405290816000820160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600182015481526020016002820154815250509050919050565b60065481565b600760003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff166118ed576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016118e490612b0f565b60405180910390fd5b6000600a6000838152602001908152602001600020905060006006546003546119169190612dea565b90506000600960008460000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050600081831161198f5782611991565b815b905060008184116119a35760006119b0565b81846119af9190612b5e565b5b905081600960008760000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254611a259190612b5e565b9250508190555080600860008760000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254611a9f9190612ebe565b925050819055508360026000828254611ab89190612f01565b925050819055506003856002018190555083856001015411611adb576000611aec565b838560010154611aeb9190612b5e565b5b8560010181905550611b218560000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1661208f565b8460000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff167fe23e4a65e8f09c2d92bbdfbe613a6007e35677ac2afed7f4eb690b5b93460bd98588604051611b8d929190612bd6565b60405180910390a2857f857a475dc812e506ac81a9f3ffc00638593b96a880e2543da02a1a6b38f51f396003604051611bc6919061251c565b60405180910390a28460000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff167f42f1a8a1aee108e84e4eabfaa8d51d7baaa1a02d482295297883a44b2debd3e48383604051611c3a929190613024565b60405180910390a2600085600101541115611c5957611c5886610651565b5b505050505050565b611c696121f1565b600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603611cd8576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611ccf906130d2565b60405180910390fd5b611ce18161226f565b50565b60045481565b6000808373ffffffffffffffffffffffffffffffffffffffff166040516024016040516020818303038152906040527f893d20e8000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050604051611d949190613139565b6000604051808303816000865af19150503d8060008114611dd1576040519150601f19603f3d011682016040523d82523d6000602084013e611dd6565b606091505b509150915081611e1b576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611e12906131c2565b60405180910390fd5b600081806020019051810190611e319190613220565b905083600860008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541215611eb5576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611eac90613299565b60405180910390fd5b8073ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614611f23576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611f1a9061332b565b60405180910390fd5b83600860008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254611f729190612ebe565b92505081905550600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb33866040518363ffffffff1660e01b8152600401611fd6929190612c91565b6020604051808303816000875af1158015611ff5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906120199190612ce6565b506120238561208f565b8473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f9b1bfa7fa9ee420a16e124f794c35ac9f90472acc99140eb2f6447c714cad8eb86604051612080919061251c565b60405180910390a35050505050565b60035460055461209f9190612dea565b600860008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541261216b576040518060400160405280600981526020017f7a6b41756374696f6e0000000000000000000000000000000000000000000000815250600b60008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000209081612165919061351c565b506121ee565b6040518060400160405280600381526020017f4e53430000000000000000000000000000000000000000000000000000000000815250600b60008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090816121ec919061351c565b505b50565b6121f9612333565b73ffffffffffffffffffffffffffffffffffffffff1661221761158e565b73ffffffffffffffffffffffffffffffffffffffff161461226d576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016122649061363a565b60405180910390fd5b565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050816000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b600033905090565b6040518060a0016040528060008152602001600081526020016000815260200160008152602001600081525090565b6040518060800160405280600073ffffffffffffffffffffffffffffffffffffffff1681526020016000815260200160008152602001606081525090565b6040518060600160405280600073ffffffffffffffffffffffffffffffffffffffff16815260200160008152602001600081525090565b600080fd5b600080fd5b6000819050919050565b6123fc816123e9565b811461240757600080fd5b50565b600081359050612419816123f3565b92915050565b600060208284031215612435576124346123df565b5b60006124438482850161240a565b91505092915050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006124778261244c565b9050919050565b6124878161246c565b811461249257600080fd5b50565b6000813590506124a48161247e565b92915050565b6000602082840312156124c0576124bf6123df565b5b60006124ce84828501612495565b91505092915050565b60008115159050919050565b6124ec816124d7565b82525050565b600060208201905061250760008301846124e3565b92915050565b612516816123e9565b82525050565b6000602082019050612531600083018461250d565b92915050565b6000819050919050565b61254a81612537565b82525050565b60006020820190506125656000830184612541565b92915050565b600081519050919050565b600082825260208201905092915050565b60005b838110156125a557808201518184015260208101905061258a565b60008484015250505050565b6000601f19601f8301169050919050565b60006125cd8261256b565b6125d78185612576565b93506125e7818560208601612587565b6125f0816125b1565b840191505092915050565b6000602082019050818103600083015261261581846125c2565b905092915050565b600080fd5b600080fd5b600080fd5b60008083601f8401126126425761264161261d565b5b8235905067ffffffffffffffff81111561265f5761265e612622565b5b60208301915083602082028301111561267b5761267a612627565b5b9250929050565b60008060208385031215612699576126986123df565b5b600083013567ffffffffffffffff8111156126b7576126b66123e4565b5b6126c38582860161262c565b92509250509250929050565b600080604083850312156126e6576126e56123df565b5b60006126f485828601612495565b92505060206127058582860161240a565b9150509250929050565b60008083601f8401126127255761272461261d565b5b8235905067ffffffffffffffff81111561274257612741612622565b5b60208301915083602082028301111561275e5761275d612627565b5b9250929050565b6000806000806040858703121561277f5761277e6123df565b5b600085013567ffffffffffffffff81111561279d5761279c6123e4565b5b6127a98782880161270f565b9450945050602085013567ffffffffffffffff8111156127cc576127cb6123e4565b5b6127d88782880161262c565b925092505092959194509250565b6127ef8161246c565b82525050565b600060608201905061280a60008301866127e6565b612817602083018561250d565b612824604083018461250d565b949350505050565b600060208201905061284160008301846127e6565b92915050565b612850816123e9565b82525050565b60a08201600082015161286c6000850182612847565b50602082015161287f6020850182612847565b5060408201516128926040850182612847565b5060608201516128a56060850182612847565b5060808201516128b86080850182612847565b50505050565b600060a0820190506128d36000830184612856565b92915050565b6128e28161246c565b82525050565b6128f181612537565b82525050565b600082825260208201905092915050565b60006129138261256b565b61291d81856128f7565b935061292d818560208601612587565b612936816125b1565b840191505092915050565b600060808301600083015161295960008601826128d9565b50602083015161296c60208601826128e8565b50604083015161297f6040860182612847565b50606083015184820360608601526129978282612908565b9150508091505092915050565b600060208201905081810360008301526129be8184612941565b905092915050565b6000819050919050565b60006129eb6129e66129e18461244c565b6129c6565b61244c565b9050919050565b60006129fd826129d0565b9050919050565b6000612a0f826129f2565b9050919050565b612a1f81612a04565b82525050565b6000602082019050612a3a6000830184612a16565b92915050565b606082016000820151612a5660008501826128d9565b506020820151612a696020850182612847565b506040820151612a7c6040850182612847565b50505050565b6000606082019050612a976000830184612a40565b92915050565b7f4f6e6c79207468652061646d696e2063616e2063616c6c20746869732066756e60008201527f6374696f6e2e0000000000000000000000000000000000000000000000000000602082015250565b6000612af9602683612576565b9150612b0482612a9d565b604082019050919050565b60006020820190508181036000830152612b2881612aec565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000612b69826123e9565b9150612b74836123e9565b9250828203905081811115612b8c57612b8b612b2f565b5b92915050565b6000612b9d82612537565b9150612ba883612537565b925082820190508281121560008312168382126000841215161715612bd057612bcf612b2f565b5b92915050565b6000604082019050612beb600083018561250d565b612bf8602083018461250d565b9392505050565b7f576974686472617720736c61736866756e6420616d6f756e742065786365656460008201527f7320736c617368656446756e6473000000000000000000000000000000000000602082015250565b6000612c5b602e83612576565b9150612c6682612bff565b604082019050919050565b60006020820190508181036000830152612c8a81612c4e565b9050919050565b6000604082019050612ca660008301856127e6565b612cb3602083018461250d565b9392505050565b612cc3816124d7565b8114612cce57600080fd5b50565b600081519050612ce081612cba565b92915050565b600060208284031215612cfc57612cfb6123df565b5b6000612d0a84828501612cd1565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b60006002820490506001821680612d5a57607f821691505b602082108103612d6d57612d6c612d13565b5b50919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b6000612dad826123e9565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203612ddf57612dde612b2f565b5b600182019050919050565b6000612df5826123e9565b9150612e00836123e9565b9250828202612e0e816123e9565b91508282048414831517612e2557612e24612b2f565b5b5092915050565b7f4e6f7420656e6f7567682062616c616e636520666f7220636f6c6c617465726160008201527f6c00000000000000000000000000000000000000000000000000000000000000602082015250565b6000612e88602183612576565b9150612e9382612e2c565b604082019050919050565b60006020820190508181036000830152612eb781612e7b565b9050919050565b6000612ec982612537565b9150612ed483612537565b9250828203905081811260008412168282136000851215161715612efb57612efa612b2f565b5b92915050565b6000612f0c826123e9565b9150612f17836123e9565b9250828201905080821115612f2f57612f2e612b2f565b5b92915050565b6000606082019050612f4a60008301866127e6565b612f5760208301856127e6565b612f64604083018461250d565b949350505050565b7f4172726179206c656e67746873206d757374206d617463680000000000000000600082015250565b6000612fa2601883612576565b9150612fad82612f6c565b602082019050919050565b60006020820190508181036000830152612fd181612f95565b9050919050565b7f536c617368656400000000000000000000000000000000000000000000000000600082015250565b600061300e600783612576565b915061301982612fd8565b602082019050919050565b6000606082019050613039600083018561250d565b613046602083018461250d565b818103604083015261305781613001565b90509392505050565b7f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160008201527f6464726573730000000000000000000000000000000000000000000000000000602082015250565b60006130bc602683612576565b91506130c782613060565b604082019050919050565b600060208201905081810360008301526130eb816130af565b9050919050565b600081519050919050565b600081905092915050565b6000613113826130f2565b61311d81856130fd565b935061312d818560208601612587565b80840191505092915050565b60006131458284613108565b915081905092915050565b7f4661696c656420746f2063616c6c206765744f776e65722066756e6374696f6e60008201527f206f662043504163636f756e7400000000000000000000000000000000000000602082015250565b60006131ac602d83612576565b91506131b782613150565b604082019050919050565b600060208201905081810360008301526131db8161319f565b9050919050565b60006131ed8261244c565b9050919050565b6131fd816131e2565b811461320857600080fd5b50565b60008151905061321a816131f4565b92915050565b600060208284031215613236576132356123df565b5b60006132448482850161320b565b91505092915050565b7f576974686472617720616d6f756e7420657863656564732062616c616e636500600082015250565b6000613283601f83612576565b915061328e8261324d565b602082019050919050565b600060208201905081810360008301526132b281613276565b9050919050565b7f4f6e6c792043502773206f776e65722063616e2077697468647261772074686560008201527f20636f6c6c61746572616c2066756e6473000000000000000000000000000000602082015250565b6000613315603183612576565b9150613320826132b9565b604082019050919050565b6000602082019050818103600083015261334481613308565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b60008190508160005260206000209050919050565b60006020601f8301049050919050565b600082821b905092915050565b6000600883026133dc7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8261339f565b6133e6868361339f565b95508019841693508086168417925050509392505050565b600061341961341461340f846123e9565b6129c6565b6123e9565b9050919050565b6000819050919050565b613433836133fe565b61344761343f82613420565b8484546133ac565b825550505050565b600090565b61345c61344f565b61346781848461342a565b505050565b5b8181101561348b57613480600082613454565b60018101905061346d565b5050565b601f8211156134d0576134a18161337a565b6134aa8461338f565b810160208510156134b9578190505b6134cd6134c58561338f565b83018261346c565b50505b505050565b600082821c905092915050565b60006134f3600019846008026134d5565b1980831691505092915050565b600061350c83836134e2565b9150826002028217905092915050565b6135258261256b565b67ffffffffffffffff81111561353e5761353d61334b565b5b6135488254612d42565b61355382828561348f565b600060209050601f8311600181146135865760008415613574578287015190505b61357e8582613500565b8655506135e6565b601f1984166135948661337a565b60005b828110156135bc57848901518255600182019150602085019450602081019050613597565b868310156135d957848901516135d5601f8916826134e2565b8355505b6001600288020188555050505b505050505050565b7f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572600082015250565b6000613624602083612576565b915061362f826135ee565b602082019050919050565b6000602082019050818103600083015261365381613617565b905091905056fea2646970667358221220a840337d516158e696eda13f7bf987f60e101238fe6552b2827a47c95f1de9d564736f6c63430008140033",
}

// EcpCollateralABI is the input ABI used to generate the binding from.
// Deprecated: Use EcpCollateralMetaData.ABI instead.
var EcpCollateralABI = EcpCollateralMetaData.ABI

// EcpCollateralBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use EcpCollateralMetaData.Bin instead.
var EcpCollateralBin = EcpCollateralMetaData.Bin

// DeployEcpCollateral deploys a new Ethereum contract, binding an instance of EcpCollateral to it.
func DeployEcpCollateral(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *EcpCollateral, error) {
	parsed, err := EcpCollateralMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(EcpCollateralBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &EcpCollateral{EcpCollateralCaller: EcpCollateralCaller{contract: contract}, EcpCollateralTransactor: EcpCollateralTransactor{contract: contract}, EcpCollateralFilterer: EcpCollateralFilterer{contract: contract}}, nil
}

// EcpCollateral is an auto generated Go binding around an Ethereum contract.
type EcpCollateral struct {
	EcpCollateralCaller     // Read-only binding to the contract
	EcpCollateralTransactor // Write-only binding to the contract
	EcpCollateralFilterer   // Log filterer for contract events
}

// EcpCollateralCaller is an auto generated read-only Go binding around an Ethereum contract.
type EcpCollateralCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// EcpCollateralTransactor is an auto generated write-only Go binding around an Ethereum contract.
type EcpCollateralTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// EcpCollateralFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type EcpCollateralFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// EcpCollateralSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type EcpCollateralSession struct {
	Contract     *EcpCollateral    // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// EcpCollateralCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type EcpCollateralCallerSession struct {
	Contract *EcpCollateralCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts        // Call options to use throughout this session
}

// EcpCollateralTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type EcpCollateralTransactorSession struct {
	Contract     *EcpCollateralTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts        // Transaction auth options to use throughout this session
}

// EcpCollateralRaw is an auto generated low-level Go binding around an Ethereum contract.
type EcpCollateralRaw struct {
	Contract *EcpCollateral // Generic contract binding to access the raw methods on
}

// EcpCollateralCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type EcpCollateralCallerRaw struct {
	Contract *EcpCollateralCaller // Generic read-only contract binding to access the raw methods on
}

// EcpCollateralTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type EcpCollateralTransactorRaw struct {
	Contract *EcpCollateralTransactor // Generic write-only contract binding to access the raw methods on
}

// NewEcpCollateral creates a new instance of EcpCollateral, bound to a specific deployed contract.
func NewEcpCollateral(address common.Address, backend bind.ContractBackend) (*EcpCollateral, error) {
	contract, err := bindEcpCollateral(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &EcpCollateral{EcpCollateralCaller: EcpCollateralCaller{contract: contract}, EcpCollateralTransactor: EcpCollateralTransactor{contract: contract}, EcpCollateralFilterer: EcpCollateralFilterer{contract: contract}}, nil
}

// NewEcpCollateralCaller creates a new read-only instance of EcpCollateral, bound to a specific deployed contract.
func NewEcpCollateralCaller(address common.Address, caller bind.ContractCaller) (*EcpCollateralCaller, error) {
	contract, err := bindEcpCollateral(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &EcpCollateralCaller{contract: contract}, nil
}

// NewEcpCollateralTransactor creates a new write-only instance of EcpCollateral, bound to a specific deployed contract.
func NewEcpCollateralTransactor(address common.Address, transactor bind.ContractTransactor) (*EcpCollateralTransactor, error) {
	contract, err := bindEcpCollateral(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &EcpCollateralTransactor{contract: contract}, nil
}

// NewEcpCollateralFilterer creates a new log filterer instance of EcpCollateral, bound to a specific deployed contract.
func NewEcpCollateralFilterer(address common.Address, filterer bind.ContractFilterer) (*EcpCollateralFilterer, error) {
	contract, err := bindEcpCollateral(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &EcpCollateralFilterer{contract: contract}, nil
}

// bindEcpCollateral binds a generic wrapper to an already deployed contract.
func bindEcpCollateral(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := EcpCollateralMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_EcpCollateral *EcpCollateralRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _EcpCollateral.Contract.EcpCollateralCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_EcpCollateral *EcpCollateralRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _EcpCollateral.Contract.EcpCollateralTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_EcpCollateral *EcpCollateralRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _EcpCollateral.Contract.EcpCollateralTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_EcpCollateral *EcpCollateralCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _EcpCollateral.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_EcpCollateral *EcpCollateralTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _EcpCollateral.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_EcpCollateral *EcpCollateralTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _EcpCollateral.Contract.contract.Transact(opts, method, params...)
}

// Balances is a free data retrieval call binding the contract method 0x27e235e3.
//
// Solidity: function balances(address ) view returns(int256)
func (_EcpCollateral *EcpCollateralCaller) Balances(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _EcpCollateral.contract.Call(opts, &out, "balances", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Balances is a free data retrieval call binding the contract method 0x27e235e3.
//
// Solidity: function balances(address ) view returns(int256)
func (_EcpCollateral *EcpCollateralSession) Balances(arg0 common.Address) (*big.Int, error) {
	return _EcpCollateral.Contract.Balances(&_EcpCollateral.CallOpts, arg0)
}

// Balances is a free data retrieval call binding the contract method 0x27e235e3.
//
// Solidity: function balances(address ) view returns(int256)
func (_EcpCollateral *EcpCollateralCallerSession) Balances(arg0 common.Address) (*big.Int, error) {
	return _EcpCollateral.Contract.Balances(&_EcpCollateral.CallOpts, arg0)
}

// BaseCollateral is a free data retrieval call binding the contract method 0x9b5ddf09.
//
// Solidity: function baseCollateral() view returns(uint256)
func (_EcpCollateral *EcpCollateralCaller) BaseCollateral(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _EcpCollateral.contract.Call(opts, &out, "baseCollateral")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// BaseCollateral is a free data retrieval call binding the contract method 0x9b5ddf09.
//
// Solidity: function baseCollateral() view returns(uint256)
func (_EcpCollateral *EcpCollateralSession) BaseCollateral() (*big.Int, error) {
	return _EcpCollateral.Contract.BaseCollateral(&_EcpCollateral.CallOpts)
}

// BaseCollateral is a free data retrieval call binding the contract method 0x9b5ddf09.
//
// Solidity: function baseCollateral() view returns(uint256)
func (_EcpCollateral *EcpCollateralCallerSession) BaseCollateral() (*big.Int, error) {
	return _EcpCollateral.Contract.BaseCollateral(&_EcpCollateral.CallOpts)
}

// CollateralRatio is a free data retrieval call binding the contract method 0xb4eae1cb.
//
// Solidity: function collateralRatio() view returns(uint256)
func (_EcpCollateral *EcpCollateralCaller) CollateralRatio(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _EcpCollateral.contract.Call(opts, &out, "collateralRatio")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// CollateralRatio is a free data retrieval call binding the contract method 0xb4eae1cb.
//
// Solidity: function collateralRatio() view returns(uint256)
func (_EcpCollateral *EcpCollateralSession) CollateralRatio() (*big.Int, error) {
	return _EcpCollateral.Contract.CollateralRatio(&_EcpCollateral.CallOpts)
}

// CollateralRatio is a free data retrieval call binding the contract method 0xb4eae1cb.
//
// Solidity: function collateralRatio() view returns(uint256)
func (_EcpCollateral *EcpCollateralCallerSession) CollateralRatio() (*big.Int, error) {
	return _EcpCollateral.Contract.CollateralRatio(&_EcpCollateral.CallOpts)
}

// CollateralToken is a free data retrieval call binding the contract method 0xb2016bd4.
//
// Solidity: function collateralToken() view returns(address)
func (_EcpCollateral *EcpCollateralCaller) CollateralToken(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _EcpCollateral.contract.Call(opts, &out, "collateralToken")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// CollateralToken is a free data retrieval call binding the contract method 0xb2016bd4.
//
// Solidity: function collateralToken() view returns(address)
func (_EcpCollateral *EcpCollateralSession) CollateralToken() (common.Address, error) {
	return _EcpCollateral.Contract.CollateralToken(&_EcpCollateral.CallOpts)
}

// CollateralToken is a free data retrieval call binding the contract method 0xb2016bd4.
//
// Solidity: function collateralToken() view returns(address)
func (_EcpCollateral *EcpCollateralCallerSession) CollateralToken() (common.Address, error) {
	return _EcpCollateral.Contract.CollateralToken(&_EcpCollateral.CallOpts)
}

// CpInfo is a free data retrieval call binding the contract method 0xa664c216.
//
// Solidity: function cpInfo(address cpAddress) view returns((address,int256,uint256,string))
func (_EcpCollateral *EcpCollateralCaller) CpInfo(opts *bind.CallOpts, cpAddress common.Address) (ECPCollateralCPInfo, error) {
	var out []interface{}
	err := _EcpCollateral.contract.Call(opts, &out, "cpInfo", cpAddress)

	if err != nil {
		return *new(ECPCollateralCPInfo), err
	}

	out0 := *abi.ConvertType(out[0], new(ECPCollateralCPInfo)).(*ECPCollateralCPInfo)

	return out0, err

}

// CpInfo is a free data retrieval call binding the contract method 0xa664c216.
//
// Solidity: function cpInfo(address cpAddress) view returns((address,int256,uint256,string))
func (_EcpCollateral *EcpCollateralSession) CpInfo(cpAddress common.Address) (ECPCollateralCPInfo, error) {
	return _EcpCollateral.Contract.CpInfo(&_EcpCollateral.CallOpts, cpAddress)
}

// CpInfo is a free data retrieval call binding the contract method 0xa664c216.
//
// Solidity: function cpInfo(address cpAddress) view returns((address,int256,uint256,string))
func (_EcpCollateral *EcpCollateralCallerSession) CpInfo(cpAddress common.Address) (ECPCollateralCPInfo, error) {
	return _EcpCollateral.Contract.CpInfo(&_EcpCollateral.CallOpts, cpAddress)
}

// CpStatus is a free data retrieval call binding the contract method 0x3fe65177.
//
// Solidity: function cpStatus(address ) view returns(string)
func (_EcpCollateral *EcpCollateralCaller) CpStatus(opts *bind.CallOpts, arg0 common.Address) (string, error) {
	var out []interface{}
	err := _EcpCollateral.contract.Call(opts, &out, "cpStatus", arg0)

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// CpStatus is a free data retrieval call binding the contract method 0x3fe65177.
//
// Solidity: function cpStatus(address ) view returns(string)
func (_EcpCollateral *EcpCollateralSession) CpStatus(arg0 common.Address) (string, error) {
	return _EcpCollateral.Contract.CpStatus(&_EcpCollateral.CallOpts, arg0)
}

// CpStatus is a free data retrieval call binding the contract method 0x3fe65177.
//
// Solidity: function cpStatus(address ) view returns(string)
func (_EcpCollateral *EcpCollateralCallerSession) CpStatus(arg0 common.Address) (string, error) {
	return _EcpCollateral.Contract.CpStatus(&_EcpCollateral.CallOpts, arg0)
}

// FrozenBalance is a free data retrieval call binding the contract method 0x266565a9.
//
// Solidity: function frozenBalance(address ) view returns(uint256)
func (_EcpCollateral *EcpCollateralCaller) FrozenBalance(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _EcpCollateral.contract.Call(opts, &out, "frozenBalance", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// FrozenBalance is a free data retrieval call binding the contract method 0x266565a9.
//
// Solidity: function frozenBalance(address ) view returns(uint256)
func (_EcpCollateral *EcpCollateralSession) FrozenBalance(arg0 common.Address) (*big.Int, error) {
	return _EcpCollateral.Contract.FrozenBalance(&_EcpCollateral.CallOpts, arg0)
}

// FrozenBalance is a free data retrieval call binding the contract method 0x266565a9.
//
// Solidity: function frozenBalance(address ) view returns(uint256)
func (_EcpCollateral *EcpCollateralCallerSession) FrozenBalance(arg0 common.Address) (*big.Int, error) {
	return _EcpCollateral.Contract.FrozenBalance(&_EcpCollateral.CallOpts, arg0)
}

// GetBaseCollateral is a free data retrieval call binding the contract method 0x70b72944.
//
// Solidity: function getBaseCollateral() view returns(uint256)
func (_EcpCollateral *EcpCollateralCaller) GetBaseCollateral(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _EcpCollateral.contract.Call(opts, &out, "getBaseCollateral")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetBaseCollateral is a free data retrieval call binding the contract method 0x70b72944.
//
// Solidity: function getBaseCollateral() view returns(uint256)
func (_EcpCollateral *EcpCollateralSession) GetBaseCollateral() (*big.Int, error) {
	return _EcpCollateral.Contract.GetBaseCollateral(&_EcpCollateral.CallOpts)
}

// GetBaseCollateral is a free data retrieval call binding the contract method 0x70b72944.
//
// Solidity: function getBaseCollateral() view returns(uint256)
func (_EcpCollateral *EcpCollateralCallerSession) GetBaseCollateral() (*big.Int, error) {
	return _EcpCollateral.Contract.GetBaseCollateral(&_EcpCollateral.CallOpts)
}

// GetECPCollateralInfo is a free data retrieval call binding the contract method 0x9939cd18.
//
// Solidity: function getECPCollateralInfo() view returns((uint256,uint256,uint256,uint256,uint256))
func (_EcpCollateral *EcpCollateralCaller) GetECPCollateralInfo(opts *bind.CallOpts) (ECPCollateralContractInfo, error) {
	var out []interface{}
	err := _EcpCollateral.contract.Call(opts, &out, "getECPCollateralInfo")

	if err != nil {
		return *new(ECPCollateralContractInfo), err
	}

	out0 := *abi.ConvertType(out[0], new(ECPCollateralContractInfo)).(*ECPCollateralContractInfo)

	return out0, err

}

// GetECPCollateralInfo is a free data retrieval call binding the contract method 0x9939cd18.
//
// Solidity: function getECPCollateralInfo() view returns((uint256,uint256,uint256,uint256,uint256))
func (_EcpCollateral *EcpCollateralSession) GetECPCollateralInfo() (ECPCollateralContractInfo, error) {
	return _EcpCollateral.Contract.GetECPCollateralInfo(&_EcpCollateral.CallOpts)
}

// GetECPCollateralInfo is a free data retrieval call binding the contract method 0x9939cd18.
//
// Solidity: function getECPCollateralInfo() view returns((uint256,uint256,uint256,uint256,uint256))
func (_EcpCollateral *EcpCollateralCallerSession) GetECPCollateralInfo() (ECPCollateralContractInfo, error) {
	return _EcpCollateral.Contract.GetECPCollateralInfo(&_EcpCollateral.CallOpts)
}

// GetTaskInfo is a free data retrieval call binding the contract method 0xd1a1b999.
//
// Solidity: function getTaskInfo(uint256 taskID) view returns((address,uint256,uint256))
func (_EcpCollateral *EcpCollateralCaller) GetTaskInfo(opts *bind.CallOpts, taskID *big.Int) (ECPCollateralTask, error) {
	var out []interface{}
	err := _EcpCollateral.contract.Call(opts, &out, "getTaskInfo", taskID)

	if err != nil {
		return *new(ECPCollateralTask), err
	}

	out0 := *abi.ConvertType(out[0], new(ECPCollateralTask)).(*ECPCollateralTask)

	return out0, err

}

// GetTaskInfo is a free data retrieval call binding the contract method 0xd1a1b999.
//
// Solidity: function getTaskInfo(uint256 taskID) view returns((address,uint256,uint256))
func (_EcpCollateral *EcpCollateralSession) GetTaskInfo(taskID *big.Int) (ECPCollateralTask, error) {
	return _EcpCollateral.Contract.GetTaskInfo(&_EcpCollateral.CallOpts, taskID)
}

// GetTaskInfo is a free data retrieval call binding the contract method 0xd1a1b999.
//
// Solidity: function getTaskInfo(uint256 taskID) view returns((address,uint256,uint256))
func (_EcpCollateral *EcpCollateralCallerSession) GetTaskInfo(taskID *big.Int) (ECPCollateralTask, error) {
	return _EcpCollateral.Contract.GetTaskInfo(&_EcpCollateral.CallOpts, taskID)
}

// IsAdmin is a free data retrieval call binding the contract method 0x24d7806c.
//
// Solidity: function isAdmin(address ) view returns(bool)
func (_EcpCollateral *EcpCollateralCaller) IsAdmin(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _EcpCollateral.contract.Call(opts, &out, "isAdmin", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsAdmin is a free data retrieval call binding the contract method 0x24d7806c.
//
// Solidity: function isAdmin(address ) view returns(bool)
func (_EcpCollateral *EcpCollateralSession) IsAdmin(arg0 common.Address) (bool, error) {
	return _EcpCollateral.Contract.IsAdmin(&_EcpCollateral.CallOpts, arg0)
}

// IsAdmin is a free data retrieval call binding the contract method 0x24d7806c.
//
// Solidity: function isAdmin(address ) view returns(bool)
func (_EcpCollateral *EcpCollateralCallerSession) IsAdmin(arg0 common.Address) (bool, error) {
	return _EcpCollateral.Contract.IsAdmin(&_EcpCollateral.CallOpts, arg0)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_EcpCollateral *EcpCollateralCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _EcpCollateral.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_EcpCollateral *EcpCollateralSession) Owner() (common.Address, error) {
	return _EcpCollateral.Contract.Owner(&_EcpCollateral.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_EcpCollateral *EcpCollateralCallerSession) Owner() (common.Address, error) {
	return _EcpCollateral.Contract.Owner(&_EcpCollateral.CallOpts)
}

// SlashRatio is a free data retrieval call binding the contract method 0xd27ca89b.
//
// Solidity: function slashRatio() view returns(uint256)
func (_EcpCollateral *EcpCollateralCaller) SlashRatio(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _EcpCollateral.contract.Call(opts, &out, "slashRatio")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// SlashRatio is a free data retrieval call binding the contract method 0xd27ca89b.
//
// Solidity: function slashRatio() view returns(uint256)
func (_EcpCollateral *EcpCollateralSession) SlashRatio() (*big.Int, error) {
	return _EcpCollateral.Contract.SlashRatio(&_EcpCollateral.CallOpts)
}

// SlashRatio is a free data retrieval call binding the contract method 0xd27ca89b.
//
// Solidity: function slashRatio() view returns(uint256)
func (_EcpCollateral *EcpCollateralCallerSession) SlashRatio() (*big.Int, error) {
	return _EcpCollateral.Contract.SlashRatio(&_EcpCollateral.CallOpts)
}

// SlashedFunds is a free data retrieval call binding the contract method 0x6f99f15c.
//
// Solidity: function slashedFunds() view returns(uint256)
func (_EcpCollateral *EcpCollateralCaller) SlashedFunds(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _EcpCollateral.contract.Call(opts, &out, "slashedFunds")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// SlashedFunds is a free data retrieval call binding the contract method 0x6f99f15c.
//
// Solidity: function slashedFunds() view returns(uint256)
func (_EcpCollateral *EcpCollateralSession) SlashedFunds() (*big.Int, error) {
	return _EcpCollateral.Contract.SlashedFunds(&_EcpCollateral.CallOpts)
}

// SlashedFunds is a free data retrieval call binding the contract method 0x6f99f15c.
//
// Solidity: function slashedFunds() view returns(uint256)
func (_EcpCollateral *EcpCollateralCallerSession) SlashedFunds() (*big.Int, error) {
	return _EcpCollateral.Contract.SlashedFunds(&_EcpCollateral.CallOpts)
}

// TaskBalance is a free data retrieval call binding the contract method 0xf31cc883.
//
// Solidity: function taskBalance() view returns(uint256)
func (_EcpCollateral *EcpCollateralCaller) TaskBalance(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _EcpCollateral.contract.Call(opts, &out, "taskBalance")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TaskBalance is a free data retrieval call binding the contract method 0xf31cc883.
//
// Solidity: function taskBalance() view returns(uint256)
func (_EcpCollateral *EcpCollateralSession) TaskBalance() (*big.Int, error) {
	return _EcpCollateral.Contract.TaskBalance(&_EcpCollateral.CallOpts)
}

// TaskBalance is a free data retrieval call binding the contract method 0xf31cc883.
//
// Solidity: function taskBalance() view returns(uint256)
func (_EcpCollateral *EcpCollateralCallerSession) TaskBalance() (*big.Int, error) {
	return _EcpCollateral.Contract.TaskBalance(&_EcpCollateral.CallOpts)
}

// Tasks is a free data retrieval call binding the contract method 0x8d977672.
//
// Solidity: function tasks(uint256 ) view returns(address cpAccountAddress, uint256 collateral, uint256 status)
func (_EcpCollateral *EcpCollateralCaller) Tasks(opts *bind.CallOpts, arg0 *big.Int) (struct {
	CpAccountAddress common.Address
	Collateral       *big.Int
	Status           *big.Int
}, error) {
	var out []interface{}
	err := _EcpCollateral.contract.Call(opts, &out, "tasks", arg0)

	outstruct := new(struct {
		CpAccountAddress common.Address
		Collateral       *big.Int
		Status           *big.Int
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.CpAccountAddress = *abi.ConvertType(out[0], new(common.Address)).(*common.Address)
	outstruct.Collateral = *abi.ConvertType(out[1], new(*big.Int)).(**big.Int)
	outstruct.Status = *abi.ConvertType(out[2], new(*big.Int)).(**big.Int)

	return *outstruct, err

}

// Tasks is a free data retrieval call binding the contract method 0x8d977672.
//
// Solidity: function tasks(uint256 ) view returns(address cpAccountAddress, uint256 collateral, uint256 status)
func (_EcpCollateral *EcpCollateralSession) Tasks(arg0 *big.Int) (struct {
	CpAccountAddress common.Address
	Collateral       *big.Int
	Status           *big.Int
}, error) {
	return _EcpCollateral.Contract.Tasks(&_EcpCollateral.CallOpts, arg0)
}

// Tasks is a free data retrieval call binding the contract method 0x8d977672.
//
// Solidity: function tasks(uint256 ) view returns(address cpAccountAddress, uint256 collateral, uint256 status)
func (_EcpCollateral *EcpCollateralCallerSession) Tasks(arg0 *big.Int) (struct {
	CpAccountAddress common.Address
	Collateral       *big.Int
	Status           *big.Int
}, error) {
	return _EcpCollateral.Contract.Tasks(&_EcpCollateral.CallOpts, arg0)
}

// AddAdmin is a paid mutator transaction binding the contract method 0x70480275.
//
// Solidity: function addAdmin(address newAdmin) returns()
func (_EcpCollateral *EcpCollateralTransactor) AddAdmin(opts *bind.TransactOpts, newAdmin common.Address) (*types.Transaction, error) {
	return _EcpCollateral.contract.Transact(opts, "addAdmin", newAdmin)
}

// AddAdmin is a paid mutator transaction binding the contract method 0x70480275.
//
// Solidity: function addAdmin(address newAdmin) returns()
func (_EcpCollateral *EcpCollateralSession) AddAdmin(newAdmin common.Address) (*types.Transaction, error) {
	return _EcpCollateral.Contract.AddAdmin(&_EcpCollateral.TransactOpts, newAdmin)
}

// AddAdmin is a paid mutator transaction binding the contract method 0x70480275.
//
// Solidity: function addAdmin(address newAdmin) returns()
func (_EcpCollateral *EcpCollateralTransactorSession) AddAdmin(newAdmin common.Address) (*types.Transaction, error) {
	return _EcpCollateral.Contract.AddAdmin(&_EcpCollateral.TransactOpts, newAdmin)
}

// BatchLock is a paid mutator transaction binding the contract method 0x63215bb7.
//
// Solidity: function batchLock(address[] cpAddresses, uint256[] taskIDs) returns()
func (_EcpCollateral *EcpCollateralTransactor) BatchLock(opts *bind.TransactOpts, cpAddresses []common.Address, taskIDs []*big.Int) (*types.Transaction, error) {
	return _EcpCollateral.contract.Transact(opts, "batchLock", cpAddresses, taskIDs)
}

// BatchLock is a paid mutator transaction binding the contract method 0x63215bb7.
//
// Solidity: function batchLock(address[] cpAddresses, uint256[] taskIDs) returns()
func (_EcpCollateral *EcpCollateralSession) BatchLock(cpAddresses []common.Address, taskIDs []*big.Int) (*types.Transaction, error) {
	return _EcpCollateral.Contract.BatchLock(&_EcpCollateral.TransactOpts, cpAddresses, taskIDs)
}

// BatchLock is a paid mutator transaction binding the contract method 0x63215bb7.
//
// Solidity: function batchLock(address[] cpAddresses, uint256[] taskIDs) returns()
func (_EcpCollateral *EcpCollateralTransactorSession) BatchLock(cpAddresses []common.Address, taskIDs []*big.Int) (*types.Transaction, error) {
	return _EcpCollateral.Contract.BatchLock(&_EcpCollateral.TransactOpts, cpAddresses, taskIDs)
}

// BatchSlash is a paid mutator transaction binding the contract method 0x436ea491.
//
// Solidity: function batchSlash(uint256[] taskIDs) returns()
func (_EcpCollateral *EcpCollateralTransactor) BatchSlash(opts *bind.TransactOpts, taskIDs []*big.Int) (*types.Transaction, error) {
	return _EcpCollateral.contract.Transact(opts, "batchSlash", taskIDs)
}

// BatchSlash is a paid mutator transaction binding the contract method 0x436ea491.
//
// Solidity: function batchSlash(uint256[] taskIDs) returns()
func (_EcpCollateral *EcpCollateralSession) BatchSlash(taskIDs []*big.Int) (*types.Transaction, error) {
	return _EcpCollateral.Contract.BatchSlash(&_EcpCollateral.TransactOpts, taskIDs)
}

// BatchSlash is a paid mutator transaction binding the contract method 0x436ea491.
//
// Solidity: function batchSlash(uint256[] taskIDs) returns()
func (_EcpCollateral *EcpCollateralTransactorSession) BatchSlash(taskIDs []*big.Int) (*types.Transaction, error) {
	return _EcpCollateral.Contract.BatchSlash(&_EcpCollateral.TransactOpts, taskIDs)
}

// BatchUnlock is a paid mutator transaction binding the contract method 0x4a82942c.
//
// Solidity: function batchUnlock(uint256[] taskIDs) returns()
func (_EcpCollateral *EcpCollateralTransactor) BatchUnlock(opts *bind.TransactOpts, taskIDs []*big.Int) (*types.Transaction, error) {
	return _EcpCollateral.contract.Transact(opts, "batchUnlock", taskIDs)
}

// BatchUnlock is a paid mutator transaction binding the contract method 0x4a82942c.
//
// Solidity: function batchUnlock(uint256[] taskIDs) returns()
func (_EcpCollateral *EcpCollateralSession) BatchUnlock(taskIDs []*big.Int) (*types.Transaction, error) {
	return _EcpCollateral.Contract.BatchUnlock(&_EcpCollateral.TransactOpts, taskIDs)
}

// BatchUnlock is a paid mutator transaction binding the contract method 0x4a82942c.
//
// Solidity: function batchUnlock(uint256[] taskIDs) returns()
func (_EcpCollateral *EcpCollateralTransactorSession) BatchUnlock(taskIDs []*big.Int) (*types.Transaction, error) {
	return _EcpCollateral.Contract.BatchUnlock(&_EcpCollateral.TransactOpts, taskIDs)
}

// Deposit is a paid mutator transaction binding the contract method 0x47e7ef24.
//
// Solidity: function deposit(address cpAccount, uint256 amount) returns()
func (_EcpCollateral *EcpCollateralTransactor) Deposit(opts *bind.TransactOpts, cpAccount common.Address, amount *big.Int) (*types.Transaction, error) {
	return _EcpCollateral.contract.Transact(opts, "deposit", cpAccount, amount)
}

// Deposit is a paid mutator transaction binding the contract method 0x47e7ef24.
//
// Solidity: function deposit(address cpAccount, uint256 amount) returns()
func (_EcpCollateral *EcpCollateralSession) Deposit(cpAccount common.Address, amount *big.Int) (*types.Transaction, error) {
	return _EcpCollateral.Contract.Deposit(&_EcpCollateral.TransactOpts, cpAccount, amount)
}

// Deposit is a paid mutator transaction binding the contract method 0x47e7ef24.
//
// Solidity: function deposit(address cpAccount, uint256 amount) returns()
func (_EcpCollateral *EcpCollateralTransactorSession) Deposit(cpAccount common.Address, amount *big.Int) (*types.Transaction, error) {
	return _EcpCollateral.Contract.Deposit(&_EcpCollateral.TransactOpts, cpAccount, amount)
}

// DisputeProof is a paid mutator transaction binding the contract method 0x43a8906c.
//
// Solidity: function disputeProof(address taskContractAddress) returns()
func (_EcpCollateral *EcpCollateralTransactor) DisputeProof(opts *bind.TransactOpts, taskContractAddress common.Address) (*types.Transaction, error) {
	return _EcpCollateral.contract.Transact(opts, "disputeProof", taskContractAddress)
}

// DisputeProof is a paid mutator transaction binding the contract method 0x43a8906c.
//
// Solidity: function disputeProof(address taskContractAddress) returns()
func (_EcpCollateral *EcpCollateralSession) DisputeProof(taskContractAddress common.Address) (*types.Transaction, error) {
	return _EcpCollateral.Contract.DisputeProof(&_EcpCollateral.TransactOpts, taskContractAddress)
}

// DisputeProof is a paid mutator transaction binding the contract method 0x43a8906c.
//
// Solidity: function disputeProof(address taskContractAddress) returns()
func (_EcpCollateral *EcpCollateralTransactorSession) DisputeProof(taskContractAddress common.Address) (*types.Transaction, error) {
	return _EcpCollateral.Contract.DisputeProof(&_EcpCollateral.TransactOpts, taskContractAddress)
}

// LockCollateral is a paid mutator transaction binding the contract method 0x47a7d107.
//
// Solidity: function lockCollateral(address cp, uint256 taskID) returns()
func (_EcpCollateral *EcpCollateralTransactor) LockCollateral(opts *bind.TransactOpts, cp common.Address, taskID *big.Int) (*types.Transaction, error) {
	return _EcpCollateral.contract.Transact(opts, "lockCollateral", cp, taskID)
}

// LockCollateral is a paid mutator transaction binding the contract method 0x47a7d107.
//
// Solidity: function lockCollateral(address cp, uint256 taskID) returns()
func (_EcpCollateral *EcpCollateralSession) LockCollateral(cp common.Address, taskID *big.Int) (*types.Transaction, error) {
	return _EcpCollateral.Contract.LockCollateral(&_EcpCollateral.TransactOpts, cp, taskID)
}

// LockCollateral is a paid mutator transaction binding the contract method 0x47a7d107.
//
// Solidity: function lockCollateral(address cp, uint256 taskID) returns()
func (_EcpCollateral *EcpCollateralTransactorSession) LockCollateral(cp common.Address, taskID *big.Int) (*types.Transaction, error) {
	return _EcpCollateral.Contract.LockCollateral(&_EcpCollateral.TransactOpts, cp, taskID)
}

// RemoveAdmin is a paid mutator transaction binding the contract method 0x1785f53c.
//
// Solidity: function removeAdmin(address admin) returns()
func (_EcpCollateral *EcpCollateralTransactor) RemoveAdmin(opts *bind.TransactOpts, admin common.Address) (*types.Transaction, error) {
	return _EcpCollateral.contract.Transact(opts, "removeAdmin", admin)
}

// RemoveAdmin is a paid mutator transaction binding the contract method 0x1785f53c.
//
// Solidity: function removeAdmin(address admin) returns()
func (_EcpCollateral *EcpCollateralSession) RemoveAdmin(admin common.Address) (*types.Transaction, error) {
	return _EcpCollateral.Contract.RemoveAdmin(&_EcpCollateral.TransactOpts, admin)
}

// RemoveAdmin is a paid mutator transaction binding the contract method 0x1785f53c.
//
// Solidity: function removeAdmin(address admin) returns()
func (_EcpCollateral *EcpCollateralTransactorSession) RemoveAdmin(admin common.Address) (*types.Transaction, error) {
	return _EcpCollateral.Contract.RemoveAdmin(&_EcpCollateral.TransactOpts, admin)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_EcpCollateral *EcpCollateralTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _EcpCollateral.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_EcpCollateral *EcpCollateralSession) RenounceOwnership() (*types.Transaction, error) {
	return _EcpCollateral.Contract.RenounceOwnership(&_EcpCollateral.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_EcpCollateral *EcpCollateralTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _EcpCollateral.Contract.RenounceOwnership(&_EcpCollateral.TransactOpts)
}

// SetBaseCollateral is a paid mutator transaction binding the contract method 0x7f58a7e5.
//
// Solidity: function setBaseCollateral(uint256 _baseCollateral) returns()
func (_EcpCollateral *EcpCollateralTransactor) SetBaseCollateral(opts *bind.TransactOpts, _baseCollateral *big.Int) (*types.Transaction, error) {
	return _EcpCollateral.contract.Transact(opts, "setBaseCollateral", _baseCollateral)
}

// SetBaseCollateral is a paid mutator transaction binding the contract method 0x7f58a7e5.
//
// Solidity: function setBaseCollateral(uint256 _baseCollateral) returns()
func (_EcpCollateral *EcpCollateralSession) SetBaseCollateral(_baseCollateral *big.Int) (*types.Transaction, error) {
	return _EcpCollateral.Contract.SetBaseCollateral(&_EcpCollateral.TransactOpts, _baseCollateral)
}

// SetBaseCollateral is a paid mutator transaction binding the contract method 0x7f58a7e5.
//
// Solidity: function setBaseCollateral(uint256 _baseCollateral) returns()
func (_EcpCollateral *EcpCollateralTransactorSession) SetBaseCollateral(_baseCollateral *big.Int) (*types.Transaction, error) {
	return _EcpCollateral.Contract.SetBaseCollateral(&_EcpCollateral.TransactOpts, _baseCollateral)
}

// SetCollateralRatio is a paid mutator transaction binding the contract method 0x6060663e.
//
// Solidity: function setCollateralRatio(uint256 _collateralRatio) returns()
func (_EcpCollateral *EcpCollateralTransactor) SetCollateralRatio(opts *bind.TransactOpts, _collateralRatio *big.Int) (*types.Transaction, error) {
	return _EcpCollateral.contract.Transact(opts, "setCollateralRatio", _collateralRatio)
}

// SetCollateralRatio is a paid mutator transaction binding the contract method 0x6060663e.
//
// Solidity: function setCollateralRatio(uint256 _collateralRatio) returns()
func (_EcpCollateral *EcpCollateralSession) SetCollateralRatio(_collateralRatio *big.Int) (*types.Transaction, error) {
	return _EcpCollateral.Contract.SetCollateralRatio(&_EcpCollateral.TransactOpts, _collateralRatio)
}

// SetCollateralRatio is a paid mutator transaction binding the contract method 0x6060663e.
//
// Solidity: function setCollateralRatio(uint256 _collateralRatio) returns()
func (_EcpCollateral *EcpCollateralTransactorSession) SetCollateralRatio(_collateralRatio *big.Int) (*types.Transaction, error) {
	return _EcpCollateral.Contract.SetCollateralRatio(&_EcpCollateral.TransactOpts, _collateralRatio)
}

// SetCollateralToken is a paid mutator transaction binding the contract method 0x666181a9.
//
// Solidity: function setCollateralToken(address tokenAddress) returns()
func (_EcpCollateral *EcpCollateralTransactor) SetCollateralToken(opts *bind.TransactOpts, tokenAddress common.Address) (*types.Transaction, error) {
	return _EcpCollateral.contract.Transact(opts, "setCollateralToken", tokenAddress)
}

// SetCollateralToken is a paid mutator transaction binding the contract method 0x666181a9.
//
// Solidity: function setCollateralToken(address tokenAddress) returns()
func (_EcpCollateral *EcpCollateralSession) SetCollateralToken(tokenAddress common.Address) (*types.Transaction, error) {
	return _EcpCollateral.Contract.SetCollateralToken(&_EcpCollateral.TransactOpts, tokenAddress)
}

// SetCollateralToken is a paid mutator transaction binding the contract method 0x666181a9.
//
// Solidity: function setCollateralToken(address tokenAddress) returns()
func (_EcpCollateral *EcpCollateralTransactorSession) SetCollateralToken(tokenAddress common.Address) (*types.Transaction, error) {
	return _EcpCollateral.Contract.SetCollateralToken(&_EcpCollateral.TransactOpts, tokenAddress)
}

// SetSlashRatio is a paid mutator transaction binding the contract method 0xce3518aa.
//
// Solidity: function setSlashRatio(uint256 _slashRatio) returns()
func (_EcpCollateral *EcpCollateralTransactor) SetSlashRatio(opts *bind.TransactOpts, _slashRatio *big.Int) (*types.Transaction, error) {
	return _EcpCollateral.contract.Transact(opts, "setSlashRatio", _slashRatio)
}

// SetSlashRatio is a paid mutator transaction binding the contract method 0xce3518aa.
//
// Solidity: function setSlashRatio(uint256 _slashRatio) returns()
func (_EcpCollateral *EcpCollateralSession) SetSlashRatio(_slashRatio *big.Int) (*types.Transaction, error) {
	return _EcpCollateral.Contract.SetSlashRatio(&_EcpCollateral.TransactOpts, _slashRatio)
}

// SetSlashRatio is a paid mutator transaction binding the contract method 0xce3518aa.
//
// Solidity: function setSlashRatio(uint256 _slashRatio) returns()
func (_EcpCollateral *EcpCollateralTransactorSession) SetSlashRatio(_slashRatio *big.Int) (*types.Transaction, error) {
	return _EcpCollateral.Contract.SetSlashRatio(&_EcpCollateral.TransactOpts, _slashRatio)
}

// SlashCollateral is a paid mutator transaction binding the contract method 0xde2b2f53.
//
// Solidity: function slashCollateral(uint256 taskID) returns()
func (_EcpCollateral *EcpCollateralTransactor) SlashCollateral(opts *bind.TransactOpts, taskID *big.Int) (*types.Transaction, error) {
	return _EcpCollateral.contract.Transact(opts, "slashCollateral", taskID)
}

// SlashCollateral is a paid mutator transaction binding the contract method 0xde2b2f53.
//
// Solidity: function slashCollateral(uint256 taskID) returns()
func (_EcpCollateral *EcpCollateralSession) SlashCollateral(taskID *big.Int) (*types.Transaction, error) {
	return _EcpCollateral.Contract.SlashCollateral(&_EcpCollateral.TransactOpts, taskID)
}

// SlashCollateral is a paid mutator transaction binding the contract method 0xde2b2f53.
//
// Solidity: function slashCollateral(uint256 taskID) returns()
func (_EcpCollateral *EcpCollateralTransactorSession) SlashCollateral(taskID *big.Int) (*types.Transaction, error) {
	return _EcpCollateral.Contract.SlashCollateral(&_EcpCollateral.TransactOpts, taskID)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_EcpCollateral *EcpCollateralTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _EcpCollateral.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_EcpCollateral *EcpCollateralSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _EcpCollateral.Contract.TransferOwnership(&_EcpCollateral.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_EcpCollateral *EcpCollateralTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _EcpCollateral.Contract.TransferOwnership(&_EcpCollateral.TransactOpts, newOwner)
}

// UnlockCollateral is a paid mutator transaction binding the contract method 0x0fcc834e.
//
// Solidity: function unlockCollateral(uint256 taskID) returns()
func (_EcpCollateral *EcpCollateralTransactor) UnlockCollateral(opts *bind.TransactOpts, taskID *big.Int) (*types.Transaction, error) {
	return _EcpCollateral.contract.Transact(opts, "unlockCollateral", taskID)
}

// UnlockCollateral is a paid mutator transaction binding the contract method 0x0fcc834e.
//
// Solidity: function unlockCollateral(uint256 taskID) returns()
func (_EcpCollateral *EcpCollateralSession) UnlockCollateral(taskID *big.Int) (*types.Transaction, error) {
	return _EcpCollateral.Contract.UnlockCollateral(&_EcpCollateral.TransactOpts, taskID)
}

// UnlockCollateral is a paid mutator transaction binding the contract method 0x0fcc834e.
//
// Solidity: function unlockCollateral(uint256 taskID) returns()
func (_EcpCollateral *EcpCollateralTransactorSession) UnlockCollateral(taskID *big.Int) (*types.Transaction, error) {
	return _EcpCollateral.Contract.UnlockCollateral(&_EcpCollateral.TransactOpts, taskID)
}

// Withdraw is a paid mutator transaction binding the contract method 0xf3fef3a3.
//
// Solidity: function withdraw(address cpAccount, uint256 amount) returns()
func (_EcpCollateral *EcpCollateralTransactor) Withdraw(opts *bind.TransactOpts, cpAccount common.Address, amount *big.Int) (*types.Transaction, error) {
	return _EcpCollateral.contract.Transact(opts, "withdraw", cpAccount, amount)
}

// Withdraw is a paid mutator transaction binding the contract method 0xf3fef3a3.
//
// Solidity: function withdraw(address cpAccount, uint256 amount) returns()
func (_EcpCollateral *EcpCollateralSession) Withdraw(cpAccount common.Address, amount *big.Int) (*types.Transaction, error) {
	return _EcpCollateral.Contract.Withdraw(&_EcpCollateral.TransactOpts, cpAccount, amount)
}

// Withdraw is a paid mutator transaction binding the contract method 0xf3fef3a3.
//
// Solidity: function withdraw(address cpAccount, uint256 amount) returns()
func (_EcpCollateral *EcpCollateralTransactorSession) Withdraw(cpAccount common.Address, amount *big.Int) (*types.Transaction, error) {
	return _EcpCollateral.Contract.Withdraw(&_EcpCollateral.TransactOpts, cpAccount, amount)
}

// WithdrawSlashedFunds is a paid mutator transaction binding the contract method 0x2894493f.
//
// Solidity: function withdrawSlashedFunds(uint256 slashfund) returns()
func (_EcpCollateral *EcpCollateralTransactor) WithdrawSlashedFunds(opts *bind.TransactOpts, slashfund *big.Int) (*types.Transaction, error) {
	return _EcpCollateral.contract.Transact(opts, "withdrawSlashedFunds", slashfund)
}

// WithdrawSlashedFunds is a paid mutator transaction binding the contract method 0x2894493f.
//
// Solidity: function withdrawSlashedFunds(uint256 slashfund) returns()
func (_EcpCollateral *EcpCollateralSession) WithdrawSlashedFunds(slashfund *big.Int) (*types.Transaction, error) {
	return _EcpCollateral.Contract.WithdrawSlashedFunds(&_EcpCollateral.TransactOpts, slashfund)
}

// WithdrawSlashedFunds is a paid mutator transaction binding the contract method 0x2894493f.
//
// Solidity: function withdrawSlashedFunds(uint256 slashfund) returns()
func (_EcpCollateral *EcpCollateralTransactorSession) WithdrawSlashedFunds(slashfund *big.Int) (*types.Transaction, error) {
	return _EcpCollateral.Contract.WithdrawSlashedFunds(&_EcpCollateral.TransactOpts, slashfund)
}

// EcpCollateralCollateralAdjustedIterator is returned from FilterCollateralAdjusted and is used to iterate over the raw logs and unpacked data for CollateralAdjusted events raised by the EcpCollateral contract.
type EcpCollateralCollateralAdjustedIterator struct {
	Event *EcpCollateralCollateralAdjusted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *EcpCollateralCollateralAdjustedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(EcpCollateralCollateralAdjusted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(EcpCollateralCollateralAdjusted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *EcpCollateralCollateralAdjustedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *EcpCollateralCollateralAdjustedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// EcpCollateralCollateralAdjusted represents a CollateralAdjusted event raised by the EcpCollateral contract.
type EcpCollateralCollateralAdjusted struct {
	Cp            common.Address
	FrozenAmount  *big.Int
	BalanceAmount *big.Int
	Operation     string
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterCollateralAdjusted is a free log retrieval operation binding the contract event 0x42f1a8a1aee108e84e4eabfaa8d51d7baaa1a02d482295297883a44b2debd3e4.
//
// Solidity: event CollateralAdjusted(address indexed cp, uint256 frozenAmount, uint256 balanceAmount, string operation)
func (_EcpCollateral *EcpCollateralFilterer) FilterCollateralAdjusted(opts *bind.FilterOpts, cp []common.Address) (*EcpCollateralCollateralAdjustedIterator, error) {

	var cpRule []interface{}
	for _, cpItem := range cp {
		cpRule = append(cpRule, cpItem)
	}

	logs, sub, err := _EcpCollateral.contract.FilterLogs(opts, "CollateralAdjusted", cpRule)
	if err != nil {
		return nil, err
	}
	return &EcpCollateralCollateralAdjustedIterator{contract: _EcpCollateral.contract, event: "CollateralAdjusted", logs: logs, sub: sub}, nil
}

// WatchCollateralAdjusted is a free log subscription operation binding the contract event 0x42f1a8a1aee108e84e4eabfaa8d51d7baaa1a02d482295297883a44b2debd3e4.
//
// Solidity: event CollateralAdjusted(address indexed cp, uint256 frozenAmount, uint256 balanceAmount, string operation)
func (_EcpCollateral *EcpCollateralFilterer) WatchCollateralAdjusted(opts *bind.WatchOpts, sink chan<- *EcpCollateralCollateralAdjusted, cp []common.Address) (event.Subscription, error) {

	var cpRule []interface{}
	for _, cpItem := range cp {
		cpRule = append(cpRule, cpItem)
	}

	logs, sub, err := _EcpCollateral.contract.WatchLogs(opts, "CollateralAdjusted", cpRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(EcpCollateralCollateralAdjusted)
				if err := _EcpCollateral.contract.UnpackLog(event, "CollateralAdjusted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseCollateralAdjusted is a log parse operation binding the contract event 0x42f1a8a1aee108e84e4eabfaa8d51d7baaa1a02d482295297883a44b2debd3e4.
//
// Solidity: event CollateralAdjusted(address indexed cp, uint256 frozenAmount, uint256 balanceAmount, string operation)
func (_EcpCollateral *EcpCollateralFilterer) ParseCollateralAdjusted(log types.Log) (*EcpCollateralCollateralAdjusted, error) {
	event := new(EcpCollateralCollateralAdjusted)
	if err := _EcpCollateral.contract.UnpackLog(event, "CollateralAdjusted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// EcpCollateralCollateralLockedIterator is returned from FilterCollateralLocked and is used to iterate over the raw logs and unpacked data for CollateralLocked events raised by the EcpCollateral contract.
type EcpCollateralCollateralLockedIterator struct {
	Event *EcpCollateralCollateralLocked // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *EcpCollateralCollateralLockedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(EcpCollateralCollateralLocked)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(EcpCollateralCollateralLocked)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *EcpCollateralCollateralLockedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *EcpCollateralCollateralLockedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// EcpCollateralCollateralLocked represents a CollateralLocked event raised by the EcpCollateral contract.
type EcpCollateralCollateralLocked struct {
	Cp               common.Address
	CollateralAmount *big.Int
	TaskID           *big.Int
	Raw              types.Log // Blockchain specific contextual infos
}

// FilterCollateralLocked is a free log retrieval operation binding the contract event 0xaff82f4178df227ea409be11c927e414a908fb01481236913cec80ea866b2468.
//
// Solidity: event CollateralLocked(address indexed cp, uint256 collateralAmount, uint256 taskID)
func (_EcpCollateral *EcpCollateralFilterer) FilterCollateralLocked(opts *bind.FilterOpts, cp []common.Address) (*EcpCollateralCollateralLockedIterator, error) {

	var cpRule []interface{}
	for _, cpItem := range cp {
		cpRule = append(cpRule, cpItem)
	}

	logs, sub, err := _EcpCollateral.contract.FilterLogs(opts, "CollateralLocked", cpRule)
	if err != nil {
		return nil, err
	}
	return &EcpCollateralCollateralLockedIterator{contract: _EcpCollateral.contract, event: "CollateralLocked", logs: logs, sub: sub}, nil
}

// WatchCollateralLocked is a free log subscription operation binding the contract event 0xaff82f4178df227ea409be11c927e414a908fb01481236913cec80ea866b2468.
//
// Solidity: event CollateralLocked(address indexed cp, uint256 collateralAmount, uint256 taskID)
func (_EcpCollateral *EcpCollateralFilterer) WatchCollateralLocked(opts *bind.WatchOpts, sink chan<- *EcpCollateralCollateralLocked, cp []common.Address) (event.Subscription, error) {

	var cpRule []interface{}
	for _, cpItem := range cp {
		cpRule = append(cpRule, cpItem)
	}

	logs, sub, err := _EcpCollateral.contract.WatchLogs(opts, "CollateralLocked", cpRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(EcpCollateralCollateralLocked)
				if err := _EcpCollateral.contract.UnpackLog(event, "CollateralLocked", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseCollateralLocked is a log parse operation binding the contract event 0xaff82f4178df227ea409be11c927e414a908fb01481236913cec80ea866b2468.
//
// Solidity: event CollateralLocked(address indexed cp, uint256 collateralAmount, uint256 taskID)
func (_EcpCollateral *EcpCollateralFilterer) ParseCollateralLocked(log types.Log) (*EcpCollateralCollateralLocked, error) {
	event := new(EcpCollateralCollateralLocked)
	if err := _EcpCollateral.contract.UnpackLog(event, "CollateralLocked", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// EcpCollateralCollateralSlashedIterator is returned from FilterCollateralSlashed and is used to iterate over the raw logs and unpacked data for CollateralSlashed events raised by the EcpCollateral contract.
type EcpCollateralCollateralSlashedIterator struct {
	Event *EcpCollateralCollateralSlashed // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *EcpCollateralCollateralSlashedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(EcpCollateralCollateralSlashed)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(EcpCollateralCollateralSlashed)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *EcpCollateralCollateralSlashedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *EcpCollateralCollateralSlashedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// EcpCollateralCollateralSlashed represents a CollateralSlashed event raised by the EcpCollateral contract.
type EcpCollateralCollateralSlashed struct {
	Cp     common.Address
	Amount *big.Int
	TaskID *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterCollateralSlashed is a free log retrieval operation binding the contract event 0xe23e4a65e8f09c2d92bbdfbe613a6007e35677ac2afed7f4eb690b5b93460bd9.
//
// Solidity: event CollateralSlashed(address indexed cp, uint256 amount, uint256 taskID)
func (_EcpCollateral *EcpCollateralFilterer) FilterCollateralSlashed(opts *bind.FilterOpts, cp []common.Address) (*EcpCollateralCollateralSlashedIterator, error) {

	var cpRule []interface{}
	for _, cpItem := range cp {
		cpRule = append(cpRule, cpItem)
	}

	logs, sub, err := _EcpCollateral.contract.FilterLogs(opts, "CollateralSlashed", cpRule)
	if err != nil {
		return nil, err
	}
	return &EcpCollateralCollateralSlashedIterator{contract: _EcpCollateral.contract, event: "CollateralSlashed", logs: logs, sub: sub}, nil
}

// WatchCollateralSlashed is a free log subscription operation binding the contract event 0xe23e4a65e8f09c2d92bbdfbe613a6007e35677ac2afed7f4eb690b5b93460bd9.
//
// Solidity: event CollateralSlashed(address indexed cp, uint256 amount, uint256 taskID)
func (_EcpCollateral *EcpCollateralFilterer) WatchCollateralSlashed(opts *bind.WatchOpts, sink chan<- *EcpCollateralCollateralSlashed, cp []common.Address) (event.Subscription, error) {

	var cpRule []interface{}
	for _, cpItem := range cp {
		cpRule = append(cpRule, cpItem)
	}

	logs, sub, err := _EcpCollateral.contract.WatchLogs(opts, "CollateralSlashed", cpRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(EcpCollateralCollateralSlashed)
				if err := _EcpCollateral.contract.UnpackLog(event, "CollateralSlashed", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseCollateralSlashed is a log parse operation binding the contract event 0xe23e4a65e8f09c2d92bbdfbe613a6007e35677ac2afed7f4eb690b5b93460bd9.
//
// Solidity: event CollateralSlashed(address indexed cp, uint256 amount, uint256 taskID)
func (_EcpCollateral *EcpCollateralFilterer) ParseCollateralSlashed(log types.Log) (*EcpCollateralCollateralSlashed, error) {
	event := new(EcpCollateralCollateralSlashed)
	if err := _EcpCollateral.contract.UnpackLog(event, "CollateralSlashed", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// EcpCollateralCollateralUnlockedIterator is returned from FilterCollateralUnlocked and is used to iterate over the raw logs and unpacked data for CollateralUnlocked events raised by the EcpCollateral contract.
type EcpCollateralCollateralUnlockedIterator struct {
	Event *EcpCollateralCollateralUnlocked // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *EcpCollateralCollateralUnlockedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(EcpCollateralCollateralUnlocked)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(EcpCollateralCollateralUnlocked)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *EcpCollateralCollateralUnlockedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *EcpCollateralCollateralUnlockedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// EcpCollateralCollateralUnlocked represents a CollateralUnlocked event raised by the EcpCollateral contract.
type EcpCollateralCollateralUnlocked struct {
	Cp               common.Address
	CollateralAmount *big.Int
	TaskID           *big.Int
	Raw              types.Log // Blockchain specific contextual infos
}

// FilterCollateralUnlocked is a free log retrieval operation binding the contract event 0xe8e7440c7efbb5d2d20a061fde9c0fa35db9764f5da8475a0090ea4f23466c84.
//
// Solidity: event CollateralUnlocked(address indexed cp, uint256 collateralAmount, uint256 taskID)
func (_EcpCollateral *EcpCollateralFilterer) FilterCollateralUnlocked(opts *bind.FilterOpts, cp []common.Address) (*EcpCollateralCollateralUnlockedIterator, error) {

	var cpRule []interface{}
	for _, cpItem := range cp {
		cpRule = append(cpRule, cpItem)
	}

	logs, sub, err := _EcpCollateral.contract.FilterLogs(opts, "CollateralUnlocked", cpRule)
	if err != nil {
		return nil, err
	}
	return &EcpCollateralCollateralUnlockedIterator{contract: _EcpCollateral.contract, event: "CollateralUnlocked", logs: logs, sub: sub}, nil
}

// WatchCollateralUnlocked is a free log subscription operation binding the contract event 0xe8e7440c7efbb5d2d20a061fde9c0fa35db9764f5da8475a0090ea4f23466c84.
//
// Solidity: event CollateralUnlocked(address indexed cp, uint256 collateralAmount, uint256 taskID)
func (_EcpCollateral *EcpCollateralFilterer) WatchCollateralUnlocked(opts *bind.WatchOpts, sink chan<- *EcpCollateralCollateralUnlocked, cp []common.Address) (event.Subscription, error) {

	var cpRule []interface{}
	for _, cpItem := range cp {
		cpRule = append(cpRule, cpItem)
	}

	logs, sub, err := _EcpCollateral.contract.WatchLogs(opts, "CollateralUnlocked", cpRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(EcpCollateralCollateralUnlocked)
				if err := _EcpCollateral.contract.UnpackLog(event, "CollateralUnlocked", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseCollateralUnlocked is a log parse operation binding the contract event 0xe8e7440c7efbb5d2d20a061fde9c0fa35db9764f5da8475a0090ea4f23466c84.
//
// Solidity: event CollateralUnlocked(address indexed cp, uint256 collateralAmount, uint256 taskID)
func (_EcpCollateral *EcpCollateralFilterer) ParseCollateralUnlocked(log types.Log) (*EcpCollateralCollateralUnlocked, error) {
	event := new(EcpCollateralCollateralUnlocked)
	if err := _EcpCollateral.contract.UnpackLog(event, "CollateralUnlocked", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// EcpCollateralDepositIterator is returned from FilterDeposit and is used to iterate over the raw logs and unpacked data for Deposit events raised by the EcpCollateral contract.
type EcpCollateralDepositIterator struct {
	Event *EcpCollateralDeposit // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *EcpCollateralDepositIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(EcpCollateralDeposit)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(EcpCollateralDeposit)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *EcpCollateralDepositIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *EcpCollateralDepositIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// EcpCollateralDeposit represents a Deposit event raised by the EcpCollateral contract.
type EcpCollateralDeposit struct {
	FundingWallet common.Address
	CpAccount     common.Address
	DepositAmount *big.Int
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterDeposit is a free log retrieval operation binding the contract event 0x5548c837ab068cf56a2c2479df0882a4922fd203edb7517321831d95078c5f62.
//
// Solidity: event Deposit(address indexed fundingWallet, address indexed cpAccount, uint256 depositAmount)
func (_EcpCollateral *EcpCollateralFilterer) FilterDeposit(opts *bind.FilterOpts, fundingWallet []common.Address, cpAccount []common.Address) (*EcpCollateralDepositIterator, error) {

	var fundingWalletRule []interface{}
	for _, fundingWalletItem := range fundingWallet {
		fundingWalletRule = append(fundingWalletRule, fundingWalletItem)
	}
	var cpAccountRule []interface{}
	for _, cpAccountItem := range cpAccount {
		cpAccountRule = append(cpAccountRule, cpAccountItem)
	}

	logs, sub, err := _EcpCollateral.contract.FilterLogs(opts, "Deposit", fundingWalletRule, cpAccountRule)
	if err != nil {
		return nil, err
	}
	return &EcpCollateralDepositIterator{contract: _EcpCollateral.contract, event: "Deposit", logs: logs, sub: sub}, nil
}

// WatchDeposit is a free log subscription operation binding the contract event 0x5548c837ab068cf56a2c2479df0882a4922fd203edb7517321831d95078c5f62.
//
// Solidity: event Deposit(address indexed fundingWallet, address indexed cpAccount, uint256 depositAmount)
func (_EcpCollateral *EcpCollateralFilterer) WatchDeposit(opts *bind.WatchOpts, sink chan<- *EcpCollateralDeposit, fundingWallet []common.Address, cpAccount []common.Address) (event.Subscription, error) {

	var fundingWalletRule []interface{}
	for _, fundingWalletItem := range fundingWallet {
		fundingWalletRule = append(fundingWalletRule, fundingWalletItem)
	}
	var cpAccountRule []interface{}
	for _, cpAccountItem := range cpAccount {
		cpAccountRule = append(cpAccountRule, cpAccountItem)
	}

	logs, sub, err := _EcpCollateral.contract.WatchLogs(opts, "Deposit", fundingWalletRule, cpAccountRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(EcpCollateralDeposit)
				if err := _EcpCollateral.contract.UnpackLog(event, "Deposit", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDeposit is a log parse operation binding the contract event 0x5548c837ab068cf56a2c2479df0882a4922fd203edb7517321831d95078c5f62.
//
// Solidity: event Deposit(address indexed fundingWallet, address indexed cpAccount, uint256 depositAmount)
func (_EcpCollateral *EcpCollateralFilterer) ParseDeposit(log types.Log) (*EcpCollateralDeposit, error) {
	event := new(EcpCollateralDeposit)
	if err := _EcpCollateral.contract.UnpackLog(event, "Deposit", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// EcpCollateralDisputeProofIterator is returned from FilterDisputeProof and is used to iterate over the raw logs and unpacked data for DisputeProof events raised by the EcpCollateral contract.
type EcpCollateralDisputeProofIterator struct {
	Event *EcpCollateralDisputeProof // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *EcpCollateralDisputeProofIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(EcpCollateralDisputeProof)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(EcpCollateralDisputeProof)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *EcpCollateralDisputeProofIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *EcpCollateralDisputeProofIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// EcpCollateralDisputeProof represents a DisputeProof event raised by the EcpCollateral contract.
type EcpCollateralDisputeProof struct {
	Challenger          common.Address
	TaskContractAddress common.Address
	Raw                 types.Log // Blockchain specific contextual infos
}

// FilterDisputeProof is a free log retrieval operation binding the contract event 0x1e61a07012c23d5019cb79991ed79d73a9fc17fb89182f5830f036bd544423f3.
//
// Solidity: event DisputeProof(address indexed challenger, address indexed taskContractAddress)
func (_EcpCollateral *EcpCollateralFilterer) FilterDisputeProof(opts *bind.FilterOpts, challenger []common.Address, taskContractAddress []common.Address) (*EcpCollateralDisputeProofIterator, error) {

	var challengerRule []interface{}
	for _, challengerItem := range challenger {
		challengerRule = append(challengerRule, challengerItem)
	}
	var taskContractAddressRule []interface{}
	for _, taskContractAddressItem := range taskContractAddress {
		taskContractAddressRule = append(taskContractAddressRule, taskContractAddressItem)
	}

	logs, sub, err := _EcpCollateral.contract.FilterLogs(opts, "DisputeProof", challengerRule, taskContractAddressRule)
	if err != nil {
		return nil, err
	}
	return &EcpCollateralDisputeProofIterator{contract: _EcpCollateral.contract, event: "DisputeProof", logs: logs, sub: sub}, nil
}

// WatchDisputeProof is a free log subscription operation binding the contract event 0x1e61a07012c23d5019cb79991ed79d73a9fc17fb89182f5830f036bd544423f3.
//
// Solidity: event DisputeProof(address indexed challenger, address indexed taskContractAddress)
func (_EcpCollateral *EcpCollateralFilterer) WatchDisputeProof(opts *bind.WatchOpts, sink chan<- *EcpCollateralDisputeProof, challenger []common.Address, taskContractAddress []common.Address) (event.Subscription, error) {

	var challengerRule []interface{}
	for _, challengerItem := range challenger {
		challengerRule = append(challengerRule, challengerItem)
	}
	var taskContractAddressRule []interface{}
	for _, taskContractAddressItem := range taskContractAddress {
		taskContractAddressRule = append(taskContractAddressRule, taskContractAddressItem)
	}

	logs, sub, err := _EcpCollateral.contract.WatchLogs(opts, "DisputeProof", challengerRule, taskContractAddressRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(EcpCollateralDisputeProof)
				if err := _EcpCollateral.contract.UnpackLog(event, "DisputeProof", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDisputeProof is a log parse operation binding the contract event 0x1e61a07012c23d5019cb79991ed79d73a9fc17fb89182f5830f036bd544423f3.
//
// Solidity: event DisputeProof(address indexed challenger, address indexed taskContractAddress)
func (_EcpCollateral *EcpCollateralFilterer) ParseDisputeProof(log types.Log) (*EcpCollateralDisputeProof, error) {
	event := new(EcpCollateralDisputeProof)
	if err := _EcpCollateral.contract.UnpackLog(event, "DisputeProof", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// EcpCollateralOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the EcpCollateral contract.
type EcpCollateralOwnershipTransferredIterator struct {
	Event *EcpCollateralOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *EcpCollateralOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(EcpCollateralOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(EcpCollateralOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *EcpCollateralOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *EcpCollateralOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// EcpCollateralOwnershipTransferred represents a OwnershipTransferred event raised by the EcpCollateral contract.
type EcpCollateralOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_EcpCollateral *EcpCollateralFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*EcpCollateralOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _EcpCollateral.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &EcpCollateralOwnershipTransferredIterator{contract: _EcpCollateral.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_EcpCollateral *EcpCollateralFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *EcpCollateralOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _EcpCollateral.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(EcpCollateralOwnershipTransferred)
				if err := _EcpCollateral.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_EcpCollateral *EcpCollateralFilterer) ParseOwnershipTransferred(log types.Log) (*EcpCollateralOwnershipTransferred, error) {
	event := new(EcpCollateralOwnershipTransferred)
	if err := _EcpCollateral.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// EcpCollateralTaskCreatedIterator is returned from FilterTaskCreated and is used to iterate over the raw logs and unpacked data for TaskCreated events raised by the EcpCollateral contract.
type EcpCollateralTaskCreatedIterator struct {
	Event *EcpCollateralTaskCreated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *EcpCollateralTaskCreatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(EcpCollateralTaskCreated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(EcpCollateralTaskCreated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *EcpCollateralTaskCreatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *EcpCollateralTaskCreatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// EcpCollateralTaskCreated represents a TaskCreated event raised by the EcpCollateral contract.
type EcpCollateralTaskCreated struct {
	TaskID           *big.Int
	CpAccountAddress common.Address
	Collateral       *big.Int
	Raw              types.Log // Blockchain specific contextual infos
}

// FilterTaskCreated is a free log retrieval operation binding the contract event 0x6cf53aa7292e664152c2ea948c3b3c95d4b05c36daeb2626d0293473c4a4a153.
//
// Solidity: event TaskCreated(uint256 indexed taskID, address cpAccountAddress, uint256 collateral)
func (_EcpCollateral *EcpCollateralFilterer) FilterTaskCreated(opts *bind.FilterOpts, taskID []*big.Int) (*EcpCollateralTaskCreatedIterator, error) {

	var taskIDRule []interface{}
	for _, taskIDItem := range taskID {
		taskIDRule = append(taskIDRule, taskIDItem)
	}

	logs, sub, err := _EcpCollateral.contract.FilterLogs(opts, "TaskCreated", taskIDRule)
	if err != nil {
		return nil, err
	}
	return &EcpCollateralTaskCreatedIterator{contract: _EcpCollateral.contract, event: "TaskCreated", logs: logs, sub: sub}, nil
}

// WatchTaskCreated is a free log subscription operation binding the contract event 0x6cf53aa7292e664152c2ea948c3b3c95d4b05c36daeb2626d0293473c4a4a153.
//
// Solidity: event TaskCreated(uint256 indexed taskID, address cpAccountAddress, uint256 collateral)
func (_EcpCollateral *EcpCollateralFilterer) WatchTaskCreated(opts *bind.WatchOpts, sink chan<- *EcpCollateralTaskCreated, taskID []*big.Int) (event.Subscription, error) {

	var taskIDRule []interface{}
	for _, taskIDItem := range taskID {
		taskIDRule = append(taskIDRule, taskIDItem)
	}

	logs, sub, err := _EcpCollateral.contract.WatchLogs(opts, "TaskCreated", taskIDRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(EcpCollateralTaskCreated)
				if err := _EcpCollateral.contract.UnpackLog(event, "TaskCreated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTaskCreated is a log parse operation binding the contract event 0x6cf53aa7292e664152c2ea948c3b3c95d4b05c36daeb2626d0293473c4a4a153.
//
// Solidity: event TaskCreated(uint256 indexed taskID, address cpAccountAddress, uint256 collateral)
func (_EcpCollateral *EcpCollateralFilterer) ParseTaskCreated(log types.Log) (*EcpCollateralTaskCreated, error) {
	event := new(EcpCollateralTaskCreated)
	if err := _EcpCollateral.contract.UnpackLog(event, "TaskCreated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// EcpCollateralTaskStatusChangedIterator is returned from FilterTaskStatusChanged and is used to iterate over the raw logs and unpacked data for TaskStatusChanged events raised by the EcpCollateral contract.
type EcpCollateralTaskStatusChangedIterator struct {
	Event *EcpCollateralTaskStatusChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *EcpCollateralTaskStatusChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(EcpCollateralTaskStatusChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(EcpCollateralTaskStatusChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *EcpCollateralTaskStatusChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *EcpCollateralTaskStatusChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// EcpCollateralTaskStatusChanged represents a TaskStatusChanged event raised by the EcpCollateral contract.
type EcpCollateralTaskStatusChanged struct {
	TaskID    *big.Int
	NewStatus *big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterTaskStatusChanged is a free log retrieval operation binding the contract event 0x857a475dc812e506ac81a9f3ffc00638593b96a880e2543da02a1a6b38f51f39.
//
// Solidity: event TaskStatusChanged(uint256 indexed taskID, uint256 newStatus)
func (_EcpCollateral *EcpCollateralFilterer) FilterTaskStatusChanged(opts *bind.FilterOpts, taskID []*big.Int) (*EcpCollateralTaskStatusChangedIterator, error) {

	var taskIDRule []interface{}
	for _, taskIDItem := range taskID {
		taskIDRule = append(taskIDRule, taskIDItem)
	}

	logs, sub, err := _EcpCollateral.contract.FilterLogs(opts, "TaskStatusChanged", taskIDRule)
	if err != nil {
		return nil, err
	}
	return &EcpCollateralTaskStatusChangedIterator{contract: _EcpCollateral.contract, event: "TaskStatusChanged", logs: logs, sub: sub}, nil
}

// WatchTaskStatusChanged is a free log subscription operation binding the contract event 0x857a475dc812e506ac81a9f3ffc00638593b96a880e2543da02a1a6b38f51f39.
//
// Solidity: event TaskStatusChanged(uint256 indexed taskID, uint256 newStatus)
func (_EcpCollateral *EcpCollateralFilterer) WatchTaskStatusChanged(opts *bind.WatchOpts, sink chan<- *EcpCollateralTaskStatusChanged, taskID []*big.Int) (event.Subscription, error) {

	var taskIDRule []interface{}
	for _, taskIDItem := range taskID {
		taskIDRule = append(taskIDRule, taskIDItem)
	}

	logs, sub, err := _EcpCollateral.contract.WatchLogs(opts, "TaskStatusChanged", taskIDRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(EcpCollateralTaskStatusChanged)
				if err := _EcpCollateral.contract.UnpackLog(event, "TaskStatusChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTaskStatusChanged is a log parse operation binding the contract event 0x857a475dc812e506ac81a9f3ffc00638593b96a880e2543da02a1a6b38f51f39.
//
// Solidity: event TaskStatusChanged(uint256 indexed taskID, uint256 newStatus)
func (_EcpCollateral *EcpCollateralFilterer) ParseTaskStatusChanged(log types.Log) (*EcpCollateralTaskStatusChanged, error) {
	event := new(EcpCollateralTaskStatusChanged)
	if err := _EcpCollateral.contract.UnpackLog(event, "TaskStatusChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// EcpCollateralWithdrawIterator is returned from FilterWithdraw and is used to iterate over the raw logs and unpacked data for Withdraw events raised by the EcpCollateral contract.
type EcpCollateralWithdrawIterator struct {
	Event *EcpCollateralWithdraw // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *EcpCollateralWithdrawIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(EcpCollateralWithdraw)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(EcpCollateralWithdraw)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *EcpCollateralWithdrawIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *EcpCollateralWithdrawIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// EcpCollateralWithdraw represents a Withdraw event raised by the EcpCollateral contract.
type EcpCollateralWithdraw struct {
	CpOwner        common.Address
	CpAccount      common.Address
	WithdrawAmount *big.Int
	Raw            types.Log // Blockchain specific contextual infos
}

// FilterWithdraw is a free log retrieval operation binding the contract event 0x9b1bfa7fa9ee420a16e124f794c35ac9f90472acc99140eb2f6447c714cad8eb.
//
// Solidity: event Withdraw(address indexed cpOwner, address indexed cpAccount, uint256 withdrawAmount)
func (_EcpCollateral *EcpCollateralFilterer) FilterWithdraw(opts *bind.FilterOpts, cpOwner []common.Address, cpAccount []common.Address) (*EcpCollateralWithdrawIterator, error) {

	var cpOwnerRule []interface{}
	for _, cpOwnerItem := range cpOwner {
		cpOwnerRule = append(cpOwnerRule, cpOwnerItem)
	}
	var cpAccountRule []interface{}
	for _, cpAccountItem := range cpAccount {
		cpAccountRule = append(cpAccountRule, cpAccountItem)
	}

	logs, sub, err := _EcpCollateral.contract.FilterLogs(opts, "Withdraw", cpOwnerRule, cpAccountRule)
	if err != nil {
		return nil, err
	}
	return &EcpCollateralWithdrawIterator{contract: _EcpCollateral.contract, event: "Withdraw", logs: logs, sub: sub}, nil
}

// WatchWithdraw is a free log subscription operation binding the contract event 0x9b1bfa7fa9ee420a16e124f794c35ac9f90472acc99140eb2f6447c714cad8eb.
//
// Solidity: event Withdraw(address indexed cpOwner, address indexed cpAccount, uint256 withdrawAmount)
func (_EcpCollateral *EcpCollateralFilterer) WatchWithdraw(opts *bind.WatchOpts, sink chan<- *EcpCollateralWithdraw, cpOwner []common.Address, cpAccount []common.Address) (event.Subscription, error) {

	var cpOwnerRule []interface{}
	for _, cpOwnerItem := range cpOwner {
		cpOwnerRule = append(cpOwnerRule, cpOwnerItem)
	}
	var cpAccountRule []interface{}
	for _, cpAccountItem := range cpAccount {
		cpAccountRule = append(cpAccountRule, cpAccountItem)
	}

	logs, sub, err := _EcpCollateral.contract.WatchLogs(opts, "Withdraw", cpOwnerRule, cpAccountRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(EcpCollateralWithdraw)
				if err := _EcpCollateral.contract.UnpackLog(event, "Withdraw", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseWithdraw is a log parse operation binding the contract event 0x9b1bfa7fa9ee420a16e124f794c35ac9f90472acc99140eb2f6447c714cad8eb.
//
// Solidity: event Withdraw(address indexed cpOwner, address indexed cpAccount, uint256 withdrawAmount)
func (_EcpCollateral *EcpCollateralFilterer) ParseWithdraw(log types.Log) (*EcpCollateralWithdraw, error) {
	event := new(EcpCollateralWithdraw)
	if err := _EcpCollateral.contract.UnpackLog(event, "Withdraw", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// EcpCollateralWithdrawSlashIterator is returned from FilterWithdrawSlash and is used to iterate over the raw logs and unpacked data for WithdrawSlash events raised by the EcpCollateral contract.
type EcpCollateralWithdrawSlashIterator struct {
	Event *EcpCollateralWithdrawSlash // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *EcpCollateralWithdrawSlashIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(EcpCollateralWithdrawSlash)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(EcpCollateralWithdrawSlash)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *EcpCollateralWithdrawSlashIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *EcpCollateralWithdrawSlashIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// EcpCollateralWithdrawSlash represents a WithdrawSlash event raised by the EcpCollateral contract.
type EcpCollateralWithdrawSlash struct {
	CollateralContratOwner common.Address
	Slashfund              *big.Int
	Raw                    types.Log // Blockchain specific contextual infos
}

// FilterWithdrawSlash is a free log retrieval operation binding the contract event 0xbfd9c82485e2178fcfd5c40379d8e66fe60acc50aa1ef4c50966431eb1e381cd.
//
// Solidity: event WithdrawSlash(address indexed collateralContratOwner, uint256 slashfund)
func (_EcpCollateral *EcpCollateralFilterer) FilterWithdrawSlash(opts *bind.FilterOpts, collateralContratOwner []common.Address) (*EcpCollateralWithdrawSlashIterator, error) {

	var collateralContratOwnerRule []interface{}
	for _, collateralContratOwnerItem := range collateralContratOwner {
		collateralContratOwnerRule = append(collateralContratOwnerRule, collateralContratOwnerItem)
	}

	logs, sub, err := _EcpCollateral.contract.FilterLogs(opts, "WithdrawSlash", collateralContratOwnerRule)
	if err != nil {
		return nil, err
	}
	return &EcpCollateralWithdrawSlashIterator{contract: _EcpCollateral.contract, event: "WithdrawSlash", logs: logs, sub: sub}, nil
}

// WatchWithdrawSlash is a free log subscription operation binding the contract event 0xbfd9c82485e2178fcfd5c40379d8e66fe60acc50aa1ef4c50966431eb1e381cd.
//
// Solidity: event WithdrawSlash(address indexed collateralContratOwner, uint256 slashfund)
func (_EcpCollateral *EcpCollateralFilterer) WatchWithdrawSlash(opts *bind.WatchOpts, sink chan<- *EcpCollateralWithdrawSlash, collateralContratOwner []common.Address) (event.Subscription, error) {

	var collateralContratOwnerRule []interface{}
	for _, collateralContratOwnerItem := range collateralContratOwner {
		collateralContratOwnerRule = append(collateralContratOwnerRule, collateralContratOwnerItem)
	}

	logs, sub, err := _EcpCollateral.contract.WatchLogs(opts, "WithdrawSlash", collateralContratOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(EcpCollateralWithdrawSlash)
				if err := _EcpCollateral.contract.UnpackLog(event, "WithdrawSlash", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseWithdrawSlash is a log parse operation binding the contract event 0xbfd9c82485e2178fcfd5c40379d8e66fe60acc50aa1ef4c50966431eb1e381cd.
//
// Solidity: event WithdrawSlash(address indexed collateralContratOwner, uint256 slashfund)
func (_EcpCollateral *EcpCollateralFilterer) ParseWithdrawSlash(log types.Log) (*EcpCollateralWithdrawSlash, error) {
	event := new(EcpCollateralWithdrawSlash)
	if err := _EcpCollateral.contract.UnpackLog(event, "WithdrawSlash", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}
